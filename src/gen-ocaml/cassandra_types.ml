(*
 Autogenerated by Thrift

 DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING
*)

open Thrift
module ConsistencyLevel = 
struct
  type t = 
    | ZERO
    | ONE
    | QUORUM
    | DCQUORUM
    | DCQUORUMSYNC
    | ALL
    | ANY
  let to_i = function
    | ZERO -> 0
    | ONE -> 1
    | QUORUM -> 2
    | DCQUORUM -> 3
    | DCQUORUMSYNC -> 4
    | ALL -> 5
    | ANY -> 6
  let of_i = function
    | 0 -> ZERO
    | 1 -> ONE
    | 2 -> QUORUM
    | 3 -> DCQUORUM
    | 4 -> DCQUORUMSYNC
    | 5 -> ALL
    | 6 -> ANY
    | n -> raise (Thrift_error (Printf.sprintf "Unknown ConsistencyLevel: %d" n))
end
module IndexOperator = 
struct
  type t = 
    | EQ
    | GTE
    | GT
    | LTE
    | LT
  let to_i = function
    | EQ -> 0
    | GTE -> 1
    | GT -> 2
    | LTE -> 3
    | LT -> 4
  let of_i = function
    | 0 -> EQ
    | 1 -> GTE
    | 2 -> GT
    | 3 -> LTE
    | 4 -> LT
    | n -> raise (Thrift_error (Printf.sprintf "Unknown IndexOperator: %d" n))
end
module IndexType = 
struct
  type t = 
    | KEYS
  let to_i = function
    | KEYS -> 0
  let of_i = function
    | 0 -> KEYS
    | n -> raise (Thrift_error (Printf.sprintf "Unknown IndexType: %d" n))
end
class column =
object (self)
  val mutable _name : string option = None
  method get_name = _name
  method grab_name = match _name with None->raise (Field_empty "column.name") | Some _x0 -> _x0
  method set_name _x0 = _name <- Some _x0
  val mutable _value : string option = None
  method get_value = _value
  method grab_value = match _value with None->raise (Field_empty "column.value") | Some _x0 -> _x0
  method set_value _x0 = _value <- Some _x0
  val mutable _timestamp : Int64.t option = None
  method get_timestamp = _timestamp
  method grab_timestamp = match _timestamp with None->raise (Field_empty "column.timestamp") | Some _x0 -> _x0
  method set_timestamp _x0 = _timestamp <- Some _x0
  val mutable _ttl : int option = None
  method get_ttl = _ttl
  method grab_ttl = match _ttl with None->raise (Field_empty "column.ttl") | Some _x0 -> _x0
  method set_ttl _x0 = _ttl <- Some _x0
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "Column";
    (match _name with None -> () | Some _v -> 
      oprot#writeFieldBegin("name",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _value with None -> () | Some _v -> 
      oprot#writeFieldBegin("value",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _timestamp with None -> () | Some _v -> 
      oprot#writeFieldBegin("timestamp",Protocol.T_I64,3);
      oprot#writeI64(_v);
      oprot#writeFieldEnd
    );
    (match _ttl with None -> () | Some _v -> 
      oprot#writeFieldBegin("ttl",Protocol.T_I32,4);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_column (iprot : Protocol.t) =
  let _str3 = new column in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t4,_id5) = iprot#readFieldBegin in
        if _t4 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id5 with 
          | 1 -> (if _t4 = Protocol.T_STRING then
              _str3#set_name iprot#readString
            else
              iprot#skip _t4)
          | 2 -> (if _t4 = Protocol.T_STRING then
              _str3#set_value iprot#readString
            else
              iprot#skip _t4)
          | 3 -> (if _t4 = Protocol.T_I64 then
              _str3#set_timestamp iprot#readI64
            else
              iprot#skip _t4)
          | 4 -> (if _t4 = Protocol.T_I32 then
              _str3#set_ttl iprot#readI32
            else
              iprot#skip _t4)
          | _ -> iprot#skip _t4);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str3

class superColumn =
object (self)
  val mutable _name : string option = None
  method get_name = _name
  method grab_name = match _name with None->raise (Field_empty "superColumn.name") | Some _x7 -> _x7
  method set_name _x7 = _name <- Some _x7
  val mutable _columns : column list option = None
  method get_columns = _columns
  method grab_columns = match _columns with None->raise (Field_empty "superColumn.columns") | Some _x7 -> _x7
  method set_columns _x7 = _columns <- Some _x7
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "SuperColumn";
    (match _name with None -> () | Some _v -> 
      oprot#writeFieldBegin("name",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _columns with None -> () | Some _v -> 
      oprot#writeFieldBegin("columns",Protocol.T_LIST,2);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter10 ->         _iter10#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_superColumn (iprot : Protocol.t) =
  let _str11 = new superColumn in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t12,_id13) = iprot#readFieldBegin in
        if _t12 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id13 with 
          | 1 -> (if _t12 = Protocol.T_STRING then
              _str11#set_name iprot#readString
            else
              iprot#skip _t12)
          | 2 -> (if _t12 = Protocol.T_LIST then
              _str11#set_columns 
                (let (_etype17,_size14) = iprot#readListBegin in
                  let _con18 = (Array.to_list (Array.init _size14 (fun _ -> (read_column iprot)))) in
                    iprot#readListEnd; _con18)
            else
              iprot#skip _t12)
          | _ -> iprot#skip _t12);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str11

class columnOrSuperColumn =
object (self)
  val mutable _column : column option = None
  method get_column = _column
  method grab_column = match _column with None->raise (Field_empty "columnOrSuperColumn.column") | Some _x20 -> _x20
  method set_column _x20 = _column <- Some _x20
  val mutable _super_column : superColumn option = None
  method get_super_column = _super_column
  method grab_super_column = match _super_column with None->raise (Field_empty "columnOrSuperColumn.super_column") | Some _x20 -> _x20
  method set_super_column _x20 = _super_column <- Some _x20
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "ColumnOrSuperColumn";
    (match _column with None -> () | Some _v -> 
      oprot#writeFieldBegin("column",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _super_column with None -> () | Some _v -> 
      oprot#writeFieldBegin("super_column",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_columnOrSuperColumn (iprot : Protocol.t) =
  let _str23 = new columnOrSuperColumn in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t24,_id25) = iprot#readFieldBegin in
        if _t24 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id25 with 
          | 1 -> (if _t24 = Protocol.T_STRUCT then
              _str23#set_column (read_column iprot)
            else
              iprot#skip _t24)
          | 2 -> (if _t24 = Protocol.T_STRUCT then
              _str23#set_super_column (read_superColumn iprot)
            else
              iprot#skip _t24)
          | _ -> iprot#skip _t24);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str23

class columnParent =
object (self)
  val mutable _column_family : string option = None
  method get_column_family = _column_family
  method grab_column_family = match _column_family with None->raise (Field_empty "columnParent.column_family") | Some _x27 -> _x27
  method set_column_family _x27 = _column_family <- Some _x27
  val mutable _super_column : string option = None
  method get_super_column = _super_column
  method grab_super_column = match _super_column with None->raise (Field_empty "columnParent.super_column") | Some _x27 -> _x27
  method set_super_column _x27 = _super_column <- Some _x27
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "ColumnParent";
    (match _column_family with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_family",Protocol.T_STRING,3);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _super_column with None -> () | Some _v -> 
      oprot#writeFieldBegin("super_column",Protocol.T_STRING,4);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_columnParent (iprot : Protocol.t) =
  let _str30 = new columnParent in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t31,_id32) = iprot#readFieldBegin in
        if _t31 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id32 with 
          | 3 -> (if _t31 = Protocol.T_STRING then
              _str30#set_column_family iprot#readString
            else
              iprot#skip _t31)
          | 4 -> (if _t31 = Protocol.T_STRING then
              _str30#set_super_column iprot#readString
            else
              iprot#skip _t31)
          | _ -> iprot#skip _t31);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str30

class columnPath =
object (self)
  val mutable _column_family : string option = None
  method get_column_family = _column_family
  method grab_column_family = match _column_family with None->raise (Field_empty "columnPath.column_family") | Some _x34 -> _x34
  method set_column_family _x34 = _column_family <- Some _x34
  val mutable _super_column : string option = None
  method get_super_column = _super_column
  method grab_super_column = match _super_column with None->raise (Field_empty "columnPath.super_column") | Some _x34 -> _x34
  method set_super_column _x34 = _super_column <- Some _x34
  val mutable _column : string option = None
  method get_column = _column
  method grab_column = match _column with None->raise (Field_empty "columnPath.column") | Some _x34 -> _x34
  method set_column _x34 = _column <- Some _x34
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "ColumnPath";
    (match _column_family with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_family",Protocol.T_STRING,3);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _super_column with None -> () | Some _v -> 
      oprot#writeFieldBegin("super_column",Protocol.T_STRING,4);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _column with None -> () | Some _v -> 
      oprot#writeFieldBegin("column",Protocol.T_STRING,5);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_columnPath (iprot : Protocol.t) =
  let _str37 = new columnPath in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t38,_id39) = iprot#readFieldBegin in
        if _t38 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id39 with 
          | 3 -> (if _t38 = Protocol.T_STRING then
              _str37#set_column_family iprot#readString
            else
              iprot#skip _t38)
          | 4 -> (if _t38 = Protocol.T_STRING then
              _str37#set_super_column iprot#readString
            else
              iprot#skip _t38)
          | 5 -> (if _t38 = Protocol.T_STRING then
              _str37#set_column iprot#readString
            else
              iprot#skip _t38)
          | _ -> iprot#skip _t38);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str37

class sliceRange =
object (self)
  val mutable _start : string option = None
  method get_start = _start
  method grab_start = match _start with None->raise (Field_empty "sliceRange.start") | Some _x41 -> _x41
  method set_start _x41 = _start <- Some _x41
  val mutable _finish : string option = None
  method get_finish = _finish
  method grab_finish = match _finish with None->raise (Field_empty "sliceRange.finish") | Some _x41 -> _x41
  method set_finish _x41 = _finish <- Some _x41
  val mutable _reversed : bool option = None
  method get_reversed = _reversed
  method grab_reversed = match _reversed with None->raise (Field_empty "sliceRange.reversed") | Some _x41 -> _x41
  method set_reversed _x41 = _reversed <- Some _x41
  val mutable _count : int option = None
  method get_count = _count
  method grab_count = match _count with None->raise (Field_empty "sliceRange.count") | Some _x41 -> _x41
  method set_count _x41 = _count <- Some _x41
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "SliceRange";
    (match _start with None -> () | Some _v -> 
      oprot#writeFieldBegin("start",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _finish with None -> () | Some _v -> 
      oprot#writeFieldBegin("finish",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _reversed with None -> () | Some _v -> 
      oprot#writeFieldBegin("reversed",Protocol.T_BOOL,3);
      oprot#writeBool(_v);
      oprot#writeFieldEnd
    );
    (match _count with None -> () | Some _v -> 
      oprot#writeFieldBegin("count",Protocol.T_I32,4);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_sliceRange (iprot : Protocol.t) =
  let _str44 = new sliceRange in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t45,_id46) = iprot#readFieldBegin in
        if _t45 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id46 with 
          | 1 -> (if _t45 = Protocol.T_STRING then
              _str44#set_start iprot#readString
            else
              iprot#skip _t45)
          | 2 -> (if _t45 = Protocol.T_STRING then
              _str44#set_finish iprot#readString
            else
              iprot#skip _t45)
          | 3 -> (if _t45 = Protocol.T_BOOL then
              _str44#set_reversed iprot#readBool
            else
              iprot#skip _t45)
          | 4 -> (if _t45 = Protocol.T_I32 then
              _str44#set_count iprot#readI32
            else
              iprot#skip _t45)
          | _ -> iprot#skip _t45);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str44

class slicePredicate =
object (self)
  val mutable _column_names : string list option = None
  method get_column_names = _column_names
  method grab_column_names = match _column_names with None->raise (Field_empty "slicePredicate.column_names") | Some _x48 -> _x48
  method set_column_names _x48 = _column_names <- Some _x48
  val mutable _slice_range : sliceRange option = None
  method get_slice_range = _slice_range
  method grab_slice_range = match _slice_range with None->raise (Field_empty "slicePredicate.slice_range") | Some _x48 -> _x48
  method set_slice_range _x48 = _slice_range <- Some _x48
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "SlicePredicate";
    (match _column_names with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_names",Protocol.T_LIST,1);
      oprot#writeListBegin(Protocol.T_STRING,List.length _v);
      List.iter (fun _iter51 ->         oprot#writeString(_iter51);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _slice_range with None -> () | Some _v -> 
      oprot#writeFieldBegin("slice_range",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_slicePredicate (iprot : Protocol.t) =
  let _str52 = new slicePredicate in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t53,_id54) = iprot#readFieldBegin in
        if _t53 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id54 with 
          | 1 -> (if _t53 = Protocol.T_LIST then
              _str52#set_column_names 
                (let (_etype58,_size55) = iprot#readListBegin in
                  let _con59 = (Array.to_list (Array.init _size55 (fun _ -> iprot#readString))) in
                    iprot#readListEnd; _con59)
            else
              iprot#skip _t53)
          | 2 -> (if _t53 = Protocol.T_STRUCT then
              _str52#set_slice_range (read_sliceRange iprot)
            else
              iprot#skip _t53)
          | _ -> iprot#skip _t53);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str52

class indexExpression =
object (self)
  val mutable _column_name : string option = None
  method get_column_name = _column_name
  method grab_column_name = match _column_name with None->raise (Field_empty "indexExpression.column_name") | Some _x61 -> _x61
  method set_column_name _x61 = _column_name <- Some _x61
  val mutable _op : IndexOperator.t option = None
  method get_op = _op
  method grab_op = match _op with None->raise (Field_empty "indexExpression.op") | Some _x61 -> _x61
  method set_op _x61 = _op <- Some _x61
  val mutable _value : string option = None
  method get_value = _value
  method grab_value = match _value with None->raise (Field_empty "indexExpression.value") | Some _x61 -> _x61
  method set_value _x61 = _value <- Some _x61
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "IndexExpression";
    (match _column_name with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_name",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _op with None -> () | Some _v -> 
      oprot#writeFieldBegin("op",Protocol.T_I32,2);
      oprot#writeI32(IndexOperator.to_i _v);
      oprot#writeFieldEnd
    );
    (match _value with None -> () | Some _v -> 
      oprot#writeFieldBegin("value",Protocol.T_STRING,3);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_indexExpression (iprot : Protocol.t) =
  let _str64 = new indexExpression in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t65,_id66) = iprot#readFieldBegin in
        if _t65 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id66 with 
          | 1 -> (if _t65 = Protocol.T_STRING then
              _str64#set_column_name iprot#readString
            else
              iprot#skip _t65)
          | 2 -> (if _t65 = Protocol.T_I32 then
              _str64#set_op (IndexOperator.of_i iprot#readI32)
            else
              iprot#skip _t65)
          | 3 -> (if _t65 = Protocol.T_STRING then
              _str64#set_value iprot#readString
            else
              iprot#skip _t65)
          | _ -> iprot#skip _t65);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str64

class indexClause =
object (self)
  val mutable _expressions : indexExpression list option = None
  method get_expressions = _expressions
  method grab_expressions = match _expressions with None->raise (Field_empty "indexClause.expressions") | Some _x68 -> _x68
  method set_expressions _x68 = _expressions <- Some _x68
  val mutable _start_key : string option = None
  method get_start_key = _start_key
  method grab_start_key = match _start_key with None->raise (Field_empty "indexClause.start_key") | Some _x68 -> _x68
  method set_start_key _x68 = _start_key <- Some _x68
  val mutable _count : int option = None
  method get_count = _count
  method grab_count = match _count with None->raise (Field_empty "indexClause.count") | Some _x68 -> _x68
  method set_count _x68 = _count <- Some _x68
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "IndexClause";
    (match _expressions with None -> () | Some _v -> 
      oprot#writeFieldBegin("expressions",Protocol.T_LIST,1);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter71 ->         _iter71#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _start_key with None -> () | Some _v -> 
      oprot#writeFieldBegin("start_key",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _count with None -> () | Some _v -> 
      oprot#writeFieldBegin("count",Protocol.T_I32,3);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_indexClause (iprot : Protocol.t) =
  let _str72 = new indexClause in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t73,_id74) = iprot#readFieldBegin in
        if _t73 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id74 with 
          | 1 -> (if _t73 = Protocol.T_LIST then
              _str72#set_expressions 
                (let (_etype78,_size75) = iprot#readListBegin in
                  let _con79 = (Array.to_list (Array.init _size75 (fun _ -> (read_indexExpression iprot)))) in
                    iprot#readListEnd; _con79)
            else
              iprot#skip _t73)
          | 2 -> (if _t73 = Protocol.T_STRING then
              _str72#set_start_key iprot#readString
            else
              iprot#skip _t73)
          | 3 -> (if _t73 = Protocol.T_I32 then
              _str72#set_count iprot#readI32
            else
              iprot#skip _t73)
          | _ -> iprot#skip _t73);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str72

class keyRange =
object (self)
  val mutable _start_key : string option = None
  method get_start_key = _start_key
  method grab_start_key = match _start_key with None->raise (Field_empty "keyRange.start_key") | Some _x81 -> _x81
  method set_start_key _x81 = _start_key <- Some _x81
  val mutable _end_key : string option = None
  method get_end_key = _end_key
  method grab_end_key = match _end_key with None->raise (Field_empty "keyRange.end_key") | Some _x81 -> _x81
  method set_end_key _x81 = _end_key <- Some _x81
  val mutable _start_token : string option = None
  method get_start_token = _start_token
  method grab_start_token = match _start_token with None->raise (Field_empty "keyRange.start_token") | Some _x81 -> _x81
  method set_start_token _x81 = _start_token <- Some _x81
  val mutable _end_token : string option = None
  method get_end_token = _end_token
  method grab_end_token = match _end_token with None->raise (Field_empty "keyRange.end_token") | Some _x81 -> _x81
  method set_end_token _x81 = _end_token <- Some _x81
  val mutable _count : int option = None
  method get_count = _count
  method grab_count = match _count with None->raise (Field_empty "keyRange.count") | Some _x81 -> _x81
  method set_count _x81 = _count <- Some _x81
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "KeyRange";
    (match _start_key with None -> () | Some _v -> 
      oprot#writeFieldBegin("start_key",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _end_key with None -> () | Some _v -> 
      oprot#writeFieldBegin("end_key",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _start_token with None -> () | Some _v -> 
      oprot#writeFieldBegin("start_token",Protocol.T_STRING,3);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _end_token with None -> () | Some _v -> 
      oprot#writeFieldBegin("end_token",Protocol.T_STRING,4);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _count with None -> () | Some _v -> 
      oprot#writeFieldBegin("count",Protocol.T_I32,5);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_keyRange (iprot : Protocol.t) =
  let _str84 = new keyRange in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t85,_id86) = iprot#readFieldBegin in
        if _t85 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id86 with 
          | 1 -> (if _t85 = Protocol.T_STRING then
              _str84#set_start_key iprot#readString
            else
              iprot#skip _t85)
          | 2 -> (if _t85 = Protocol.T_STRING then
              _str84#set_end_key iprot#readString
            else
              iprot#skip _t85)
          | 3 -> (if _t85 = Protocol.T_STRING then
              _str84#set_start_token iprot#readString
            else
              iprot#skip _t85)
          | 4 -> (if _t85 = Protocol.T_STRING then
              _str84#set_end_token iprot#readString
            else
              iprot#skip _t85)
          | 5 -> (if _t85 = Protocol.T_I32 then
              _str84#set_count iprot#readI32
            else
              iprot#skip _t85)
          | _ -> iprot#skip _t85);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str84

class keySlice =
object (self)
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "keySlice.key") | Some _x88 -> _x88
  method set_key _x88 = _key <- Some _x88
  val mutable _columns : columnOrSuperColumn list option = None
  method get_columns = _columns
  method grab_columns = match _columns with None->raise (Field_empty "keySlice.columns") | Some _x88 -> _x88
  method set_columns _x88 = _columns <- Some _x88
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "KeySlice";
    (match _key with None -> () | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _columns with None -> () | Some _v -> 
      oprot#writeFieldBegin("columns",Protocol.T_LIST,2);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter91 ->         _iter91#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_keySlice (iprot : Protocol.t) =
  let _str92 = new keySlice in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t93,_id94) = iprot#readFieldBegin in
        if _t93 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id94 with 
          | 1 -> (if _t93 = Protocol.T_STRING then
              _str92#set_key iprot#readString
            else
              iprot#skip _t93)
          | 2 -> (if _t93 = Protocol.T_LIST then
              _str92#set_columns 
                (let (_etype98,_size95) = iprot#readListBegin in
                  let _con99 = (Array.to_list (Array.init _size95 (fun _ -> (read_columnOrSuperColumn iprot)))) in
                    iprot#readListEnd; _con99)
            else
              iprot#skip _t93)
          | _ -> iprot#skip _t93);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str92

class keyCount =
object (self)
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "keyCount.key") | Some _x101 -> _x101
  method set_key _x101 = _key <- Some _x101
  val mutable _count : int option = None
  method get_count = _count
  method grab_count = match _count with None->raise (Field_empty "keyCount.count") | Some _x101 -> _x101
  method set_count _x101 = _count <- Some _x101
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "KeyCount";
    (match _key with None -> () | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _count with None -> () | Some _v -> 
      oprot#writeFieldBegin("count",Protocol.T_I32,2);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_keyCount (iprot : Protocol.t) =
  let _str104 = new keyCount in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t105,_id106) = iprot#readFieldBegin in
        if _t105 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id106 with 
          | 1 -> (if _t105 = Protocol.T_STRING then
              _str104#set_key iprot#readString
            else
              iprot#skip _t105)
          | 2 -> (if _t105 = Protocol.T_I32 then
              _str104#set_count iprot#readI32
            else
              iprot#skip _t105)
          | _ -> iprot#skip _t105);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str104

class deletion =
object (self)
  val mutable _timestamp : Int64.t option = None
  method get_timestamp = _timestamp
  method grab_timestamp = match _timestamp with None->raise (Field_empty "deletion.timestamp") | Some _x108 -> _x108
  method set_timestamp _x108 = _timestamp <- Some _x108
  val mutable _super_column : string option = None
  method get_super_column = _super_column
  method grab_super_column = match _super_column with None->raise (Field_empty "deletion.super_column") | Some _x108 -> _x108
  method set_super_column _x108 = _super_column <- Some _x108
  val mutable _predicate : slicePredicate option = None
  method get_predicate = _predicate
  method grab_predicate = match _predicate with None->raise (Field_empty "deletion.predicate") | Some _x108 -> _x108
  method set_predicate _x108 = _predicate <- Some _x108
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "Deletion";
    (match _timestamp with None -> () | Some _v -> 
      oprot#writeFieldBegin("timestamp",Protocol.T_I64,1);
      oprot#writeI64(_v);
      oprot#writeFieldEnd
    );
    (match _super_column with None -> () | Some _v -> 
      oprot#writeFieldBegin("super_column",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _predicate with None -> () | Some _v -> 
      oprot#writeFieldBegin("predicate",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_deletion (iprot : Protocol.t) =
  let _str111 = new deletion in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t112,_id113) = iprot#readFieldBegin in
        if _t112 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id113 with 
          | 1 -> (if _t112 = Protocol.T_I64 then
              _str111#set_timestamp iprot#readI64
            else
              iprot#skip _t112)
          | 2 -> (if _t112 = Protocol.T_STRING then
              _str111#set_super_column iprot#readString
            else
              iprot#skip _t112)
          | 3 -> (if _t112 = Protocol.T_STRUCT then
              _str111#set_predicate (read_slicePredicate iprot)
            else
              iprot#skip _t112)
          | _ -> iprot#skip _t112);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str111

class mutation =
object (self)
  val mutable _column_or_supercolumn : columnOrSuperColumn option = None
  method get_column_or_supercolumn = _column_or_supercolumn
  method grab_column_or_supercolumn = match _column_or_supercolumn with None->raise (Field_empty "mutation.column_or_supercolumn") | Some _x115 -> _x115
  method set_column_or_supercolumn _x115 = _column_or_supercolumn <- Some _x115
  val mutable _deletion : deletion option = None
  method get_deletion = _deletion
  method grab_deletion = match _deletion with None->raise (Field_empty "mutation.deletion") | Some _x115 -> _x115
  method set_deletion _x115 = _deletion <- Some _x115
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "Mutation";
    (match _column_or_supercolumn with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_or_supercolumn",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _deletion with None -> () | Some _v -> 
      oprot#writeFieldBegin("deletion",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_mutation (iprot : Protocol.t) =
  let _str118 = new mutation in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t119,_id120) = iprot#readFieldBegin in
        if _t119 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id120 with 
          | 1 -> (if _t119 = Protocol.T_STRUCT then
              _str118#set_column_or_supercolumn (read_columnOrSuperColumn iprot)
            else
              iprot#skip _t119)
          | 2 -> (if _t119 = Protocol.T_STRUCT then
              _str118#set_deletion (read_deletion iprot)
            else
              iprot#skip _t119)
          | _ -> iprot#skip _t119);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str118

class tokenRange =
object (self)
  val mutable _start_token : string option = None
  method get_start_token = _start_token
  method grab_start_token = match _start_token with None->raise (Field_empty "tokenRange.start_token") | Some _x122 -> _x122
  method set_start_token _x122 = _start_token <- Some _x122
  val mutable _end_token : string option = None
  method get_end_token = _end_token
  method grab_end_token = match _end_token with None->raise (Field_empty "tokenRange.end_token") | Some _x122 -> _x122
  method set_end_token _x122 = _end_token <- Some _x122
  val mutable _endpoints : string list option = None
  method get_endpoints = _endpoints
  method grab_endpoints = match _endpoints with None->raise (Field_empty "tokenRange.endpoints") | Some _x122 -> _x122
  method set_endpoints _x122 = _endpoints <- Some _x122
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "TokenRange";
    (match _start_token with None -> () | Some _v -> 
      oprot#writeFieldBegin("start_token",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _end_token with None -> () | Some _v -> 
      oprot#writeFieldBegin("end_token",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _endpoints with None -> () | Some _v -> 
      oprot#writeFieldBegin("endpoints",Protocol.T_LIST,3);
      oprot#writeListBegin(Protocol.T_STRING,List.length _v);
      List.iter (fun _iter125 ->         oprot#writeString(_iter125);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_tokenRange (iprot : Protocol.t) =
  let _str126 = new tokenRange in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t127,_id128) = iprot#readFieldBegin in
        if _t127 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id128 with 
          | 1 -> (if _t127 = Protocol.T_STRING then
              _str126#set_start_token iprot#readString
            else
              iprot#skip _t127)
          | 2 -> (if _t127 = Protocol.T_STRING then
              _str126#set_end_token iprot#readString
            else
              iprot#skip _t127)
          | 3 -> (if _t127 = Protocol.T_LIST then
              _str126#set_endpoints 
                (let (_etype132,_size129) = iprot#readListBegin in
                  let _con133 = (Array.to_list (Array.init _size129 (fun _ -> iprot#readString))) in
                    iprot#readListEnd; _con133)
            else
              iprot#skip _t127)
          | _ -> iprot#skip _t127);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str126

class authenticationRequest =
object (self)
  val mutable _credentials : (string,string) Hashtbl.t option = None
  method get_credentials = _credentials
  method grab_credentials = match _credentials with None->raise (Field_empty "authenticationRequest.credentials") | Some _x135 -> _x135
  method set_credentials _x135 = _credentials <- Some _x135
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "AuthenticationRequest";
    (match _credentials with None -> () | Some _v -> 
      oprot#writeFieldBegin("credentials",Protocol.T_MAP,1);
      oprot#writeMapBegin(Protocol.T_STRING,Protocol.T_STRING,Hashtbl.length _v);
      Hashtbl.iter (fun _kiter138 -> fun _viter139 -> 
        oprot#writeString(_kiter138);
        oprot#writeString(_viter139);
      ) _v;
      oprot#writeMapEnd;
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_authenticationRequest (iprot : Protocol.t) =
  let _str140 = new authenticationRequest in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t141,_id142) = iprot#readFieldBegin in
        if _t141 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id142 with 
          | 1 -> (if _t141 = Protocol.T_MAP then
              _str140#set_credentials 
                (let (_ktype144,_vtype145,_size143) = iprot#readMapBegin in
                let _con147 = Hashtbl.create _size143 in
                  for i = 1 to _size143 do
                    let _k = iprot#readString in
                    let _v = iprot#readString in
                      Hashtbl.add _con147 _k _v
                  done; iprot#readMapEnd; _con147)
            else
              iprot#skip _t141)
          | _ -> iprot#skip _t141);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str140

class columnDef =
object (self)
  val mutable _name : string option = None
  method get_name = _name
  method grab_name = match _name with None->raise (Field_empty "columnDef.name") | Some _x149 -> _x149
  method set_name _x149 = _name <- Some _x149
  val mutable _validation_class : string option = None
  method get_validation_class = _validation_class
  method grab_validation_class = match _validation_class with None->raise (Field_empty "columnDef.validation_class") | Some _x149 -> _x149
  method set_validation_class _x149 = _validation_class <- Some _x149
  val mutable _index_type : IndexType.t option = None
  method get_index_type = _index_type
  method grab_index_type = match _index_type with None->raise (Field_empty "columnDef.index_type") | Some _x149 -> _x149
  method set_index_type _x149 = _index_type <- Some _x149
  val mutable _index_name : string option = None
  method get_index_name = _index_name
  method grab_index_name = match _index_name with None->raise (Field_empty "columnDef.index_name") | Some _x149 -> _x149
  method set_index_name _x149 = _index_name <- Some _x149
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "ColumnDef";
    (match _name with None -> () | Some _v -> 
      oprot#writeFieldBegin("name",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _validation_class with None -> () | Some _v -> 
      oprot#writeFieldBegin("validation_class",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _index_type with None -> () | Some _v -> 
      oprot#writeFieldBegin("index_type",Protocol.T_I32,3);
      oprot#writeI32(IndexType.to_i _v);
      oprot#writeFieldEnd
    );
    (match _index_name with None -> () | Some _v -> 
      oprot#writeFieldBegin("index_name",Protocol.T_STRING,4);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_columnDef (iprot : Protocol.t) =
  let _str152 = new columnDef in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t153,_id154) = iprot#readFieldBegin in
        if _t153 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id154 with 
          | 1 -> (if _t153 = Protocol.T_STRING then
              _str152#set_name iprot#readString
            else
              iprot#skip _t153)
          | 2 -> (if _t153 = Protocol.T_STRING then
              _str152#set_validation_class iprot#readString
            else
              iprot#skip _t153)
          | 3 -> (if _t153 = Protocol.T_I32 then
              _str152#set_index_type (IndexType.of_i iprot#readI32)
            else
              iprot#skip _t153)
          | 4 -> (if _t153 = Protocol.T_STRING then
              _str152#set_index_name iprot#readString
            else
              iprot#skip _t153)
          | _ -> iprot#skip _t153);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str152

class cfDef =
object (self)
  val mutable _keyspace : string option = None
  method get_keyspace = _keyspace
  method grab_keyspace = match _keyspace with None->raise (Field_empty "cfDef.keyspace") | Some _x156 -> _x156
  method set_keyspace _x156 = _keyspace <- Some _x156
  val mutable _name : string option = None
  method get_name = _name
  method grab_name = match _name with None->raise (Field_empty "cfDef.name") | Some _x156 -> _x156
  method set_name _x156 = _name <- Some _x156
  val mutable _column_type : string option = None
  method get_column_type = _column_type
  method grab_column_type = match _column_type with None->raise (Field_empty "cfDef.column_type") | Some _x156 -> _x156
  method set_column_type _x156 = _column_type <- Some _x156
  val mutable _comparator_type : string option = None
  method get_comparator_type = _comparator_type
  method grab_comparator_type = match _comparator_type with None->raise (Field_empty "cfDef.comparator_type") | Some _x156 -> _x156
  method set_comparator_type _x156 = _comparator_type <- Some _x156
  val mutable _subcomparator_type : string option = None
  method get_subcomparator_type = _subcomparator_type
  method grab_subcomparator_type = match _subcomparator_type with None->raise (Field_empty "cfDef.subcomparator_type") | Some _x156 -> _x156
  method set_subcomparator_type _x156 = _subcomparator_type <- Some _x156
  val mutable _comment : string option = None
  method get_comment = _comment
  method grab_comment = match _comment with None->raise (Field_empty "cfDef.comment") | Some _x156 -> _x156
  method set_comment _x156 = _comment <- Some _x156
  val mutable _row_cache_size : float option = None
  method get_row_cache_size = _row_cache_size
  method grab_row_cache_size = match _row_cache_size with None->raise (Field_empty "cfDef.row_cache_size") | Some _x156 -> _x156
  method set_row_cache_size _x156 = _row_cache_size <- Some _x156
  val mutable _preload_row_cache : bool option = None
  method get_preload_row_cache = _preload_row_cache
  method grab_preload_row_cache = match _preload_row_cache with None->raise (Field_empty "cfDef.preload_row_cache") | Some _x156 -> _x156
  method set_preload_row_cache _x156 = _preload_row_cache <- Some _x156
  val mutable _key_cache_size : float option = None
  method get_key_cache_size = _key_cache_size
  method grab_key_cache_size = match _key_cache_size with None->raise (Field_empty "cfDef.key_cache_size") | Some _x156 -> _x156
  method set_key_cache_size _x156 = _key_cache_size <- Some _x156
  val mutable _read_repair_chance : float option = None
  method get_read_repair_chance = _read_repair_chance
  method grab_read_repair_chance = match _read_repair_chance with None->raise (Field_empty "cfDef.read_repair_chance") | Some _x156 -> _x156
  method set_read_repair_chance _x156 = _read_repair_chance <- Some _x156
  val mutable _column_metadata : columnDef list option = None
  method get_column_metadata = _column_metadata
  method grab_column_metadata = match _column_metadata with None->raise (Field_empty "cfDef.column_metadata") | Some _x156 -> _x156
  method set_column_metadata _x156 = _column_metadata <- Some _x156
  val mutable _gc_grace_seconds : int option = None
  method get_gc_grace_seconds = _gc_grace_seconds
  method grab_gc_grace_seconds = match _gc_grace_seconds with None->raise (Field_empty "cfDef.gc_grace_seconds") | Some _x156 -> _x156
  method set_gc_grace_seconds _x156 = _gc_grace_seconds <- Some _x156
  val mutable _default_validation_class : string option = None
  method get_default_validation_class = _default_validation_class
  method grab_default_validation_class = match _default_validation_class with None->raise (Field_empty "cfDef.default_validation_class") | Some _x156 -> _x156
  method set_default_validation_class _x156 = _default_validation_class <- Some _x156
  val mutable _id : int option = None
  method get_id = _id
  method grab_id = match _id with None->raise (Field_empty "cfDef.id") | Some _x156 -> _x156
  method set_id _x156 = _id <- Some _x156
  val mutable _min_compaction_threshold : int option = None
  method get_min_compaction_threshold = _min_compaction_threshold
  method grab_min_compaction_threshold = match _min_compaction_threshold with None->raise (Field_empty "cfDef.min_compaction_threshold") | Some _x156 -> _x156
  method set_min_compaction_threshold _x156 = _min_compaction_threshold <- Some _x156
  val mutable _max_compaction_threshold : int option = None
  method get_max_compaction_threshold = _max_compaction_threshold
  method grab_max_compaction_threshold = match _max_compaction_threshold with None->raise (Field_empty "cfDef.max_compaction_threshold") | Some _x156 -> _x156
  method set_max_compaction_threshold _x156 = _max_compaction_threshold <- Some _x156
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "CfDef";
    (match _keyspace with None -> () | Some _v -> 
      oprot#writeFieldBegin("keyspace",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _name with None -> () | Some _v -> 
      oprot#writeFieldBegin("name",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _column_type with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_type",Protocol.T_STRING,3);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _comparator_type with None -> () | Some _v -> 
      oprot#writeFieldBegin("comparator_type",Protocol.T_STRING,5);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _subcomparator_type with None -> () | Some _v -> 
      oprot#writeFieldBegin("subcomparator_type",Protocol.T_STRING,6);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _comment with None -> () | Some _v -> 
      oprot#writeFieldBegin("comment",Protocol.T_STRING,8);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _row_cache_size with None -> () | Some _v -> 
      oprot#writeFieldBegin("row_cache_size",Protocol.T_DOUBLE,9);
      oprot#writeDouble(_v);
      oprot#writeFieldEnd
    );
    (match _preload_row_cache with None -> () | Some _v -> 
      oprot#writeFieldBegin("preload_row_cache",Protocol.T_BOOL,10);
      oprot#writeBool(_v);
      oprot#writeFieldEnd
    );
    (match _key_cache_size with None -> () | Some _v -> 
      oprot#writeFieldBegin("key_cache_size",Protocol.T_DOUBLE,11);
      oprot#writeDouble(_v);
      oprot#writeFieldEnd
    );
    (match _read_repair_chance with None -> () | Some _v -> 
      oprot#writeFieldBegin("read_repair_chance",Protocol.T_DOUBLE,12);
      oprot#writeDouble(_v);
      oprot#writeFieldEnd
    );
    (match _column_metadata with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_metadata",Protocol.T_LIST,13);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter159 ->         _iter159#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _gc_grace_seconds with None -> () | Some _v -> 
      oprot#writeFieldBegin("gc_grace_seconds",Protocol.T_I32,14);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _default_validation_class with None -> () | Some _v -> 
      oprot#writeFieldBegin("default_validation_class",Protocol.T_STRING,15);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _id with None -> () | Some _v -> 
      oprot#writeFieldBegin("id",Protocol.T_I32,16);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _min_compaction_threshold with None -> () | Some _v -> 
      oprot#writeFieldBegin("min_compaction_threshold",Protocol.T_I32,17);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _max_compaction_threshold with None -> () | Some _v -> 
      oprot#writeFieldBegin("max_compaction_threshold",Protocol.T_I32,18);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_cfDef (iprot : Protocol.t) =
  let _str160 = new cfDef in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t161,_id162) = iprot#readFieldBegin in
        if _t161 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id162 with 
          | 1 -> (if _t161 = Protocol.T_STRING then
              _str160#set_keyspace iprot#readString
            else
              iprot#skip _t161)
          | 2 -> (if _t161 = Protocol.T_STRING then
              _str160#set_name iprot#readString
            else
              iprot#skip _t161)
          | 3 -> (if _t161 = Protocol.T_STRING then
              _str160#set_column_type iprot#readString
            else
              iprot#skip _t161)
          | 5 -> (if _t161 = Protocol.T_STRING then
              _str160#set_comparator_type iprot#readString
            else
              iprot#skip _t161)
          | 6 -> (if _t161 = Protocol.T_STRING then
              _str160#set_subcomparator_type iprot#readString
            else
              iprot#skip _t161)
          | 8 -> (if _t161 = Protocol.T_STRING then
              _str160#set_comment iprot#readString
            else
              iprot#skip _t161)
          | 9 -> (if _t161 = Protocol.T_DOUBLE then
              _str160#set_row_cache_size iprot#readDouble
            else
              iprot#skip _t161)
          | 10 -> (if _t161 = Protocol.T_BOOL then
              _str160#set_preload_row_cache iprot#readBool
            else
              iprot#skip _t161)
          | 11 -> (if _t161 = Protocol.T_DOUBLE then
              _str160#set_key_cache_size iprot#readDouble
            else
              iprot#skip _t161)
          | 12 -> (if _t161 = Protocol.T_DOUBLE then
              _str160#set_read_repair_chance iprot#readDouble
            else
              iprot#skip _t161)
          | 13 -> (if _t161 = Protocol.T_LIST then
              _str160#set_column_metadata 
                (let (_etype166,_size163) = iprot#readListBegin in
                  let _con167 = (Array.to_list (Array.init _size163 (fun _ -> (read_columnDef iprot)))) in
                    iprot#readListEnd; _con167)
            else
              iprot#skip _t161)
          | 14 -> (if _t161 = Protocol.T_I32 then
              _str160#set_gc_grace_seconds iprot#readI32
            else
              iprot#skip _t161)
          | 15 -> (if _t161 = Protocol.T_STRING then
              _str160#set_default_validation_class iprot#readString
            else
              iprot#skip _t161)
          | 16 -> (if _t161 = Protocol.T_I32 then
              _str160#set_id iprot#readI32
            else
              iprot#skip _t161)
          | 17 -> (if _t161 = Protocol.T_I32 then
              _str160#set_min_compaction_threshold iprot#readI32
            else
              iprot#skip _t161)
          | 18 -> (if _t161 = Protocol.T_I32 then
              _str160#set_max_compaction_threshold iprot#readI32
            else
              iprot#skip _t161)
          | _ -> iprot#skip _t161);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str160

class ksDef =
object (self)
  val mutable _name : string option = None
  method get_name = _name
  method grab_name = match _name with None->raise (Field_empty "ksDef.name") | Some _x169 -> _x169
  method set_name _x169 = _name <- Some _x169
  val mutable _strategy_class : string option = None
  method get_strategy_class = _strategy_class
  method grab_strategy_class = match _strategy_class with None->raise (Field_empty "ksDef.strategy_class") | Some _x169 -> _x169
  method set_strategy_class _x169 = _strategy_class <- Some _x169
  val mutable _strategy_options : (string,string) Hashtbl.t option = None
  method get_strategy_options = _strategy_options
  method grab_strategy_options = match _strategy_options with None->raise (Field_empty "ksDef.strategy_options") | Some _x169 -> _x169
  method set_strategy_options _x169 = _strategy_options <- Some _x169
  val mutable _replication_factor : int option = None
  method get_replication_factor = _replication_factor
  method grab_replication_factor = match _replication_factor with None->raise (Field_empty "ksDef.replication_factor") | Some _x169 -> _x169
  method set_replication_factor _x169 = _replication_factor <- Some _x169
  val mutable _cf_defs : cfDef list option = None
  method get_cf_defs = _cf_defs
  method grab_cf_defs = match _cf_defs with None->raise (Field_empty "ksDef.cf_defs") | Some _x169 -> _x169
  method set_cf_defs _x169 = _cf_defs <- Some _x169
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "KsDef";
    (match _name with None -> () | Some _v -> 
      oprot#writeFieldBegin("name",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _strategy_class with None -> () | Some _v -> 
      oprot#writeFieldBegin("strategy_class",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _strategy_options with None -> () | Some _v -> 
      oprot#writeFieldBegin("strategy_options",Protocol.T_MAP,3);
      oprot#writeMapBegin(Protocol.T_STRING,Protocol.T_STRING,Hashtbl.length _v);
      Hashtbl.iter (fun _kiter172 -> fun _viter173 -> 
        oprot#writeString(_kiter172);
        oprot#writeString(_viter173);
      ) _v;
      oprot#writeMapEnd;
      oprot#writeFieldEnd
    );
    (match _replication_factor with None -> () | Some _v -> 
      oprot#writeFieldBegin("replication_factor",Protocol.T_I32,4);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _cf_defs with None -> () | Some _v -> 
      oprot#writeFieldBegin("cf_defs",Protocol.T_LIST,5);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter174 ->         _iter174#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_ksDef (iprot : Protocol.t) =
  let _str175 = new ksDef in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t176,_id177) = iprot#readFieldBegin in
        if _t176 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id177 with 
          | 1 -> (if _t176 = Protocol.T_STRING then
              _str175#set_name iprot#readString
            else
              iprot#skip _t176)
          | 2 -> (if _t176 = Protocol.T_STRING then
              _str175#set_strategy_class iprot#readString
            else
              iprot#skip _t176)
          | 3 -> (if _t176 = Protocol.T_MAP then
              _str175#set_strategy_options 
                (let (_ktype179,_vtype180,_size178) = iprot#readMapBegin in
                let _con182 = Hashtbl.create _size178 in
                  for i = 1 to _size178 do
                    let _k = iprot#readString in
                    let _v = iprot#readString in
                      Hashtbl.add _con182 _k _v
                  done; iprot#readMapEnd; _con182)
            else
              iprot#skip _t176)
          | 4 -> (if _t176 = Protocol.T_I32 then
              _str175#set_replication_factor iprot#readI32
            else
              iprot#skip _t176)
          | 5 -> (if _t176 = Protocol.T_LIST then
              _str175#set_cf_defs 
                (let (_etype186,_size183) = iprot#readListBegin in
                  let _con187 = (Array.to_list (Array.init _size183 (fun _ -> (read_cfDef iprot)))) in
                    iprot#readListEnd; _con187)
            else
              iprot#skip _t176)
          | _ -> iprot#skip _t176);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str175

class notFoundException =
object (self)
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "NotFoundException";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
exception NotFoundException of notFoundException
let rec read_notFoundException (iprot : Protocol.t) =
  let _str192 = new notFoundException in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t193,_id194) = iprot#readFieldBegin in
        if _t193 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id194 with 
          | _ -> iprot#skip _t193);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str192

class invalidRequestException =
object (self)
  val mutable _why : string option = None
  method get_why = _why
  method grab_why = match _why with None->raise (Field_empty "invalidRequestException.why") | Some _x196 -> _x196
  method set_why _x196 = _why <- Some _x196
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "InvalidRequestException";
    (match _why with None -> () | Some _v -> 
      oprot#writeFieldBegin("why",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
exception InvalidRequestException of invalidRequestException
let rec read_invalidRequestException (iprot : Protocol.t) =
  let _str199 = new invalidRequestException in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t200,_id201) = iprot#readFieldBegin in
        if _t200 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id201 with 
          | 1 -> (if _t200 = Protocol.T_STRING then
              _str199#set_why iprot#readString
            else
              iprot#skip _t200)
          | _ -> iprot#skip _t200);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str199

class unavailableException =
object (self)
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "UnavailableException";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
exception UnavailableException of unavailableException
let rec read_unavailableException (iprot : Protocol.t) =
  let _str206 = new unavailableException in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t207,_id208) = iprot#readFieldBegin in
        if _t207 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id208 with 
          | _ -> iprot#skip _t207);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str206

class timedOutException =
object (self)
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "TimedOutException";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
exception TimedOutException of timedOutException
let rec read_timedOutException (iprot : Protocol.t) =
  let _str213 = new timedOutException in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t214,_id215) = iprot#readFieldBegin in
        if _t214 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id215 with 
          | _ -> iprot#skip _t214);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str213

class authenticationException =
object (self)
  val mutable _why : string option = None
  method get_why = _why
  method grab_why = match _why with None->raise (Field_empty "authenticationException.why") | Some _x217 -> _x217
  method set_why _x217 = _why <- Some _x217
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "AuthenticationException";
    (match _why with None -> () | Some _v -> 
      oprot#writeFieldBegin("why",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
exception AuthenticationException of authenticationException
let rec read_authenticationException (iprot : Protocol.t) =
  let _str220 = new authenticationException in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t221,_id222) = iprot#readFieldBegin in
        if _t221 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id222 with 
          | 1 -> (if _t221 = Protocol.T_STRING then
              _str220#set_why iprot#readString
            else
              iprot#skip _t221)
          | _ -> iprot#skip _t221);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str220

class authorizationException =
object (self)
  val mutable _why : string option = None
  method get_why = _why
  method grab_why = match _why with None->raise (Field_empty "authorizationException.why") | Some _x224 -> _x224
  method set_why _x224 = _why <- Some _x224
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "AuthorizationException";
    (match _why with None -> () | Some _v -> 
      oprot#writeFieldBegin("why",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
exception AuthorizationException of authorizationException
let rec read_authorizationException (iprot : Protocol.t) =
  let _str227 = new authorizationException in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t228,_id229) = iprot#readFieldBegin in
        if _t228 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id229 with 
          | 1 -> (if _t228 = Protocol.T_STRING then
              _str227#set_why iprot#readString
            else
              iprot#skip _t228)
          | _ -> iprot#skip _t228);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str227

