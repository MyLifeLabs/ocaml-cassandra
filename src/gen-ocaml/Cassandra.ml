(*
 Autogenerated by Thrift

 DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING
*)

open Thrift
open Cassandra_types

(* HELPER FUNCTIONS AND STRUCTURES *)

class login_args =
object (self)
  val mutable _auth_request : authenticationRequest option = None
  method get_auth_request = _auth_request
  method grab_auth_request = match _auth_request with None->raise (Field_empty "login_args.auth_request") | Some _x346 -> _x346
  method set_auth_request _x346 = _auth_request <- Some _x346
  method unset_auth_request = _auth_request <- None
  method reset_auth_request = _auth_request <- None

  method copy =
      let _new = Oo.copy self in
      if _auth_request <> None then
        _new#set_auth_request self#grab_auth_request#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "login_args";
    (match _auth_request with 
    | None -> raise (Field_empty "login_args._auth_request")
    | Some _v -> 
      oprot#writeFieldBegin("auth_request",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_login_args (iprot : Protocol.t) =
  let _str349 = new login_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t350,_id351) = iprot#readFieldBegin in
        if _t350 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id351 with 
          | 1 -> (if _t350 = Protocol.T_STRUCT then
              _str349#set_auth_request (read_authenticationRequest iprot)
            else
              iprot#skip _t350)
          | _ -> iprot#skip _t350);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str349

class login_result =
object (self)
  val mutable _authnx : authenticationException option = None
  method get_authnx = _authnx
  method grab_authnx = match _authnx with None->raise (Field_empty "login_result.authnx") | Some _x352 -> _x352
  method set_authnx _x352 = _authnx <- Some _x352
  method unset_authnx = _authnx <- None
  method reset_authnx = _authnx <- None

  val mutable _authzx : authorizationException option = None
  method get_authzx = _authzx
  method grab_authzx = match _authzx with None->raise (Field_empty "login_result.authzx") | Some _x353 -> _x353
  method set_authzx _x353 = _authzx <- Some _x353
  method unset_authzx = _authzx <- None
  method reset_authzx = _authzx <- None

  method copy =
      let _new = Oo.copy self in
      if _authnx <> None then
        _new#set_authnx self#grab_authnx#copy;
      if _authzx <> None then
        _new#set_authzx self#grab_authzx#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "login_result";
    (match _authnx with None -> () | Some _v -> 
      oprot#writeFieldBegin("authnx",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _authzx with None -> () | Some _v -> 
      oprot#writeFieldBegin("authzx",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_login_result (iprot : Protocol.t) =
  let _str356 = new login_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t357,_id358) = iprot#readFieldBegin in
        if _t357 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id358 with 
          | 1 -> (if _t357 = Protocol.T_STRUCT then
              _str356#set_authnx (read_authenticationException iprot)
            else
              iprot#skip _t357)
          | 2 -> (if _t357 = Protocol.T_STRUCT then
              _str356#set_authzx (read_authorizationException iprot)
            else
              iprot#skip _t357)
          | _ -> iprot#skip _t357);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str356

class set_keyspace_args =
object (self)
  val mutable _keyspace : string option = None
  method get_keyspace = _keyspace
  method grab_keyspace = match _keyspace with None->raise (Field_empty "set_keyspace_args.keyspace") | Some _x359 -> _x359
  method set_keyspace _x359 = _keyspace <- Some _x359
  method unset_keyspace = _keyspace <- None
  method reset_keyspace = _keyspace <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "set_keyspace_args";
    (match _keyspace with 
    | None -> raise (Field_empty "set_keyspace_args._keyspace")
    | Some _v -> 
      oprot#writeFieldBegin("keyspace",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_set_keyspace_args (iprot : Protocol.t) =
  let _str362 = new set_keyspace_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t363,_id364) = iprot#readFieldBegin in
        if _t363 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id364 with 
          | 1 -> (if _t363 = Protocol.T_STRING then
              _str362#set_keyspace iprot#readString
            else
              iprot#skip _t363)
          | _ -> iprot#skip _t363);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str362

class set_keyspace_result =
object (self)
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "set_keyspace_result.ire") | Some _x365 -> _x365
  method set_ire _x365 = _ire <- Some _x365
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  method copy =
      let _new = Oo.copy self in
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "set_keyspace_result";
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_set_keyspace_result (iprot : Protocol.t) =
  let _str368 = new set_keyspace_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t369,_id370) = iprot#readFieldBegin in
        if _t369 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id370 with 
          | 1 -> (if _t369 = Protocol.T_STRUCT then
              _str368#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t369)
          | _ -> iprot#skip _t369);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str368

class get_args =
object (self)
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "get_args.key") | Some _x371 -> _x371
  method set_key _x371 = _key <- Some _x371
  method unset_key = _key <- None
  method reset_key = _key <- None

  val mutable _column_path : columnPath option = None
  method get_column_path = _column_path
  method grab_column_path = match _column_path with None->raise (Field_empty "get_args.column_path") | Some _x372 -> _x372
  method set_column_path _x372 = _column_path <- Some _x372
  method unset_column_path = _column_path <- None
  method reset_column_path = _column_path <- None

  val mutable _consistency_level : ConsistencyLevel.t =   ConsistencyLevel.ONE
  method get_consistency_level = Some _consistency_level
  method grab_consistency_level = _consistency_level
  method set_consistency_level _x373 = _consistency_level <- _x373
  method reset_consistency_level = _consistency_level <-   ConsistencyLevel.ONE

  method copy =
      let _new = Oo.copy self in
      if _column_path <> None then
        _new#set_column_path self#grab_column_path#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_args";
    (match _key with 
    | None -> raise (Field_empty "get_args._key")
    | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _column_path with 
    | None -> raise (Field_empty "get_args._column_path")
    | Some _v -> 
      oprot#writeFieldBegin("column_path",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,3);
      oprot#writeI32(ConsistencyLevel.to_i _consistency_level);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_args (iprot : Protocol.t) =
  let _str376 = new get_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t377,_id378) = iprot#readFieldBegin in
        if _t377 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id378 with 
          | 1 -> (if _t377 = Protocol.T_STRING then
              _str376#set_key iprot#readString
            else
              iprot#skip _t377)
          | 2 -> (if _t377 = Protocol.T_STRUCT then
              _str376#set_column_path (read_columnPath iprot)
            else
              iprot#skip _t377)
          | 3 -> (if _t377 = Protocol.T_I32 then
              _str376#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t377)
          | _ -> iprot#skip _t377);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str376

class get_result =
object (self)
  val mutable _success : columnOrSuperColumn option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "get_result.success") | Some _x379 -> _x379
  method set_success _x379 = _success <- Some _x379
  method unset_success = _success <- None
  method reset_success = _success <- None

  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "get_result.ire") | Some _x380 -> _x380
  method set_ire _x380 = _ire <- Some _x380
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  val mutable _nfe : notFoundException option = None
  method get_nfe = _nfe
  method grab_nfe = match _nfe with None->raise (Field_empty "get_result.nfe") | Some _x381 -> _x381
  method set_nfe _x381 = _nfe <- Some _x381
  method unset_nfe = _nfe <- None
  method reset_nfe = _nfe <- None

  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "get_result.ue") | Some _x382 -> _x382
  method set_ue _x382 = _ue <- Some _x382
  method unset_ue = _ue <- None
  method reset_ue = _ue <- None

  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "get_result.te") | Some _x383 -> _x383
  method set_te _x383 = _te <- Some _x383
  method unset_te = _te <- None
  method reset_te = _te <- None

  method copy =
      let _new = Oo.copy self in
      if _success <> None then
        _new#set_success self#grab_success#copy;
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
      if _nfe <> None then
        _new#set_nfe self#grab_nfe#copy;
      if _ue <> None then
        _new#set_ue self#grab_ue#copy;
      if _te <> None then
        _new#set_te self#grab_te#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRUCT,0);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _nfe with None -> () | Some _v -> 
      oprot#writeFieldBegin("nfe",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,4);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_result (iprot : Protocol.t) =
  let _str386 = new get_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t387,_id388) = iprot#readFieldBegin in
        if _t387 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id388 with 
          | 0 -> (if _t387 = Protocol.T_STRUCT then
              _str386#set_success (read_columnOrSuperColumn iprot)
            else
              iprot#skip _t387)
          | 1 -> (if _t387 = Protocol.T_STRUCT then
              _str386#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t387)
          | 2 -> (if _t387 = Protocol.T_STRUCT then
              _str386#set_nfe (read_notFoundException iprot)
            else
              iprot#skip _t387)
          | 3 -> (if _t387 = Protocol.T_STRUCT then
              _str386#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t387)
          | 4 -> (if _t387 = Protocol.T_STRUCT then
              _str386#set_te (read_timedOutException iprot)
            else
              iprot#skip _t387)
          | _ -> iprot#skip _t387);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str386

class get_slice_args =
object (self)
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "get_slice_args.key") | Some _x389 -> _x389
  method set_key _x389 = _key <- Some _x389
  method unset_key = _key <- None
  method reset_key = _key <- None

  val mutable _column_parent : columnParent option = None
  method get_column_parent = _column_parent
  method grab_column_parent = match _column_parent with None->raise (Field_empty "get_slice_args.column_parent") | Some _x390 -> _x390
  method set_column_parent _x390 = _column_parent <- Some _x390
  method unset_column_parent = _column_parent <- None
  method reset_column_parent = _column_parent <- None

  val mutable _predicate : slicePredicate option = None
  method get_predicate = _predicate
  method grab_predicate = match _predicate with None->raise (Field_empty "get_slice_args.predicate") | Some _x391 -> _x391
  method set_predicate _x391 = _predicate <- Some _x391
  method unset_predicate = _predicate <- None
  method reset_predicate = _predicate <- None

  val mutable _consistency_level : ConsistencyLevel.t =   ConsistencyLevel.ONE
  method get_consistency_level = Some _consistency_level
  method grab_consistency_level = _consistency_level
  method set_consistency_level _x392 = _consistency_level <- _x392
  method reset_consistency_level = _consistency_level <-   ConsistencyLevel.ONE

  method copy =
      let _new = Oo.copy self in
      if _column_parent <> None then
        _new#set_column_parent self#grab_column_parent#copy;
      if _predicate <> None then
        _new#set_predicate self#grab_predicate#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_slice_args";
    (match _key with 
    | None -> raise (Field_empty "get_slice_args._key")
    | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _column_parent with 
    | None -> raise (Field_empty "get_slice_args._column_parent")
    | Some _v -> 
      oprot#writeFieldBegin("column_parent",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _predicate with 
    | None -> raise (Field_empty "get_slice_args._predicate")
    | Some _v -> 
      oprot#writeFieldBegin("predicate",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,4);
      oprot#writeI32(ConsistencyLevel.to_i _consistency_level);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_slice_args (iprot : Protocol.t) =
  let _str395 = new get_slice_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t396,_id397) = iprot#readFieldBegin in
        if _t396 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id397 with 
          | 1 -> (if _t396 = Protocol.T_STRING then
              _str395#set_key iprot#readString
            else
              iprot#skip _t396)
          | 2 -> (if _t396 = Protocol.T_STRUCT then
              _str395#set_column_parent (read_columnParent iprot)
            else
              iprot#skip _t396)
          | 3 -> (if _t396 = Protocol.T_STRUCT then
              _str395#set_predicate (read_slicePredicate iprot)
            else
              iprot#skip _t396)
          | 4 -> (if _t396 = Protocol.T_I32 then
              _str395#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t396)
          | _ -> iprot#skip _t396);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str395

class get_slice_result =
object (self)
  val mutable _success : columnOrSuperColumn list option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "get_slice_result.success") | Some _x398 -> _x398
  method set_success _x398 = _success <- Some _x398
  method unset_success = _success <- None
  method reset_success = _success <- None

  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "get_slice_result.ire") | Some _x399 -> _x399
  method set_ire _x399 = _ire <- Some _x399
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "get_slice_result.ue") | Some _x400 -> _x400
  method set_ue _x400 = _ue <- Some _x400
  method unset_ue = _ue <- None
  method reset_ue = _ue <- None

  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "get_slice_result.te") | Some _x401 -> _x401
  method set_te _x401 = _te <- Some _x401
  method unset_te = _te <- None
  method reset_te = _te <- None

  method copy =
      let _new = Oo.copy self in
      if _success <> None then
        _new#set_success (List.map (fun x -> x#copy) self#grab_success);
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
      if _ue <> None then
        _new#set_ue self#grab_ue#copy;
      if _te <> None then
        _new#set_te self#grab_te#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_slice_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_LIST,0);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter404 ->         _iter404#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_slice_result (iprot : Protocol.t) =
  let _str405 = new get_slice_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t406,_id407) = iprot#readFieldBegin in
        if _t406 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id407 with 
          | 0 -> (if _t406 = Protocol.T_LIST then
              _str405#set_success 
                (let (_etype411,_size408) = iprot#readListBegin in
                  let _con412 = (Array.to_list (Array.init _size408 (fun _ -> (read_columnOrSuperColumn iprot)))) in
                    iprot#readListEnd; _con412)
            else
              iprot#skip _t406)
          | 1 -> (if _t406 = Protocol.T_STRUCT then
              _str405#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t406)
          | 2 -> (if _t406 = Protocol.T_STRUCT then
              _str405#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t406)
          | 3 -> (if _t406 = Protocol.T_STRUCT then
              _str405#set_te (read_timedOutException iprot)
            else
              iprot#skip _t406)
          | _ -> iprot#skip _t406);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str405

class get_count_args =
object (self)
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "get_count_args.key") | Some _x413 -> _x413
  method set_key _x413 = _key <- Some _x413
  method unset_key = _key <- None
  method reset_key = _key <- None

  val mutable _column_parent : columnParent option = None
  method get_column_parent = _column_parent
  method grab_column_parent = match _column_parent with None->raise (Field_empty "get_count_args.column_parent") | Some _x414 -> _x414
  method set_column_parent _x414 = _column_parent <- Some _x414
  method unset_column_parent = _column_parent <- None
  method reset_column_parent = _column_parent <- None

  val mutable _predicate : slicePredicate option = None
  method get_predicate = _predicate
  method grab_predicate = match _predicate with None->raise (Field_empty "get_count_args.predicate") | Some _x415 -> _x415
  method set_predicate _x415 = _predicate <- Some _x415
  method unset_predicate = _predicate <- None
  method reset_predicate = _predicate <- None

  val mutable _consistency_level : ConsistencyLevel.t =   ConsistencyLevel.ONE
  method get_consistency_level = Some _consistency_level
  method grab_consistency_level = _consistency_level
  method set_consistency_level _x416 = _consistency_level <- _x416
  method reset_consistency_level = _consistency_level <-   ConsistencyLevel.ONE

  method copy =
      let _new = Oo.copy self in
      if _column_parent <> None then
        _new#set_column_parent self#grab_column_parent#copy;
      if _predicate <> None then
        _new#set_predicate self#grab_predicate#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_count_args";
    (match _key with 
    | None -> raise (Field_empty "get_count_args._key")
    | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _column_parent with 
    | None -> raise (Field_empty "get_count_args._column_parent")
    | Some _v -> 
      oprot#writeFieldBegin("column_parent",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _predicate with 
    | None -> raise (Field_empty "get_count_args._predicate")
    | Some _v -> 
      oprot#writeFieldBegin("predicate",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,4);
      oprot#writeI32(ConsistencyLevel.to_i _consistency_level);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_count_args (iprot : Protocol.t) =
  let _str419 = new get_count_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t420,_id421) = iprot#readFieldBegin in
        if _t420 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id421 with 
          | 1 -> (if _t420 = Protocol.T_STRING then
              _str419#set_key iprot#readString
            else
              iprot#skip _t420)
          | 2 -> (if _t420 = Protocol.T_STRUCT then
              _str419#set_column_parent (read_columnParent iprot)
            else
              iprot#skip _t420)
          | 3 -> (if _t420 = Protocol.T_STRUCT then
              _str419#set_predicate (read_slicePredicate iprot)
            else
              iprot#skip _t420)
          | 4 -> (if _t420 = Protocol.T_I32 then
              _str419#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t420)
          | _ -> iprot#skip _t420);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str419

class get_count_result =
object (self)
  val mutable _success : int option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "get_count_result.success") | Some _x422 -> _x422
  method set_success _x422 = _success <- Some _x422
  method unset_success = _success <- None
  method reset_success = _success <- None

  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "get_count_result.ire") | Some _x423 -> _x423
  method set_ire _x423 = _ire <- Some _x423
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "get_count_result.ue") | Some _x424 -> _x424
  method set_ue _x424 = _ue <- Some _x424
  method unset_ue = _ue <- None
  method reset_ue = _ue <- None

  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "get_count_result.te") | Some _x425 -> _x425
  method set_te _x425 = _te <- Some _x425
  method unset_te = _te <- None
  method reset_te = _te <- None

  method copy =
      let _new = Oo.copy self in
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
      if _ue <> None then
        _new#set_ue self#grab_ue#copy;
      if _te <> None then
        _new#set_te self#grab_te#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_count_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_I32,0);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_count_result (iprot : Protocol.t) =
  let _str428 = new get_count_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t429,_id430) = iprot#readFieldBegin in
        if _t429 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id430 with 
          | 0 -> (if _t429 = Protocol.T_I32 then
              _str428#set_success iprot#readI32
            else
              iprot#skip _t429)
          | 1 -> (if _t429 = Protocol.T_STRUCT then
              _str428#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t429)
          | 2 -> (if _t429 = Protocol.T_STRUCT then
              _str428#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t429)
          | 3 -> (if _t429 = Protocol.T_STRUCT then
              _str428#set_te (read_timedOutException iprot)
            else
              iprot#skip _t429)
          | _ -> iprot#skip _t429);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str428

class multiget_slice_args =
object (self)
  val mutable _keys : string list option = None
  method get_keys = _keys
  method grab_keys = match _keys with None->raise (Field_empty "multiget_slice_args.keys") | Some _x431 -> _x431
  method set_keys _x431 = _keys <- Some _x431
  method unset_keys = _keys <- None
  method reset_keys = _keys <- None

  val mutable _column_parent : columnParent option = None
  method get_column_parent = _column_parent
  method grab_column_parent = match _column_parent with None->raise (Field_empty "multiget_slice_args.column_parent") | Some _x432 -> _x432
  method set_column_parent _x432 = _column_parent <- Some _x432
  method unset_column_parent = _column_parent <- None
  method reset_column_parent = _column_parent <- None

  val mutable _predicate : slicePredicate option = None
  method get_predicate = _predicate
  method grab_predicate = match _predicate with None->raise (Field_empty "multiget_slice_args.predicate") | Some _x433 -> _x433
  method set_predicate _x433 = _predicate <- Some _x433
  method unset_predicate = _predicate <- None
  method reset_predicate = _predicate <- None

  val mutable _consistency_level : ConsistencyLevel.t =   ConsistencyLevel.ONE
  method get_consistency_level = Some _consistency_level
  method grab_consistency_level = _consistency_level
  method set_consistency_level _x434 = _consistency_level <- _x434
  method reset_consistency_level = _consistency_level <-   ConsistencyLevel.ONE

  method copy =
      let _new = Oo.copy self in
      if _column_parent <> None then
        _new#set_column_parent self#grab_column_parent#copy;
      if _predicate <> None then
        _new#set_predicate self#grab_predicate#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "multiget_slice_args";
    (match _keys with 
    | None -> raise (Field_empty "multiget_slice_args._keys")
    | Some _v -> 
      oprot#writeFieldBegin("keys",Protocol.T_LIST,1);
      oprot#writeListBegin(Protocol.T_STRING,List.length _v);
      List.iter (fun _iter437 ->         oprot#writeString(_iter437);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _column_parent with 
    | None -> raise (Field_empty "multiget_slice_args._column_parent")
    | Some _v -> 
      oprot#writeFieldBegin("column_parent",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _predicate with 
    | None -> raise (Field_empty "multiget_slice_args._predicate")
    | Some _v -> 
      oprot#writeFieldBegin("predicate",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,4);
      oprot#writeI32(ConsistencyLevel.to_i _consistency_level);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_multiget_slice_args (iprot : Protocol.t) =
  let _str438 = new multiget_slice_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t439,_id440) = iprot#readFieldBegin in
        if _t439 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id440 with 
          | 1 -> (if _t439 = Protocol.T_LIST then
              _str438#set_keys 
                (let (_etype444,_size441) = iprot#readListBegin in
                  let _con445 = (Array.to_list (Array.init _size441 (fun _ -> iprot#readString))) in
                    iprot#readListEnd; _con445)
            else
              iprot#skip _t439)
          | 2 -> (if _t439 = Protocol.T_STRUCT then
              _str438#set_column_parent (read_columnParent iprot)
            else
              iprot#skip _t439)
          | 3 -> (if _t439 = Protocol.T_STRUCT then
              _str438#set_predicate (read_slicePredicate iprot)
            else
              iprot#skip _t439)
          | 4 -> (if _t439 = Protocol.T_I32 then
              _str438#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t439)
          | _ -> iprot#skip _t439);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str438

class multiget_slice_result =
object (self)
  val mutable _success : (string,columnOrSuperColumn list) Hashtbl.t option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "multiget_slice_result.success") | Some _x446 -> _x446
  method set_success _x446 = _success <- Some _x446
  method unset_success = _success <- None
  method reset_success = _success <- None

  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "multiget_slice_result.ire") | Some _x447 -> _x447
  method set_ire _x447 = _ire <- Some _x447
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "multiget_slice_result.ue") | Some _x448 -> _x448
  method set_ue _x448 = _ue <- Some _x448
  method unset_ue = _ue <- None
  method reset_ue = _ue <- None

  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "multiget_slice_result.te") | Some _x449 -> _x449
  method set_te _x449 = _te <- Some _x449
  method unset_te = _te <- None
  method reset_te = _te <- None

  method copy =
      let _new = Oo.copy self in
      if _success <> None then
        _new#set_success ((fun oh -> let nh = Hashtbl.create (Hashtbl.length oh) in Hashtbl.iter (fun k v -> Hashtbl.add nh k (List.map (fun x -> x#copy) v)) oh; nh) self#grab_success);
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
      if _ue <> None then
        _new#set_ue self#grab_ue#copy;
      if _te <> None then
        _new#set_te self#grab_te#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "multiget_slice_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_MAP,0);
      oprot#writeMapBegin(Protocol.T_STRING,Protocol.T_LIST,Hashtbl.length _v);
      Hashtbl.iter (fun _kiter452 -> fun _viter453 -> 
        oprot#writeString(_kiter452);
        oprot#writeListBegin(Protocol.T_STRUCT,List.length _viter453);
        List.iter (fun _iter454 ->           _iter454#write(oprot);
        ) _viter453;
        oprot#writeListEnd;
      ) _v;
      oprot#writeMapEnd;
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_multiget_slice_result (iprot : Protocol.t) =
  let _str455 = new multiget_slice_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t456,_id457) = iprot#readFieldBegin in
        if _t456 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id457 with 
          | 0 -> (if _t456 = Protocol.T_MAP then
              _str455#set_success 
                (let (_ktype459,_vtype460,_size458) = iprot#readMapBegin in
                let _con462 = Hashtbl.create _size458 in
                  for i = 1 to _size458 do
                    let _k = iprot#readString in
                    let _v = 
                      (let (_etype466,_size463) = iprot#readListBegin in
                        let _con467 = (Array.to_list (Array.init _size463 (fun _ -> (read_columnOrSuperColumn iprot)))) in
                          iprot#readListEnd; _con467) in
                      Hashtbl.add _con462 _k _v
                  done; iprot#readMapEnd; _con462)
            else
              iprot#skip _t456)
          | 1 -> (if _t456 = Protocol.T_STRUCT then
              _str455#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t456)
          | 2 -> (if _t456 = Protocol.T_STRUCT then
              _str455#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t456)
          | 3 -> (if _t456 = Protocol.T_STRUCT then
              _str455#set_te (read_timedOutException iprot)
            else
              iprot#skip _t456)
          | _ -> iprot#skip _t456);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str455

class multiget_count_args =
object (self)
  val mutable _keys : string list option = None
  method get_keys = _keys
  method grab_keys = match _keys with None->raise (Field_empty "multiget_count_args.keys") | Some _x468 -> _x468
  method set_keys _x468 = _keys <- Some _x468
  method unset_keys = _keys <- None
  method reset_keys = _keys <- None

  val mutable _column_parent : columnParent option = None
  method get_column_parent = _column_parent
  method grab_column_parent = match _column_parent with None->raise (Field_empty "multiget_count_args.column_parent") | Some _x469 -> _x469
  method set_column_parent _x469 = _column_parent <- Some _x469
  method unset_column_parent = _column_parent <- None
  method reset_column_parent = _column_parent <- None

  val mutable _predicate : slicePredicate option = None
  method get_predicate = _predicate
  method grab_predicate = match _predicate with None->raise (Field_empty "multiget_count_args.predicate") | Some _x470 -> _x470
  method set_predicate _x470 = _predicate <- Some _x470
  method unset_predicate = _predicate <- None
  method reset_predicate = _predicate <- None

  val mutable _consistency_level : ConsistencyLevel.t =   ConsistencyLevel.ONE
  method get_consistency_level = Some _consistency_level
  method grab_consistency_level = _consistency_level
  method set_consistency_level _x471 = _consistency_level <- _x471
  method reset_consistency_level = _consistency_level <-   ConsistencyLevel.ONE

  method copy =
      let _new = Oo.copy self in
      if _column_parent <> None then
        _new#set_column_parent self#grab_column_parent#copy;
      if _predicate <> None then
        _new#set_predicate self#grab_predicate#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "multiget_count_args";
    (match _keys with 
    | None -> raise (Field_empty "multiget_count_args._keys")
    | Some _v -> 
      oprot#writeFieldBegin("keys",Protocol.T_LIST,1);
      oprot#writeListBegin(Protocol.T_STRING,List.length _v);
      List.iter (fun _iter474 ->         oprot#writeString(_iter474);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _column_parent with 
    | None -> raise (Field_empty "multiget_count_args._column_parent")
    | Some _v -> 
      oprot#writeFieldBegin("column_parent",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _predicate with 
    | None -> raise (Field_empty "multiget_count_args._predicate")
    | Some _v -> 
      oprot#writeFieldBegin("predicate",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,4);
      oprot#writeI32(ConsistencyLevel.to_i _consistency_level);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_multiget_count_args (iprot : Protocol.t) =
  let _str475 = new multiget_count_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t476,_id477) = iprot#readFieldBegin in
        if _t476 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id477 with 
          | 1 -> (if _t476 = Protocol.T_LIST then
              _str475#set_keys 
                (let (_etype481,_size478) = iprot#readListBegin in
                  let _con482 = (Array.to_list (Array.init _size478 (fun _ -> iprot#readString))) in
                    iprot#readListEnd; _con482)
            else
              iprot#skip _t476)
          | 2 -> (if _t476 = Protocol.T_STRUCT then
              _str475#set_column_parent (read_columnParent iprot)
            else
              iprot#skip _t476)
          | 3 -> (if _t476 = Protocol.T_STRUCT then
              _str475#set_predicate (read_slicePredicate iprot)
            else
              iprot#skip _t476)
          | 4 -> (if _t476 = Protocol.T_I32 then
              _str475#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t476)
          | _ -> iprot#skip _t476);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str475

class multiget_count_result =
object (self)
  val mutable _success : (string,int) Hashtbl.t option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "multiget_count_result.success") | Some _x483 -> _x483
  method set_success _x483 = _success <- Some _x483
  method unset_success = _success <- None
  method reset_success = _success <- None

  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "multiget_count_result.ire") | Some _x484 -> _x484
  method set_ire _x484 = _ire <- Some _x484
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "multiget_count_result.ue") | Some _x485 -> _x485
  method set_ue _x485 = _ue <- Some _x485
  method unset_ue = _ue <- None
  method reset_ue = _ue <- None

  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "multiget_count_result.te") | Some _x486 -> _x486
  method set_te _x486 = _te <- Some _x486
  method unset_te = _te <- None
  method reset_te = _te <- None

  method copy =
      let _new = Oo.copy self in
      if _success <> None then
        _new#set_success (Hashtbl.copy self#grab_success);
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
      if _ue <> None then
        _new#set_ue self#grab_ue#copy;
      if _te <> None then
        _new#set_te self#grab_te#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "multiget_count_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_MAP,0);
      oprot#writeMapBegin(Protocol.T_STRING,Protocol.T_I32,Hashtbl.length _v);
      Hashtbl.iter (fun _kiter489 -> fun _viter490 -> 
        oprot#writeString(_kiter489);
        oprot#writeI32(_viter490);
      ) _v;
      oprot#writeMapEnd;
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_multiget_count_result (iprot : Protocol.t) =
  let _str491 = new multiget_count_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t492,_id493) = iprot#readFieldBegin in
        if _t492 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id493 with 
          | 0 -> (if _t492 = Protocol.T_MAP then
              _str491#set_success 
                (let (_ktype495,_vtype496,_size494) = iprot#readMapBegin in
                let _con498 = Hashtbl.create _size494 in
                  for i = 1 to _size494 do
                    let _k = iprot#readString in
                    let _v = iprot#readI32 in
                      Hashtbl.add _con498 _k _v
                  done; iprot#readMapEnd; _con498)
            else
              iprot#skip _t492)
          | 1 -> (if _t492 = Protocol.T_STRUCT then
              _str491#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t492)
          | 2 -> (if _t492 = Protocol.T_STRUCT then
              _str491#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t492)
          | 3 -> (if _t492 = Protocol.T_STRUCT then
              _str491#set_te (read_timedOutException iprot)
            else
              iprot#skip _t492)
          | _ -> iprot#skip _t492);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str491

class get_range_slices_args =
object (self)
  val mutable _column_parent : columnParent option = None
  method get_column_parent = _column_parent
  method grab_column_parent = match _column_parent with None->raise (Field_empty "get_range_slices_args.column_parent") | Some _x499 -> _x499
  method set_column_parent _x499 = _column_parent <- Some _x499
  method unset_column_parent = _column_parent <- None
  method reset_column_parent = _column_parent <- None

  val mutable _predicate : slicePredicate option = None
  method get_predicate = _predicate
  method grab_predicate = match _predicate with None->raise (Field_empty "get_range_slices_args.predicate") | Some _x500 -> _x500
  method set_predicate _x500 = _predicate <- Some _x500
  method unset_predicate = _predicate <- None
  method reset_predicate = _predicate <- None

  val mutable _range : keyRange option = None
  method get_range = _range
  method grab_range = match _range with None->raise (Field_empty "get_range_slices_args.range") | Some _x501 -> _x501
  method set_range _x501 = _range <- Some _x501
  method unset_range = _range <- None
  method reset_range = _range <- None

  val mutable _consistency_level : ConsistencyLevel.t =   ConsistencyLevel.ONE
  method get_consistency_level = Some _consistency_level
  method grab_consistency_level = _consistency_level
  method set_consistency_level _x502 = _consistency_level <- _x502
  method reset_consistency_level = _consistency_level <-   ConsistencyLevel.ONE

  method copy =
      let _new = Oo.copy self in
      if _column_parent <> None then
        _new#set_column_parent self#grab_column_parent#copy;
      if _predicate <> None then
        _new#set_predicate self#grab_predicate#copy;
      if _range <> None then
        _new#set_range self#grab_range#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_range_slices_args";
    (match _column_parent with 
    | None -> raise (Field_empty "get_range_slices_args._column_parent")
    | Some _v -> 
      oprot#writeFieldBegin("column_parent",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _predicate with 
    | None -> raise (Field_empty "get_range_slices_args._predicate")
    | Some _v -> 
      oprot#writeFieldBegin("predicate",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _range with 
    | None -> raise (Field_empty "get_range_slices_args._range")
    | Some _v -> 
      oprot#writeFieldBegin("range",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,4);
      oprot#writeI32(ConsistencyLevel.to_i _consistency_level);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_range_slices_args (iprot : Protocol.t) =
  let _str505 = new get_range_slices_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t506,_id507) = iprot#readFieldBegin in
        if _t506 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id507 with 
          | 1 -> (if _t506 = Protocol.T_STRUCT then
              _str505#set_column_parent (read_columnParent iprot)
            else
              iprot#skip _t506)
          | 2 -> (if _t506 = Protocol.T_STRUCT then
              _str505#set_predicate (read_slicePredicate iprot)
            else
              iprot#skip _t506)
          | 3 -> (if _t506 = Protocol.T_STRUCT then
              _str505#set_range (read_keyRange iprot)
            else
              iprot#skip _t506)
          | 4 -> (if _t506 = Protocol.T_I32 then
              _str505#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t506)
          | _ -> iprot#skip _t506);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str505

class get_range_slices_result =
object (self)
  val mutable _success : keySlice list option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "get_range_slices_result.success") | Some _x508 -> _x508
  method set_success _x508 = _success <- Some _x508
  method unset_success = _success <- None
  method reset_success = _success <- None

  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "get_range_slices_result.ire") | Some _x509 -> _x509
  method set_ire _x509 = _ire <- Some _x509
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "get_range_slices_result.ue") | Some _x510 -> _x510
  method set_ue _x510 = _ue <- Some _x510
  method unset_ue = _ue <- None
  method reset_ue = _ue <- None

  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "get_range_slices_result.te") | Some _x511 -> _x511
  method set_te _x511 = _te <- Some _x511
  method unset_te = _te <- None
  method reset_te = _te <- None

  method copy =
      let _new = Oo.copy self in
      if _success <> None then
        _new#set_success (List.map (fun x -> x#copy) self#grab_success);
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
      if _ue <> None then
        _new#set_ue self#grab_ue#copy;
      if _te <> None then
        _new#set_te self#grab_te#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_range_slices_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_LIST,0);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter514 ->         _iter514#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_range_slices_result (iprot : Protocol.t) =
  let _str515 = new get_range_slices_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t516,_id517) = iprot#readFieldBegin in
        if _t516 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id517 with 
          | 0 -> (if _t516 = Protocol.T_LIST then
              _str515#set_success 
                (let (_etype521,_size518) = iprot#readListBegin in
                  let _con522 = (Array.to_list (Array.init _size518 (fun _ -> (read_keySlice iprot)))) in
                    iprot#readListEnd; _con522)
            else
              iprot#skip _t516)
          | 1 -> (if _t516 = Protocol.T_STRUCT then
              _str515#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t516)
          | 2 -> (if _t516 = Protocol.T_STRUCT then
              _str515#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t516)
          | 3 -> (if _t516 = Protocol.T_STRUCT then
              _str515#set_te (read_timedOutException iprot)
            else
              iprot#skip _t516)
          | _ -> iprot#skip _t516);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str515

class get_indexed_slices_args =
object (self)
  val mutable _column_parent : columnParent option = None
  method get_column_parent = _column_parent
  method grab_column_parent = match _column_parent with None->raise (Field_empty "get_indexed_slices_args.column_parent") | Some _x523 -> _x523
  method set_column_parent _x523 = _column_parent <- Some _x523
  method unset_column_parent = _column_parent <- None
  method reset_column_parent = _column_parent <- None

  val mutable _index_clause : indexClause option = None
  method get_index_clause = _index_clause
  method grab_index_clause = match _index_clause with None->raise (Field_empty "get_indexed_slices_args.index_clause") | Some _x524 -> _x524
  method set_index_clause _x524 = _index_clause <- Some _x524
  method unset_index_clause = _index_clause <- None
  method reset_index_clause = _index_clause <- None

  val mutable _column_predicate : slicePredicate option = None
  method get_column_predicate = _column_predicate
  method grab_column_predicate = match _column_predicate with None->raise (Field_empty "get_indexed_slices_args.column_predicate") | Some _x525 -> _x525
  method set_column_predicate _x525 = _column_predicate <- Some _x525
  method unset_column_predicate = _column_predicate <- None
  method reset_column_predicate = _column_predicate <- None

  val mutable _consistency_level : ConsistencyLevel.t =   ConsistencyLevel.ONE
  method get_consistency_level = Some _consistency_level
  method grab_consistency_level = _consistency_level
  method set_consistency_level _x526 = _consistency_level <- _x526
  method reset_consistency_level = _consistency_level <-   ConsistencyLevel.ONE

  method copy =
      let _new = Oo.copy self in
      if _column_parent <> None then
        _new#set_column_parent self#grab_column_parent#copy;
      if _index_clause <> None then
        _new#set_index_clause self#grab_index_clause#copy;
      if _column_predicate <> None then
        _new#set_column_predicate self#grab_column_predicate#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_indexed_slices_args";
    (match _column_parent with 
    | None -> raise (Field_empty "get_indexed_slices_args._column_parent")
    | Some _v -> 
      oprot#writeFieldBegin("column_parent",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _index_clause with 
    | None -> raise (Field_empty "get_indexed_slices_args._index_clause")
    | Some _v -> 
      oprot#writeFieldBegin("index_clause",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _column_predicate with 
    | None -> raise (Field_empty "get_indexed_slices_args._column_predicate")
    | Some _v -> 
      oprot#writeFieldBegin("column_predicate",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,4);
      oprot#writeI32(ConsistencyLevel.to_i _consistency_level);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_indexed_slices_args (iprot : Protocol.t) =
  let _str529 = new get_indexed_slices_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t530,_id531) = iprot#readFieldBegin in
        if _t530 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id531 with 
          | 1 -> (if _t530 = Protocol.T_STRUCT then
              _str529#set_column_parent (read_columnParent iprot)
            else
              iprot#skip _t530)
          | 2 -> (if _t530 = Protocol.T_STRUCT then
              _str529#set_index_clause (read_indexClause iprot)
            else
              iprot#skip _t530)
          | 3 -> (if _t530 = Protocol.T_STRUCT then
              _str529#set_column_predicate (read_slicePredicate iprot)
            else
              iprot#skip _t530)
          | 4 -> (if _t530 = Protocol.T_I32 then
              _str529#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t530)
          | _ -> iprot#skip _t530);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str529

class get_indexed_slices_result =
object (self)
  val mutable _success : keySlice list option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "get_indexed_slices_result.success") | Some _x532 -> _x532
  method set_success _x532 = _success <- Some _x532
  method unset_success = _success <- None
  method reset_success = _success <- None

  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "get_indexed_slices_result.ire") | Some _x533 -> _x533
  method set_ire _x533 = _ire <- Some _x533
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "get_indexed_slices_result.ue") | Some _x534 -> _x534
  method set_ue _x534 = _ue <- Some _x534
  method unset_ue = _ue <- None
  method reset_ue = _ue <- None

  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "get_indexed_slices_result.te") | Some _x535 -> _x535
  method set_te _x535 = _te <- Some _x535
  method unset_te = _te <- None
  method reset_te = _te <- None

  method copy =
      let _new = Oo.copy self in
      if _success <> None then
        _new#set_success (List.map (fun x -> x#copy) self#grab_success);
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
      if _ue <> None then
        _new#set_ue self#grab_ue#copy;
      if _te <> None then
        _new#set_te self#grab_te#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_indexed_slices_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_LIST,0);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter538 ->         _iter538#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_indexed_slices_result (iprot : Protocol.t) =
  let _str539 = new get_indexed_slices_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t540,_id541) = iprot#readFieldBegin in
        if _t540 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id541 with 
          | 0 -> (if _t540 = Protocol.T_LIST then
              _str539#set_success 
                (let (_etype545,_size542) = iprot#readListBegin in
                  let _con546 = (Array.to_list (Array.init _size542 (fun _ -> (read_keySlice iprot)))) in
                    iprot#readListEnd; _con546)
            else
              iprot#skip _t540)
          | 1 -> (if _t540 = Protocol.T_STRUCT then
              _str539#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t540)
          | 2 -> (if _t540 = Protocol.T_STRUCT then
              _str539#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t540)
          | 3 -> (if _t540 = Protocol.T_STRUCT then
              _str539#set_te (read_timedOutException iprot)
            else
              iprot#skip _t540)
          | _ -> iprot#skip _t540);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str539

class insert_args =
object (self)
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "insert_args.key") | Some _x547 -> _x547
  method set_key _x547 = _key <- Some _x547
  method unset_key = _key <- None
  method reset_key = _key <- None

  val mutable _column_parent : columnParent option = None
  method get_column_parent = _column_parent
  method grab_column_parent = match _column_parent with None->raise (Field_empty "insert_args.column_parent") | Some _x548 -> _x548
  method set_column_parent _x548 = _column_parent <- Some _x548
  method unset_column_parent = _column_parent <- None
  method reset_column_parent = _column_parent <- None

  val mutable _column : column option = None
  method get_column = _column
  method grab_column = match _column with None->raise (Field_empty "insert_args.column") | Some _x549 -> _x549
  method set_column _x549 = _column <- Some _x549
  method unset_column = _column <- None
  method reset_column = _column <- None

  val mutable _consistency_level : ConsistencyLevel.t =   ConsistencyLevel.ONE
  method get_consistency_level = Some _consistency_level
  method grab_consistency_level = _consistency_level
  method set_consistency_level _x550 = _consistency_level <- _x550
  method reset_consistency_level = _consistency_level <-   ConsistencyLevel.ONE

  method copy =
      let _new = Oo.copy self in
      if _column_parent <> None then
        _new#set_column_parent self#grab_column_parent#copy;
      if _column <> None then
        _new#set_column self#grab_column#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "insert_args";
    (match _key with 
    | None -> raise (Field_empty "insert_args._key")
    | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _column_parent with 
    | None -> raise (Field_empty "insert_args._column_parent")
    | Some _v -> 
      oprot#writeFieldBegin("column_parent",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _column with 
    | None -> raise (Field_empty "insert_args._column")
    | Some _v -> 
      oprot#writeFieldBegin("column",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,4);
      oprot#writeI32(ConsistencyLevel.to_i _consistency_level);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_insert_args (iprot : Protocol.t) =
  let _str553 = new insert_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t554,_id555) = iprot#readFieldBegin in
        if _t554 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id555 with 
          | 1 -> (if _t554 = Protocol.T_STRING then
              _str553#set_key iprot#readString
            else
              iprot#skip _t554)
          | 2 -> (if _t554 = Protocol.T_STRUCT then
              _str553#set_column_parent (read_columnParent iprot)
            else
              iprot#skip _t554)
          | 3 -> (if _t554 = Protocol.T_STRUCT then
              _str553#set_column (read_column iprot)
            else
              iprot#skip _t554)
          | 4 -> (if _t554 = Protocol.T_I32 then
              _str553#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t554)
          | _ -> iprot#skip _t554);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str553

class insert_result =
object (self)
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "insert_result.ire") | Some _x556 -> _x556
  method set_ire _x556 = _ire <- Some _x556
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "insert_result.ue") | Some _x557 -> _x557
  method set_ue _x557 = _ue <- Some _x557
  method unset_ue = _ue <- None
  method reset_ue = _ue <- None

  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "insert_result.te") | Some _x558 -> _x558
  method set_te _x558 = _te <- Some _x558
  method unset_te = _te <- None
  method reset_te = _te <- None

  method copy =
      let _new = Oo.copy self in
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
      if _ue <> None then
        _new#set_ue self#grab_ue#copy;
      if _te <> None then
        _new#set_te self#grab_te#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "insert_result";
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_insert_result (iprot : Protocol.t) =
  let _str561 = new insert_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t562,_id563) = iprot#readFieldBegin in
        if _t562 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id563 with 
          | 1 -> (if _t562 = Protocol.T_STRUCT then
              _str561#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t562)
          | 2 -> (if _t562 = Protocol.T_STRUCT then
              _str561#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t562)
          | 3 -> (if _t562 = Protocol.T_STRUCT then
              _str561#set_te (read_timedOutException iprot)
            else
              iprot#skip _t562)
          | _ -> iprot#skip _t562);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str561

class add_args =
object (self)
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "add_args.key") | Some _x564 -> _x564
  method set_key _x564 = _key <- Some _x564
  method unset_key = _key <- None
  method reset_key = _key <- None

  val mutable _column_parent : columnParent option = None
  method get_column_parent = _column_parent
  method grab_column_parent = match _column_parent with None->raise (Field_empty "add_args.column_parent") | Some _x565 -> _x565
  method set_column_parent _x565 = _column_parent <- Some _x565
  method unset_column_parent = _column_parent <- None
  method reset_column_parent = _column_parent <- None

  val mutable _column : counterColumn option = None
  method get_column = _column
  method grab_column = match _column with None->raise (Field_empty "add_args.column") | Some _x566 -> _x566
  method set_column _x566 = _column <- Some _x566
  method unset_column = _column <- None
  method reset_column = _column <- None

  val mutable _consistency_level : ConsistencyLevel.t =   ConsistencyLevel.ONE
  method get_consistency_level = Some _consistency_level
  method grab_consistency_level = _consistency_level
  method set_consistency_level _x567 = _consistency_level <- _x567
  method reset_consistency_level = _consistency_level <-   ConsistencyLevel.ONE

  method copy =
      let _new = Oo.copy self in
      if _column_parent <> None then
        _new#set_column_parent self#grab_column_parent#copy;
      if _column <> None then
        _new#set_column self#grab_column#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "add_args";
    (match _key with 
    | None -> raise (Field_empty "add_args._key")
    | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _column_parent with 
    | None -> raise (Field_empty "add_args._column_parent")
    | Some _v -> 
      oprot#writeFieldBegin("column_parent",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _column with 
    | None -> raise (Field_empty "add_args._column")
    | Some _v -> 
      oprot#writeFieldBegin("column",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,4);
      oprot#writeI32(ConsistencyLevel.to_i _consistency_level);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_add_args (iprot : Protocol.t) =
  let _str570 = new add_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t571,_id572) = iprot#readFieldBegin in
        if _t571 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id572 with 
          | 1 -> (if _t571 = Protocol.T_STRING then
              _str570#set_key iprot#readString
            else
              iprot#skip _t571)
          | 2 -> (if _t571 = Protocol.T_STRUCT then
              _str570#set_column_parent (read_columnParent iprot)
            else
              iprot#skip _t571)
          | 3 -> (if _t571 = Protocol.T_STRUCT then
              _str570#set_column (read_counterColumn iprot)
            else
              iprot#skip _t571)
          | 4 -> (if _t571 = Protocol.T_I32 then
              _str570#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t571)
          | _ -> iprot#skip _t571);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str570

class add_result =
object (self)
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "add_result.ire") | Some _x573 -> _x573
  method set_ire _x573 = _ire <- Some _x573
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "add_result.ue") | Some _x574 -> _x574
  method set_ue _x574 = _ue <- Some _x574
  method unset_ue = _ue <- None
  method reset_ue = _ue <- None

  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "add_result.te") | Some _x575 -> _x575
  method set_te _x575 = _te <- Some _x575
  method unset_te = _te <- None
  method reset_te = _te <- None

  method copy =
      let _new = Oo.copy self in
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
      if _ue <> None then
        _new#set_ue self#grab_ue#copy;
      if _te <> None then
        _new#set_te self#grab_te#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "add_result";
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_add_result (iprot : Protocol.t) =
  let _str578 = new add_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t579,_id580) = iprot#readFieldBegin in
        if _t579 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id580 with 
          | 1 -> (if _t579 = Protocol.T_STRUCT then
              _str578#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t579)
          | 2 -> (if _t579 = Protocol.T_STRUCT then
              _str578#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t579)
          | 3 -> (if _t579 = Protocol.T_STRUCT then
              _str578#set_te (read_timedOutException iprot)
            else
              iprot#skip _t579)
          | _ -> iprot#skip _t579);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str578

class remove_args =
object (self)
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "remove_args.key") | Some _x581 -> _x581
  method set_key _x581 = _key <- Some _x581
  method unset_key = _key <- None
  method reset_key = _key <- None

  val mutable _column_path : columnPath option = None
  method get_column_path = _column_path
  method grab_column_path = match _column_path with None->raise (Field_empty "remove_args.column_path") | Some _x582 -> _x582
  method set_column_path _x582 = _column_path <- Some _x582
  method unset_column_path = _column_path <- None
  method reset_column_path = _column_path <- None

  val mutable _timestamp : Int64.t option = None
  method get_timestamp = _timestamp
  method grab_timestamp = match _timestamp with None->raise (Field_empty "remove_args.timestamp") | Some _x583 -> _x583
  method set_timestamp _x583 = _timestamp <- Some _x583
  method unset_timestamp = _timestamp <- None
  method reset_timestamp = _timestamp <- None

  val mutable _consistency_level : ConsistencyLevel.t =   ConsistencyLevel.ONE
  method get_consistency_level = Some _consistency_level
  method grab_consistency_level = _consistency_level
  method set_consistency_level _x584 = _consistency_level <- _x584
  method reset_consistency_level = _consistency_level <-   ConsistencyLevel.ONE

  method copy =
      let _new = Oo.copy self in
      if _column_path <> None then
        _new#set_column_path self#grab_column_path#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "remove_args";
    (match _key with 
    | None -> raise (Field_empty "remove_args._key")
    | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _column_path with 
    | None -> raise (Field_empty "remove_args._column_path")
    | Some _v -> 
      oprot#writeFieldBegin("column_path",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _timestamp with 
    | None -> raise (Field_empty "remove_args._timestamp")
    | Some _v -> 
      oprot#writeFieldBegin("timestamp",Protocol.T_I64,3);
      oprot#writeI64(_v);
      oprot#writeFieldEnd
    );
    (
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,4);
      oprot#writeI32(ConsistencyLevel.to_i _consistency_level);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_remove_args (iprot : Protocol.t) =
  let _str587 = new remove_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t588,_id589) = iprot#readFieldBegin in
        if _t588 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id589 with 
          | 1 -> (if _t588 = Protocol.T_STRING then
              _str587#set_key iprot#readString
            else
              iprot#skip _t588)
          | 2 -> (if _t588 = Protocol.T_STRUCT then
              _str587#set_column_path (read_columnPath iprot)
            else
              iprot#skip _t588)
          | 3 -> (if _t588 = Protocol.T_I64 then
              _str587#set_timestamp iprot#readI64
            else
              iprot#skip _t588)
          | 4 -> (if _t588 = Protocol.T_I32 then
              _str587#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t588)
          | _ -> iprot#skip _t588);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str587

class remove_result =
object (self)
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "remove_result.ire") | Some _x590 -> _x590
  method set_ire _x590 = _ire <- Some _x590
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "remove_result.ue") | Some _x591 -> _x591
  method set_ue _x591 = _ue <- Some _x591
  method unset_ue = _ue <- None
  method reset_ue = _ue <- None

  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "remove_result.te") | Some _x592 -> _x592
  method set_te _x592 = _te <- Some _x592
  method unset_te = _te <- None
  method reset_te = _te <- None

  method copy =
      let _new = Oo.copy self in
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
      if _ue <> None then
        _new#set_ue self#grab_ue#copy;
      if _te <> None then
        _new#set_te self#grab_te#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "remove_result";
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_remove_result (iprot : Protocol.t) =
  let _str595 = new remove_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t596,_id597) = iprot#readFieldBegin in
        if _t596 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id597 with 
          | 1 -> (if _t596 = Protocol.T_STRUCT then
              _str595#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t596)
          | 2 -> (if _t596 = Protocol.T_STRUCT then
              _str595#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t596)
          | 3 -> (if _t596 = Protocol.T_STRUCT then
              _str595#set_te (read_timedOutException iprot)
            else
              iprot#skip _t596)
          | _ -> iprot#skip _t596);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str595

class remove_counter_args =
object (self)
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "remove_counter_args.key") | Some _x598 -> _x598
  method set_key _x598 = _key <- Some _x598
  method unset_key = _key <- None
  method reset_key = _key <- None

  val mutable _path : columnPath option = None
  method get_path = _path
  method grab_path = match _path with None->raise (Field_empty "remove_counter_args.path") | Some _x599 -> _x599
  method set_path _x599 = _path <- Some _x599
  method unset_path = _path <- None
  method reset_path = _path <- None

  val mutable _consistency_level : ConsistencyLevel.t =   ConsistencyLevel.ONE
  method get_consistency_level = Some _consistency_level
  method grab_consistency_level = _consistency_level
  method set_consistency_level _x600 = _consistency_level <- _x600
  method reset_consistency_level = _consistency_level <-   ConsistencyLevel.ONE

  method copy =
      let _new = Oo.copy self in
      if _path <> None then
        _new#set_path self#grab_path#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "remove_counter_args";
    (match _key with 
    | None -> raise (Field_empty "remove_counter_args._key")
    | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _path with 
    | None -> raise (Field_empty "remove_counter_args._path")
    | Some _v -> 
      oprot#writeFieldBegin("path",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,3);
      oprot#writeI32(ConsistencyLevel.to_i _consistency_level);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_remove_counter_args (iprot : Protocol.t) =
  let _str603 = new remove_counter_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t604,_id605) = iprot#readFieldBegin in
        if _t604 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id605 with 
          | 1 -> (if _t604 = Protocol.T_STRING then
              _str603#set_key iprot#readString
            else
              iprot#skip _t604)
          | 2 -> (if _t604 = Protocol.T_STRUCT then
              _str603#set_path (read_columnPath iprot)
            else
              iprot#skip _t604)
          | 3 -> (if _t604 = Protocol.T_I32 then
              _str603#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t604)
          | _ -> iprot#skip _t604);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str603

class remove_counter_result =
object (self)
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "remove_counter_result.ire") | Some _x606 -> _x606
  method set_ire _x606 = _ire <- Some _x606
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "remove_counter_result.ue") | Some _x607 -> _x607
  method set_ue _x607 = _ue <- Some _x607
  method unset_ue = _ue <- None
  method reset_ue = _ue <- None

  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "remove_counter_result.te") | Some _x608 -> _x608
  method set_te _x608 = _te <- Some _x608
  method unset_te = _te <- None
  method reset_te = _te <- None

  method copy =
      let _new = Oo.copy self in
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
      if _ue <> None then
        _new#set_ue self#grab_ue#copy;
      if _te <> None then
        _new#set_te self#grab_te#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "remove_counter_result";
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_remove_counter_result (iprot : Protocol.t) =
  let _str611 = new remove_counter_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t612,_id613) = iprot#readFieldBegin in
        if _t612 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id613 with 
          | 1 -> (if _t612 = Protocol.T_STRUCT then
              _str611#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t612)
          | 2 -> (if _t612 = Protocol.T_STRUCT then
              _str611#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t612)
          | 3 -> (if _t612 = Protocol.T_STRUCT then
              _str611#set_te (read_timedOutException iprot)
            else
              iprot#skip _t612)
          | _ -> iprot#skip _t612);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str611

class batch_mutate_args =
object (self)
  val mutable _mutation_map : (string,(string,mutation list) Hashtbl.t) Hashtbl.t option = None
  method get_mutation_map = _mutation_map
  method grab_mutation_map = match _mutation_map with None->raise (Field_empty "batch_mutate_args.mutation_map") | Some _x614 -> _x614
  method set_mutation_map _x614 = _mutation_map <- Some _x614
  method unset_mutation_map = _mutation_map <- None
  method reset_mutation_map = _mutation_map <- None

  val mutable _consistency_level : ConsistencyLevel.t =   ConsistencyLevel.ONE
  method get_consistency_level = Some _consistency_level
  method grab_consistency_level = _consistency_level
  method set_consistency_level _x615 = _consistency_level <- _x615
  method reset_consistency_level = _consistency_level <-   ConsistencyLevel.ONE

  method copy =
      let _new = Oo.copy self in
      if _mutation_map <> None then
        _new#set_mutation_map ((fun oh -> let nh = Hashtbl.create (Hashtbl.length oh) in Hashtbl.iter (fun k v -> Hashtbl.add nh k ((fun oh -> let nh = Hashtbl.create (Hashtbl.length oh) in Hashtbl.iter (fun k v -> Hashtbl.add nh k (List.map (fun x -> x#copy) v)) oh; nh) v)) oh; nh) self#grab_mutation_map);
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "batch_mutate_args";
    (match _mutation_map with 
    | None -> raise (Field_empty "batch_mutate_args._mutation_map")
    | Some _v -> 
      oprot#writeFieldBegin("mutation_map",Protocol.T_MAP,1);
      oprot#writeMapBegin(Protocol.T_STRING,Protocol.T_MAP,Hashtbl.length _v);
      Hashtbl.iter (fun _kiter618 -> fun _viter619 -> 
        oprot#writeString(_kiter618);
        oprot#writeMapBegin(Protocol.T_STRING,Protocol.T_LIST,Hashtbl.length _viter619);
        Hashtbl.iter (fun _kiter620 -> fun _viter621 -> 
          oprot#writeString(_kiter620);
          oprot#writeListBegin(Protocol.T_STRUCT,List.length _viter621);
          List.iter (fun _iter622 ->             _iter622#write(oprot);
          ) _viter621;
          oprot#writeListEnd;
        ) _viter619;
        oprot#writeMapEnd;
      ) _v;
      oprot#writeMapEnd;
      oprot#writeFieldEnd
    );
    (
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,2);
      oprot#writeI32(ConsistencyLevel.to_i _consistency_level);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_batch_mutate_args (iprot : Protocol.t) =
  let _str623 = new batch_mutate_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t624,_id625) = iprot#readFieldBegin in
        if _t624 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id625 with 
          | 1 -> (if _t624 = Protocol.T_MAP then
              _str623#set_mutation_map 
                (let (_ktype627,_vtype628,_size626) = iprot#readMapBegin in
                let _con630 = Hashtbl.create _size626 in
                  for i = 1 to _size626 do
                    let _k = iprot#readString in
                    let _v = 
                      (let (_ktype632,_vtype633,_size631) = iprot#readMapBegin in
                      let _con635 = Hashtbl.create _size631 in
                        for i = 1 to _size631 do
                          let _k = iprot#readString in
                          let _v = 
                            (let (_etype639,_size636) = iprot#readListBegin in
                              let _con640 = (Array.to_list (Array.init _size636 (fun _ -> (read_mutation iprot)))) in
                                iprot#readListEnd; _con640) in
                            Hashtbl.add _con635 _k _v
                        done; iprot#readMapEnd; _con635) in
                      Hashtbl.add _con630 _k _v
                  done; iprot#readMapEnd; _con630)
            else
              iprot#skip _t624)
          | 2 -> (if _t624 = Protocol.T_I32 then
              _str623#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t624)
          | _ -> iprot#skip _t624);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str623

class batch_mutate_result =
object (self)
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "batch_mutate_result.ire") | Some _x641 -> _x641
  method set_ire _x641 = _ire <- Some _x641
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "batch_mutate_result.ue") | Some _x642 -> _x642
  method set_ue _x642 = _ue <- Some _x642
  method unset_ue = _ue <- None
  method reset_ue = _ue <- None

  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "batch_mutate_result.te") | Some _x643 -> _x643
  method set_te _x643 = _te <- Some _x643
  method unset_te = _te <- None
  method reset_te = _te <- None

  method copy =
      let _new = Oo.copy self in
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
      if _ue <> None then
        _new#set_ue self#grab_ue#copy;
      if _te <> None then
        _new#set_te self#grab_te#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "batch_mutate_result";
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_batch_mutate_result (iprot : Protocol.t) =
  let _str646 = new batch_mutate_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t647,_id648) = iprot#readFieldBegin in
        if _t647 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id648 with 
          | 1 -> (if _t647 = Protocol.T_STRUCT then
              _str646#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t647)
          | 2 -> (if _t647 = Protocol.T_STRUCT then
              _str646#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t647)
          | 3 -> (if _t647 = Protocol.T_STRUCT then
              _str646#set_te (read_timedOutException iprot)
            else
              iprot#skip _t647)
          | _ -> iprot#skip _t647);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str646

class truncate_args =
object (self)
  val mutable _cfname : string option = None
  method get_cfname = _cfname
  method grab_cfname = match _cfname with None->raise (Field_empty "truncate_args.cfname") | Some _x649 -> _x649
  method set_cfname _x649 = _cfname <- Some _x649
  method unset_cfname = _cfname <- None
  method reset_cfname = _cfname <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "truncate_args";
    (match _cfname with 
    | None -> raise (Field_empty "truncate_args._cfname")
    | Some _v -> 
      oprot#writeFieldBegin("cfname",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_truncate_args (iprot : Protocol.t) =
  let _str652 = new truncate_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t653,_id654) = iprot#readFieldBegin in
        if _t653 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id654 with 
          | 1 -> (if _t653 = Protocol.T_STRING then
              _str652#set_cfname iprot#readString
            else
              iprot#skip _t653)
          | _ -> iprot#skip _t653);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str652

class truncate_result =
object (self)
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "truncate_result.ire") | Some _x655 -> _x655
  method set_ire _x655 = _ire <- Some _x655
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "truncate_result.ue") | Some _x656 -> _x656
  method set_ue _x656 = _ue <- Some _x656
  method unset_ue = _ue <- None
  method reset_ue = _ue <- None

  method copy =
      let _new = Oo.copy self in
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
      if _ue <> None then
        _new#set_ue self#grab_ue#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "truncate_result";
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_truncate_result (iprot : Protocol.t) =
  let _str659 = new truncate_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t660,_id661) = iprot#readFieldBegin in
        if _t660 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id661 with 
          | 1 -> (if _t660 = Protocol.T_STRUCT then
              _str659#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t660)
          | 2 -> (if _t660 = Protocol.T_STRUCT then
              _str659#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t660)
          | _ -> iprot#skip _t660);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str659

class describe_schema_versions_args =
object (self)
  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_schema_versions_args";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_schema_versions_args (iprot : Protocol.t) =
  let _str664 = new describe_schema_versions_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t665,_id666) = iprot#readFieldBegin in
        if _t665 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id666 with 
          | _ -> iprot#skip _t665);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str664

class describe_schema_versions_result =
object (self)
  val mutable _success : (string,string list) Hashtbl.t option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "describe_schema_versions_result.success") | Some _x667 -> _x667
  method set_success _x667 = _success <- Some _x667
  method unset_success = _success <- None
  method reset_success = _success <- None

  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "describe_schema_versions_result.ire") | Some _x668 -> _x668
  method set_ire _x668 = _ire <- Some _x668
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  method copy =
      let _new = Oo.copy self in
      if _success <> None then
        _new#set_success (Hashtbl.copy self#grab_success);
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_schema_versions_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_MAP,0);
      oprot#writeMapBegin(Protocol.T_STRING,Protocol.T_LIST,Hashtbl.length _v);
      Hashtbl.iter (fun _kiter671 -> fun _viter672 -> 
        oprot#writeString(_kiter671);
        oprot#writeListBegin(Protocol.T_STRING,List.length _viter672);
        List.iter (fun _iter673 ->           oprot#writeString(_iter673);
        ) _viter672;
        oprot#writeListEnd;
      ) _v;
      oprot#writeMapEnd;
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_schema_versions_result (iprot : Protocol.t) =
  let _str674 = new describe_schema_versions_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t675,_id676) = iprot#readFieldBegin in
        if _t675 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id676 with 
          | 0 -> (if _t675 = Protocol.T_MAP then
              _str674#set_success 
                (let (_ktype678,_vtype679,_size677) = iprot#readMapBegin in
                let _con681 = Hashtbl.create _size677 in
                  for i = 1 to _size677 do
                    let _k = iprot#readString in
                    let _v = 
                      (let (_etype685,_size682) = iprot#readListBegin in
                        let _con686 = (Array.to_list (Array.init _size682 (fun _ -> iprot#readString))) in
                          iprot#readListEnd; _con686) in
                      Hashtbl.add _con681 _k _v
                  done; iprot#readMapEnd; _con681)
            else
              iprot#skip _t675)
          | 1 -> (if _t675 = Protocol.T_STRUCT then
              _str674#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t675)
          | _ -> iprot#skip _t675);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str674

class describe_keyspaces_args =
object (self)
  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_keyspaces_args";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_keyspaces_args (iprot : Protocol.t) =
  let _str689 = new describe_keyspaces_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t690,_id691) = iprot#readFieldBegin in
        if _t690 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id691 with 
          | _ -> iprot#skip _t690);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str689

class describe_keyspaces_result =
object (self)
  val mutable _success : ksDef list option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "describe_keyspaces_result.success") | Some _x692 -> _x692
  method set_success _x692 = _success <- Some _x692
  method unset_success = _success <- None
  method reset_success = _success <- None

  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "describe_keyspaces_result.ire") | Some _x693 -> _x693
  method set_ire _x693 = _ire <- Some _x693
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  method copy =
      let _new = Oo.copy self in
      if _success <> None then
        _new#set_success (List.map (fun x -> x#copy) self#grab_success);
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_keyspaces_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_LIST,0);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter696 ->         _iter696#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_keyspaces_result (iprot : Protocol.t) =
  let _str697 = new describe_keyspaces_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t698,_id699) = iprot#readFieldBegin in
        if _t698 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id699 with 
          | 0 -> (if _t698 = Protocol.T_LIST then
              _str697#set_success 
                (let (_etype703,_size700) = iprot#readListBegin in
                  let _con704 = (Array.to_list (Array.init _size700 (fun _ -> (read_ksDef iprot)))) in
                    iprot#readListEnd; _con704)
            else
              iprot#skip _t698)
          | 1 -> (if _t698 = Protocol.T_STRUCT then
              _str697#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t698)
          | _ -> iprot#skip _t698);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str697

class describe_cluster_name_args =
object (self)
  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_cluster_name_args";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_cluster_name_args (iprot : Protocol.t) =
  let _str707 = new describe_cluster_name_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t708,_id709) = iprot#readFieldBegin in
        if _t708 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id709 with 
          | _ -> iprot#skip _t708);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str707

class describe_cluster_name_result =
object (self)
  val mutable _success : string option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "describe_cluster_name_result.success") | Some _x710 -> _x710
  method set_success _x710 = _success <- Some _x710
  method unset_success = _success <- None
  method reset_success = _success <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_cluster_name_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRING,0);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_cluster_name_result (iprot : Protocol.t) =
  let _str713 = new describe_cluster_name_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t714,_id715) = iprot#readFieldBegin in
        if _t714 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id715 with 
          | 0 -> (if _t714 = Protocol.T_STRING then
              _str713#set_success iprot#readString
            else
              iprot#skip _t714)
          | _ -> iprot#skip _t714);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str713

class describe_version_args =
object (self)
  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_version_args";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_version_args (iprot : Protocol.t) =
  let _str718 = new describe_version_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t719,_id720) = iprot#readFieldBegin in
        if _t719 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id720 with 
          | _ -> iprot#skip _t719);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str718

class describe_version_result =
object (self)
  val mutable _success : string option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "describe_version_result.success") | Some _x721 -> _x721
  method set_success _x721 = _success <- Some _x721
  method unset_success = _success <- None
  method reset_success = _success <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_version_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRING,0);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_version_result (iprot : Protocol.t) =
  let _str724 = new describe_version_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t725,_id726) = iprot#readFieldBegin in
        if _t725 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id726 with 
          | 0 -> (if _t725 = Protocol.T_STRING then
              _str724#set_success iprot#readString
            else
              iprot#skip _t725)
          | _ -> iprot#skip _t725);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str724

class describe_ring_args =
object (self)
  val mutable _keyspace : string option = None
  method get_keyspace = _keyspace
  method grab_keyspace = match _keyspace with None->raise (Field_empty "describe_ring_args.keyspace") | Some _x727 -> _x727
  method set_keyspace _x727 = _keyspace <- Some _x727
  method unset_keyspace = _keyspace <- None
  method reset_keyspace = _keyspace <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_ring_args";
    (match _keyspace with 
    | None -> raise (Field_empty "describe_ring_args._keyspace")
    | Some _v -> 
      oprot#writeFieldBegin("keyspace",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_ring_args (iprot : Protocol.t) =
  let _str730 = new describe_ring_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t731,_id732) = iprot#readFieldBegin in
        if _t731 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id732 with 
          | 1 -> (if _t731 = Protocol.T_STRING then
              _str730#set_keyspace iprot#readString
            else
              iprot#skip _t731)
          | _ -> iprot#skip _t731);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str730

class describe_ring_result =
object (self)
  val mutable _success : tokenRange list option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "describe_ring_result.success") | Some _x733 -> _x733
  method set_success _x733 = _success <- Some _x733
  method unset_success = _success <- None
  method reset_success = _success <- None

  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "describe_ring_result.ire") | Some _x734 -> _x734
  method set_ire _x734 = _ire <- Some _x734
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  method copy =
      let _new = Oo.copy self in
      if _success <> None then
        _new#set_success (List.map (fun x -> x#copy) self#grab_success);
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_ring_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_LIST,0);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter737 ->         _iter737#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_ring_result (iprot : Protocol.t) =
  let _str738 = new describe_ring_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t739,_id740) = iprot#readFieldBegin in
        if _t739 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id740 with 
          | 0 -> (if _t739 = Protocol.T_LIST then
              _str738#set_success 
                (let (_etype744,_size741) = iprot#readListBegin in
                  let _con745 = (Array.to_list (Array.init _size741 (fun _ -> (read_tokenRange iprot)))) in
                    iprot#readListEnd; _con745)
            else
              iprot#skip _t739)
          | 1 -> (if _t739 = Protocol.T_STRUCT then
              _str738#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t739)
          | _ -> iprot#skip _t739);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str738

class describe_partitioner_args =
object (self)
  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_partitioner_args";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_partitioner_args (iprot : Protocol.t) =
  let _str748 = new describe_partitioner_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t749,_id750) = iprot#readFieldBegin in
        if _t749 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id750 with 
          | _ -> iprot#skip _t749);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str748

class describe_partitioner_result =
object (self)
  val mutable _success : string option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "describe_partitioner_result.success") | Some _x751 -> _x751
  method set_success _x751 = _success <- Some _x751
  method unset_success = _success <- None
  method reset_success = _success <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_partitioner_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRING,0);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_partitioner_result (iprot : Protocol.t) =
  let _str754 = new describe_partitioner_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t755,_id756) = iprot#readFieldBegin in
        if _t755 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id756 with 
          | 0 -> (if _t755 = Protocol.T_STRING then
              _str754#set_success iprot#readString
            else
              iprot#skip _t755)
          | _ -> iprot#skip _t755);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str754

class describe_snitch_args =
object (self)
  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_snitch_args";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_snitch_args (iprot : Protocol.t) =
  let _str759 = new describe_snitch_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t760,_id761) = iprot#readFieldBegin in
        if _t760 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id761 with 
          | _ -> iprot#skip _t760);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str759

class describe_snitch_result =
object (self)
  val mutable _success : string option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "describe_snitch_result.success") | Some _x762 -> _x762
  method set_success _x762 = _success <- Some _x762
  method unset_success = _success <- None
  method reset_success = _success <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_snitch_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRING,0);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_snitch_result (iprot : Protocol.t) =
  let _str765 = new describe_snitch_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t766,_id767) = iprot#readFieldBegin in
        if _t766 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id767 with 
          | 0 -> (if _t766 = Protocol.T_STRING then
              _str765#set_success iprot#readString
            else
              iprot#skip _t766)
          | _ -> iprot#skip _t766);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str765

class describe_keyspace_args =
object (self)
  val mutable _keyspace : string option = None
  method get_keyspace = _keyspace
  method grab_keyspace = match _keyspace with None->raise (Field_empty "describe_keyspace_args.keyspace") | Some _x768 -> _x768
  method set_keyspace _x768 = _keyspace <- Some _x768
  method unset_keyspace = _keyspace <- None
  method reset_keyspace = _keyspace <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_keyspace_args";
    (match _keyspace with 
    | None -> raise (Field_empty "describe_keyspace_args._keyspace")
    | Some _v -> 
      oprot#writeFieldBegin("keyspace",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_keyspace_args (iprot : Protocol.t) =
  let _str771 = new describe_keyspace_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t772,_id773) = iprot#readFieldBegin in
        if _t772 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id773 with 
          | 1 -> (if _t772 = Protocol.T_STRING then
              _str771#set_keyspace iprot#readString
            else
              iprot#skip _t772)
          | _ -> iprot#skip _t772);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str771

class describe_keyspace_result =
object (self)
  val mutable _success : ksDef option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "describe_keyspace_result.success") | Some _x774 -> _x774
  method set_success _x774 = _success <- Some _x774
  method unset_success = _success <- None
  method reset_success = _success <- None

  val mutable _nfe : notFoundException option = None
  method get_nfe = _nfe
  method grab_nfe = match _nfe with None->raise (Field_empty "describe_keyspace_result.nfe") | Some _x775 -> _x775
  method set_nfe _x775 = _nfe <- Some _x775
  method unset_nfe = _nfe <- None
  method reset_nfe = _nfe <- None

  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "describe_keyspace_result.ire") | Some _x776 -> _x776
  method set_ire _x776 = _ire <- Some _x776
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  method copy =
      let _new = Oo.copy self in
      if _success <> None then
        _new#set_success self#grab_success#copy;
      if _nfe <> None then
        _new#set_nfe self#grab_nfe#copy;
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_keyspace_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRUCT,0);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _nfe with None -> () | Some _v -> 
      oprot#writeFieldBegin("nfe",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_keyspace_result (iprot : Protocol.t) =
  let _str779 = new describe_keyspace_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t780,_id781) = iprot#readFieldBegin in
        if _t780 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id781 with 
          | 0 -> (if _t780 = Protocol.T_STRUCT then
              _str779#set_success (read_ksDef iprot)
            else
              iprot#skip _t780)
          | 1 -> (if _t780 = Protocol.T_STRUCT then
              _str779#set_nfe (read_notFoundException iprot)
            else
              iprot#skip _t780)
          | 2 -> (if _t780 = Protocol.T_STRUCT then
              _str779#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t780)
          | _ -> iprot#skip _t780);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str779

class describe_splits_args =
object (self)
  val mutable _cfName : string option = None
  method get_cfName = _cfName
  method grab_cfName = match _cfName with None->raise (Field_empty "describe_splits_args.cfName") | Some _x782 -> _x782
  method set_cfName _x782 = _cfName <- Some _x782
  method unset_cfName = _cfName <- None
  method reset_cfName = _cfName <- None

  val mutable _start_token : string option = None
  method get_start_token = _start_token
  method grab_start_token = match _start_token with None->raise (Field_empty "describe_splits_args.start_token") | Some _x783 -> _x783
  method set_start_token _x783 = _start_token <- Some _x783
  method unset_start_token = _start_token <- None
  method reset_start_token = _start_token <- None

  val mutable _end_token : string option = None
  method get_end_token = _end_token
  method grab_end_token = match _end_token with None->raise (Field_empty "describe_splits_args.end_token") | Some _x784 -> _x784
  method set_end_token _x784 = _end_token <- Some _x784
  method unset_end_token = _end_token <- None
  method reset_end_token = _end_token <- None

  val mutable _keys_per_split : int option = None
  method get_keys_per_split = _keys_per_split
  method grab_keys_per_split = match _keys_per_split with None->raise (Field_empty "describe_splits_args.keys_per_split") | Some _x785 -> _x785
  method set_keys_per_split _x785 = _keys_per_split <- Some _x785
  method unset_keys_per_split = _keys_per_split <- None
  method reset_keys_per_split = _keys_per_split <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_splits_args";
    (match _cfName with 
    | None -> raise (Field_empty "describe_splits_args._cfName")
    | Some _v -> 
      oprot#writeFieldBegin("cfName",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _start_token with 
    | None -> raise (Field_empty "describe_splits_args._start_token")
    | Some _v -> 
      oprot#writeFieldBegin("start_token",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _end_token with 
    | None -> raise (Field_empty "describe_splits_args._end_token")
    | Some _v -> 
      oprot#writeFieldBegin("end_token",Protocol.T_STRING,3);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _keys_per_split with 
    | None -> raise (Field_empty "describe_splits_args._keys_per_split")
    | Some _v -> 
      oprot#writeFieldBegin("keys_per_split",Protocol.T_I32,4);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_splits_args (iprot : Protocol.t) =
  let _str788 = new describe_splits_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t789,_id790) = iprot#readFieldBegin in
        if _t789 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id790 with 
          | 1 -> (if _t789 = Protocol.T_STRING then
              _str788#set_cfName iprot#readString
            else
              iprot#skip _t789)
          | 2 -> (if _t789 = Protocol.T_STRING then
              _str788#set_start_token iprot#readString
            else
              iprot#skip _t789)
          | 3 -> (if _t789 = Protocol.T_STRING then
              _str788#set_end_token iprot#readString
            else
              iprot#skip _t789)
          | 4 -> (if _t789 = Protocol.T_I32 then
              _str788#set_keys_per_split iprot#readI32
            else
              iprot#skip _t789)
          | _ -> iprot#skip _t789);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str788

class describe_splits_result =
object (self)
  val mutable _success : string list option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "describe_splits_result.success") | Some _x791 -> _x791
  method set_success _x791 = _success <- Some _x791
  method unset_success = _success <- None
  method reset_success = _success <- None

  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "describe_splits_result.ire") | Some _x792 -> _x792
  method set_ire _x792 = _ire <- Some _x792
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  method copy =
      let _new = Oo.copy self in
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_splits_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_LIST,0);
      oprot#writeListBegin(Protocol.T_STRING,List.length _v);
      List.iter (fun _iter795 ->         oprot#writeString(_iter795);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_splits_result (iprot : Protocol.t) =
  let _str796 = new describe_splits_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t797,_id798) = iprot#readFieldBegin in
        if _t797 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id798 with 
          | 0 -> (if _t797 = Protocol.T_LIST then
              _str796#set_success 
                (let (_etype802,_size799) = iprot#readListBegin in
                  let _con803 = (Array.to_list (Array.init _size799 (fun _ -> iprot#readString))) in
                    iprot#readListEnd; _con803)
            else
              iprot#skip _t797)
          | 1 -> (if _t797 = Protocol.T_STRUCT then
              _str796#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t797)
          | _ -> iprot#skip _t797);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str796

class system_add_column_family_args =
object (self)
  val mutable _cf_def : cfDef option = None
  method get_cf_def = _cf_def
  method grab_cf_def = match _cf_def with None->raise (Field_empty "system_add_column_family_args.cf_def") | Some _x804 -> _x804
  method set_cf_def _x804 = _cf_def <- Some _x804
  method unset_cf_def = _cf_def <- None
  method reset_cf_def = _cf_def <- None

  method copy =
      let _new = Oo.copy self in
      if _cf_def <> None then
        _new#set_cf_def self#grab_cf_def#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_add_column_family_args";
    (match _cf_def with 
    | None -> raise (Field_empty "system_add_column_family_args._cf_def")
    | Some _v -> 
      oprot#writeFieldBegin("cf_def",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_add_column_family_args (iprot : Protocol.t) =
  let _str807 = new system_add_column_family_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t808,_id809) = iprot#readFieldBegin in
        if _t808 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id809 with 
          | 1 -> (if _t808 = Protocol.T_STRUCT then
              _str807#set_cf_def (read_cfDef iprot)
            else
              iprot#skip _t808)
          | _ -> iprot#skip _t808);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str807

class system_add_column_family_result =
object (self)
  val mutable _success : string option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "system_add_column_family_result.success") | Some _x810 -> _x810
  method set_success _x810 = _success <- Some _x810
  method unset_success = _success <- None
  method reset_success = _success <- None

  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "system_add_column_family_result.ire") | Some _x811 -> _x811
  method set_ire _x811 = _ire <- Some _x811
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  val mutable _sde : schemaDisagreementException option = None
  method get_sde = _sde
  method grab_sde = match _sde with None->raise (Field_empty "system_add_column_family_result.sde") | Some _x812 -> _x812
  method set_sde _x812 = _sde <- Some _x812
  method unset_sde = _sde <- None
  method reset_sde = _sde <- None

  method copy =
      let _new = Oo.copy self in
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
      if _sde <> None then
        _new#set_sde self#grab_sde#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_add_column_family_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRING,0);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _sde with None -> () | Some _v -> 
      oprot#writeFieldBegin("sde",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_add_column_family_result (iprot : Protocol.t) =
  let _str815 = new system_add_column_family_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t816,_id817) = iprot#readFieldBegin in
        if _t816 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id817 with 
          | 0 -> (if _t816 = Protocol.T_STRING then
              _str815#set_success iprot#readString
            else
              iprot#skip _t816)
          | 1 -> (if _t816 = Protocol.T_STRUCT then
              _str815#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t816)
          | 2 -> (if _t816 = Protocol.T_STRUCT then
              _str815#set_sde (read_schemaDisagreementException iprot)
            else
              iprot#skip _t816)
          | _ -> iprot#skip _t816);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str815

class system_drop_column_family_args =
object (self)
  val mutable _column_family : string option = None
  method get_column_family = _column_family
  method grab_column_family = match _column_family with None->raise (Field_empty "system_drop_column_family_args.column_family") | Some _x818 -> _x818
  method set_column_family _x818 = _column_family <- Some _x818
  method unset_column_family = _column_family <- None
  method reset_column_family = _column_family <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_drop_column_family_args";
    (match _column_family with 
    | None -> raise (Field_empty "system_drop_column_family_args._column_family")
    | Some _v -> 
      oprot#writeFieldBegin("column_family",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_drop_column_family_args (iprot : Protocol.t) =
  let _str821 = new system_drop_column_family_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t822,_id823) = iprot#readFieldBegin in
        if _t822 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id823 with 
          | 1 -> (if _t822 = Protocol.T_STRING then
              _str821#set_column_family iprot#readString
            else
              iprot#skip _t822)
          | _ -> iprot#skip _t822);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str821

class system_drop_column_family_result =
object (self)
  val mutable _success : string option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "system_drop_column_family_result.success") | Some _x824 -> _x824
  method set_success _x824 = _success <- Some _x824
  method unset_success = _success <- None
  method reset_success = _success <- None

  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "system_drop_column_family_result.ire") | Some _x825 -> _x825
  method set_ire _x825 = _ire <- Some _x825
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  val mutable _sde : schemaDisagreementException option = None
  method get_sde = _sde
  method grab_sde = match _sde with None->raise (Field_empty "system_drop_column_family_result.sde") | Some _x826 -> _x826
  method set_sde _x826 = _sde <- Some _x826
  method unset_sde = _sde <- None
  method reset_sde = _sde <- None

  method copy =
      let _new = Oo.copy self in
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
      if _sde <> None then
        _new#set_sde self#grab_sde#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_drop_column_family_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRING,0);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _sde with None -> () | Some _v -> 
      oprot#writeFieldBegin("sde",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_drop_column_family_result (iprot : Protocol.t) =
  let _str829 = new system_drop_column_family_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t830,_id831) = iprot#readFieldBegin in
        if _t830 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id831 with 
          | 0 -> (if _t830 = Protocol.T_STRING then
              _str829#set_success iprot#readString
            else
              iprot#skip _t830)
          | 1 -> (if _t830 = Protocol.T_STRUCT then
              _str829#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t830)
          | 2 -> (if _t830 = Protocol.T_STRUCT then
              _str829#set_sde (read_schemaDisagreementException iprot)
            else
              iprot#skip _t830)
          | _ -> iprot#skip _t830);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str829

class system_add_keyspace_args =
object (self)
  val mutable _ks_def : ksDef option = None
  method get_ks_def = _ks_def
  method grab_ks_def = match _ks_def with None->raise (Field_empty "system_add_keyspace_args.ks_def") | Some _x832 -> _x832
  method set_ks_def _x832 = _ks_def <- Some _x832
  method unset_ks_def = _ks_def <- None
  method reset_ks_def = _ks_def <- None

  method copy =
      let _new = Oo.copy self in
      if _ks_def <> None then
        _new#set_ks_def self#grab_ks_def#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_add_keyspace_args";
    (match _ks_def with 
    | None -> raise (Field_empty "system_add_keyspace_args._ks_def")
    | Some _v -> 
      oprot#writeFieldBegin("ks_def",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_add_keyspace_args (iprot : Protocol.t) =
  let _str835 = new system_add_keyspace_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t836,_id837) = iprot#readFieldBegin in
        if _t836 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id837 with 
          | 1 -> (if _t836 = Protocol.T_STRUCT then
              _str835#set_ks_def (read_ksDef iprot)
            else
              iprot#skip _t836)
          | _ -> iprot#skip _t836);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str835

class system_add_keyspace_result =
object (self)
  val mutable _success : string option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "system_add_keyspace_result.success") | Some _x838 -> _x838
  method set_success _x838 = _success <- Some _x838
  method unset_success = _success <- None
  method reset_success = _success <- None

  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "system_add_keyspace_result.ire") | Some _x839 -> _x839
  method set_ire _x839 = _ire <- Some _x839
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  val mutable _sde : schemaDisagreementException option = None
  method get_sde = _sde
  method grab_sde = match _sde with None->raise (Field_empty "system_add_keyspace_result.sde") | Some _x840 -> _x840
  method set_sde _x840 = _sde <- Some _x840
  method unset_sde = _sde <- None
  method reset_sde = _sde <- None

  method copy =
      let _new = Oo.copy self in
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
      if _sde <> None then
        _new#set_sde self#grab_sde#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_add_keyspace_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRING,0);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _sde with None -> () | Some _v -> 
      oprot#writeFieldBegin("sde",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_add_keyspace_result (iprot : Protocol.t) =
  let _str843 = new system_add_keyspace_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t844,_id845) = iprot#readFieldBegin in
        if _t844 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id845 with 
          | 0 -> (if _t844 = Protocol.T_STRING then
              _str843#set_success iprot#readString
            else
              iprot#skip _t844)
          | 1 -> (if _t844 = Protocol.T_STRUCT then
              _str843#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t844)
          | 2 -> (if _t844 = Protocol.T_STRUCT then
              _str843#set_sde (read_schemaDisagreementException iprot)
            else
              iprot#skip _t844)
          | _ -> iprot#skip _t844);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str843

class system_drop_keyspace_args =
object (self)
  val mutable _keyspace : string option = None
  method get_keyspace = _keyspace
  method grab_keyspace = match _keyspace with None->raise (Field_empty "system_drop_keyspace_args.keyspace") | Some _x846 -> _x846
  method set_keyspace _x846 = _keyspace <- Some _x846
  method unset_keyspace = _keyspace <- None
  method reset_keyspace = _keyspace <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_drop_keyspace_args";
    (match _keyspace with 
    | None -> raise (Field_empty "system_drop_keyspace_args._keyspace")
    | Some _v -> 
      oprot#writeFieldBegin("keyspace",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_drop_keyspace_args (iprot : Protocol.t) =
  let _str849 = new system_drop_keyspace_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t850,_id851) = iprot#readFieldBegin in
        if _t850 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id851 with 
          | 1 -> (if _t850 = Protocol.T_STRING then
              _str849#set_keyspace iprot#readString
            else
              iprot#skip _t850)
          | _ -> iprot#skip _t850);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str849

class system_drop_keyspace_result =
object (self)
  val mutable _success : string option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "system_drop_keyspace_result.success") | Some _x852 -> _x852
  method set_success _x852 = _success <- Some _x852
  method unset_success = _success <- None
  method reset_success = _success <- None

  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "system_drop_keyspace_result.ire") | Some _x853 -> _x853
  method set_ire _x853 = _ire <- Some _x853
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  val mutable _sde : schemaDisagreementException option = None
  method get_sde = _sde
  method grab_sde = match _sde with None->raise (Field_empty "system_drop_keyspace_result.sde") | Some _x854 -> _x854
  method set_sde _x854 = _sde <- Some _x854
  method unset_sde = _sde <- None
  method reset_sde = _sde <- None

  method copy =
      let _new = Oo.copy self in
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
      if _sde <> None then
        _new#set_sde self#grab_sde#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_drop_keyspace_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRING,0);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _sde with None -> () | Some _v -> 
      oprot#writeFieldBegin("sde",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_drop_keyspace_result (iprot : Protocol.t) =
  let _str857 = new system_drop_keyspace_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t858,_id859) = iprot#readFieldBegin in
        if _t858 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id859 with 
          | 0 -> (if _t858 = Protocol.T_STRING then
              _str857#set_success iprot#readString
            else
              iprot#skip _t858)
          | 1 -> (if _t858 = Protocol.T_STRUCT then
              _str857#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t858)
          | 2 -> (if _t858 = Protocol.T_STRUCT then
              _str857#set_sde (read_schemaDisagreementException iprot)
            else
              iprot#skip _t858)
          | _ -> iprot#skip _t858);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str857

class system_update_keyspace_args =
object (self)
  val mutable _ks_def : ksDef option = None
  method get_ks_def = _ks_def
  method grab_ks_def = match _ks_def with None->raise (Field_empty "system_update_keyspace_args.ks_def") | Some _x860 -> _x860
  method set_ks_def _x860 = _ks_def <- Some _x860
  method unset_ks_def = _ks_def <- None
  method reset_ks_def = _ks_def <- None

  method copy =
      let _new = Oo.copy self in
      if _ks_def <> None then
        _new#set_ks_def self#grab_ks_def#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_update_keyspace_args";
    (match _ks_def with 
    | None -> raise (Field_empty "system_update_keyspace_args._ks_def")
    | Some _v -> 
      oprot#writeFieldBegin("ks_def",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_update_keyspace_args (iprot : Protocol.t) =
  let _str863 = new system_update_keyspace_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t864,_id865) = iprot#readFieldBegin in
        if _t864 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id865 with 
          | 1 -> (if _t864 = Protocol.T_STRUCT then
              _str863#set_ks_def (read_ksDef iprot)
            else
              iprot#skip _t864)
          | _ -> iprot#skip _t864);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str863

class system_update_keyspace_result =
object (self)
  val mutable _success : string option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "system_update_keyspace_result.success") | Some _x866 -> _x866
  method set_success _x866 = _success <- Some _x866
  method unset_success = _success <- None
  method reset_success = _success <- None

  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "system_update_keyspace_result.ire") | Some _x867 -> _x867
  method set_ire _x867 = _ire <- Some _x867
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  val mutable _sde : schemaDisagreementException option = None
  method get_sde = _sde
  method grab_sde = match _sde with None->raise (Field_empty "system_update_keyspace_result.sde") | Some _x868 -> _x868
  method set_sde _x868 = _sde <- Some _x868
  method unset_sde = _sde <- None
  method reset_sde = _sde <- None

  method copy =
      let _new = Oo.copy self in
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
      if _sde <> None then
        _new#set_sde self#grab_sde#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_update_keyspace_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRING,0);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _sde with None -> () | Some _v -> 
      oprot#writeFieldBegin("sde",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_update_keyspace_result (iprot : Protocol.t) =
  let _str871 = new system_update_keyspace_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t872,_id873) = iprot#readFieldBegin in
        if _t872 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id873 with 
          | 0 -> (if _t872 = Protocol.T_STRING then
              _str871#set_success iprot#readString
            else
              iprot#skip _t872)
          | 1 -> (if _t872 = Protocol.T_STRUCT then
              _str871#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t872)
          | 2 -> (if _t872 = Protocol.T_STRUCT then
              _str871#set_sde (read_schemaDisagreementException iprot)
            else
              iprot#skip _t872)
          | _ -> iprot#skip _t872);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str871

class system_update_column_family_args =
object (self)
  val mutable _cf_def : cfDef option = None
  method get_cf_def = _cf_def
  method grab_cf_def = match _cf_def with None->raise (Field_empty "system_update_column_family_args.cf_def") | Some _x874 -> _x874
  method set_cf_def _x874 = _cf_def <- Some _x874
  method unset_cf_def = _cf_def <- None
  method reset_cf_def = _cf_def <- None

  method copy =
      let _new = Oo.copy self in
      if _cf_def <> None then
        _new#set_cf_def self#grab_cf_def#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_update_column_family_args";
    (match _cf_def with 
    | None -> raise (Field_empty "system_update_column_family_args._cf_def")
    | Some _v -> 
      oprot#writeFieldBegin("cf_def",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_update_column_family_args (iprot : Protocol.t) =
  let _str877 = new system_update_column_family_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t878,_id879) = iprot#readFieldBegin in
        if _t878 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id879 with 
          | 1 -> (if _t878 = Protocol.T_STRUCT then
              _str877#set_cf_def (read_cfDef iprot)
            else
              iprot#skip _t878)
          | _ -> iprot#skip _t878);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str877

class system_update_column_family_result =
object (self)
  val mutable _success : string option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "system_update_column_family_result.success") | Some _x880 -> _x880
  method set_success _x880 = _success <- Some _x880
  method unset_success = _success <- None
  method reset_success = _success <- None

  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "system_update_column_family_result.ire") | Some _x881 -> _x881
  method set_ire _x881 = _ire <- Some _x881
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  val mutable _sde : schemaDisagreementException option = None
  method get_sde = _sde
  method grab_sde = match _sde with None->raise (Field_empty "system_update_column_family_result.sde") | Some _x882 -> _x882
  method set_sde _x882 = _sde <- Some _x882
  method unset_sde = _sde <- None
  method reset_sde = _sde <- None

  method copy =
      let _new = Oo.copy self in
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
      if _sde <> None then
        _new#set_sde self#grab_sde#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_update_column_family_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRING,0);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _sde with None -> () | Some _v -> 
      oprot#writeFieldBegin("sde",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_update_column_family_result (iprot : Protocol.t) =
  let _str885 = new system_update_column_family_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t886,_id887) = iprot#readFieldBegin in
        if _t886 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id887 with 
          | 0 -> (if _t886 = Protocol.T_STRING then
              _str885#set_success iprot#readString
            else
              iprot#skip _t886)
          | 1 -> (if _t886 = Protocol.T_STRUCT then
              _str885#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t886)
          | 2 -> (if _t886 = Protocol.T_STRUCT then
              _str885#set_sde (read_schemaDisagreementException iprot)
            else
              iprot#skip _t886)
          | _ -> iprot#skip _t886);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str885

class execute_cql_query_args =
object (self)
  val mutable _query : string option = None
  method get_query = _query
  method grab_query = match _query with None->raise (Field_empty "execute_cql_query_args.query") | Some _x888 -> _x888
  method set_query _x888 = _query <- Some _x888
  method unset_query = _query <- None
  method reset_query = _query <- None

  val mutable _compression : Compression.t option = None
  method get_compression = _compression
  method grab_compression = match _compression with None->raise (Field_empty "execute_cql_query_args.compression") | Some _x889 -> _x889
  method set_compression _x889 = _compression <- Some _x889
  method unset_compression = _compression <- None
  method reset_compression = _compression <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "execute_cql_query_args";
    (match _query with 
    | None -> raise (Field_empty "execute_cql_query_args._query")
    | Some _v -> 
      oprot#writeFieldBegin("query",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _compression with 
    | None -> raise (Field_empty "execute_cql_query_args._compression")
    | Some _v -> 
      oprot#writeFieldBegin("compression",Protocol.T_I32,2);
      oprot#writeI32(Compression.to_i _v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_execute_cql_query_args (iprot : Protocol.t) =
  let _str892 = new execute_cql_query_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t893,_id894) = iprot#readFieldBegin in
        if _t893 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id894 with 
          | 1 -> (if _t893 = Protocol.T_STRING then
              _str892#set_query iprot#readString
            else
              iprot#skip _t893)
          | 2 -> (if _t893 = Protocol.T_I32 then
              _str892#set_compression (Compression.of_i iprot#readI32)
            else
              iprot#skip _t893)
          | _ -> iprot#skip _t893);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str892

class execute_cql_query_result =
object (self)
  val mutable _success : cqlResult option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "execute_cql_query_result.success") | Some _x895 -> _x895
  method set_success _x895 = _success <- Some _x895
  method unset_success = _success <- None
  method reset_success = _success <- None

  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "execute_cql_query_result.ire") | Some _x896 -> _x896
  method set_ire _x896 = _ire <- Some _x896
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "execute_cql_query_result.ue") | Some _x897 -> _x897
  method set_ue _x897 = _ue <- Some _x897
  method unset_ue = _ue <- None
  method reset_ue = _ue <- None

  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "execute_cql_query_result.te") | Some _x898 -> _x898
  method set_te _x898 = _te <- Some _x898
  method unset_te = _te <- None
  method reset_te = _te <- None

  val mutable _sde : schemaDisagreementException option = None
  method get_sde = _sde
  method grab_sde = match _sde with None->raise (Field_empty "execute_cql_query_result.sde") | Some _x899 -> _x899
  method set_sde _x899 = _sde <- Some _x899
  method unset_sde = _sde <- None
  method reset_sde = _sde <- None

  method copy =
      let _new = Oo.copy self in
      if _success <> None then
        _new#set_success self#grab_success#copy;
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
      if _ue <> None then
        _new#set_ue self#grab_ue#copy;
      if _te <> None then
        _new#set_te self#grab_te#copy;
      if _sde <> None then
        _new#set_sde self#grab_sde#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "execute_cql_query_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRUCT,0);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _sde with None -> () | Some _v -> 
      oprot#writeFieldBegin("sde",Protocol.T_STRUCT,4);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_execute_cql_query_result (iprot : Protocol.t) =
  let _str902 = new execute_cql_query_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t903,_id904) = iprot#readFieldBegin in
        if _t903 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id904 with 
          | 0 -> (if _t903 = Protocol.T_STRUCT then
              _str902#set_success (read_cqlResult iprot)
            else
              iprot#skip _t903)
          | 1 -> (if _t903 = Protocol.T_STRUCT then
              _str902#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t903)
          | 2 -> (if _t903 = Protocol.T_STRUCT then
              _str902#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t903)
          | 3 -> (if _t903 = Protocol.T_STRUCT then
              _str902#set_te (read_timedOutException iprot)
            else
              iprot#skip _t903)
          | 4 -> (if _t903 = Protocol.T_STRUCT then
              _str902#set_sde (read_schemaDisagreementException iprot)
            else
              iprot#skip _t903)
          | _ -> iprot#skip _t903);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str902

class virtual iface =
object (self)
  method virtual login : authenticationRequest option -> unit
  method virtual set_keyspace : string option -> unit
  method virtual get : string option -> columnPath option -> ConsistencyLevel.t option -> columnOrSuperColumn
  method virtual get_slice : string option -> columnParent option -> slicePredicate option -> ConsistencyLevel.t option -> columnOrSuperColumn list
  method virtual get_count : string option -> columnParent option -> slicePredicate option -> ConsistencyLevel.t option -> int
  method virtual multiget_slice : string list option -> columnParent option -> slicePredicate option -> ConsistencyLevel.t option -> (string,columnOrSuperColumn list) Hashtbl.t
  method virtual multiget_count : string list option -> columnParent option -> slicePredicate option -> ConsistencyLevel.t option -> (string,int) Hashtbl.t
  method virtual get_range_slices : columnParent option -> slicePredicate option -> keyRange option -> ConsistencyLevel.t option -> keySlice list
  method virtual get_indexed_slices : columnParent option -> indexClause option -> slicePredicate option -> ConsistencyLevel.t option -> keySlice list
  method virtual insert : string option -> columnParent option -> column option -> ConsistencyLevel.t option -> unit
  method virtual add : string option -> columnParent option -> counterColumn option -> ConsistencyLevel.t option -> unit
  method virtual remove : string option -> columnPath option -> Int64.t option -> ConsistencyLevel.t option -> unit
  method virtual remove_counter : string option -> columnPath option -> ConsistencyLevel.t option -> unit
  method virtual batch_mutate : (string,(string,mutation list) Hashtbl.t) Hashtbl.t option -> ConsistencyLevel.t option -> unit
  method virtual truncate : string option -> unit
  method virtual describe_schema_versions : (string,string list) Hashtbl.t
  method virtual describe_keyspaces : ksDef list
  method virtual describe_cluster_name : string
  method virtual describe_version : string
  method virtual describe_ring : string option -> tokenRange list
  method virtual describe_partitioner : string
  method virtual describe_snitch : string
  method virtual describe_keyspace : string option -> ksDef
  method virtual describe_splits : string option -> string option -> string option -> int option -> string list
  method virtual system_add_column_family : cfDef option -> string
  method virtual system_drop_column_family : string option -> string
  method virtual system_add_keyspace : ksDef option -> string
  method virtual system_drop_keyspace : string option -> string
  method virtual system_update_keyspace : ksDef option -> string
  method virtual system_update_column_family : cfDef option -> string
  method virtual execute_cql_query : string option -> Compression.t option -> cqlResult
end

class client (iprot : Protocol.t) (oprot : Protocol.t) =
object (self)
  val mutable seqid = 0
  method login auth_request = 
    self#send_login auth_request;
    self#recv_login
  method private send_login auth_request = 
    oprot#writeMessageBegin ("login", Protocol.CALL, seqid);
    let args = new login_args in
      args#set_auth_request auth_request;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_login  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_login_result iprot in
        iprot#readMessageEnd;
        (match result#get_authnx with None -> () | Some _v ->
          raise (AuthenticationException _v));
        (match result#get_authzx with None -> () | Some _v ->
          raise (AuthorizationException _v));
        ()
  method set_keyspace keyspace = 
    self#send_set_keyspace keyspace;
    self#recv_set_keyspace
  method private send_set_keyspace keyspace = 
    oprot#writeMessageBegin ("set_keyspace", Protocol.CALL, seqid);
    let args = new set_keyspace_args in
      args#set_keyspace keyspace;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_set_keyspace  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_set_keyspace_result iprot in
        iprot#readMessageEnd;
        (match result#get_ire with None -> () | Some _v ->
          raise (InvalidRequestException _v));
        ()
  method get key column_path consistency_level = 
    self#send_get key column_path consistency_level;
    self#recv_get
  method private send_get key column_path consistency_level = 
    oprot#writeMessageBegin ("get", Protocol.CALL, seqid);
    let args = new get_args in
      args#set_key key;
      args#set_column_path column_path;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_get  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_get_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_nfe with None -> () | Some _v ->
            raise (NotFoundException _v));
          (match result#get_ue with None -> () | Some _v ->
            raise (UnavailableException _v));
          (match result#get_te with None -> () | Some _v ->
            raise (TimedOutException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "get failed: unknown result")))
  method get_slice key column_parent predicate consistency_level = 
    self#send_get_slice key column_parent predicate consistency_level;
    self#recv_get_slice
  method private send_get_slice key column_parent predicate consistency_level = 
    oprot#writeMessageBegin ("get_slice", Protocol.CALL, seqid);
    let args = new get_slice_args in
      args#set_key key;
      args#set_column_parent column_parent;
      args#set_predicate predicate;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_get_slice  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_get_slice_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_ue with None -> () | Some _v ->
            raise (UnavailableException _v));
          (match result#get_te with None -> () | Some _v ->
            raise (TimedOutException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "get_slice failed: unknown result")))
  method get_count key column_parent predicate consistency_level = 
    self#send_get_count key column_parent predicate consistency_level;
    self#recv_get_count
  method private send_get_count key column_parent predicate consistency_level = 
    oprot#writeMessageBegin ("get_count", Protocol.CALL, seqid);
    let args = new get_count_args in
      args#set_key key;
      args#set_column_parent column_parent;
      args#set_predicate predicate;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_get_count  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_get_count_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_ue with None -> () | Some _v ->
            raise (UnavailableException _v));
          (match result#get_te with None -> () | Some _v ->
            raise (TimedOutException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "get_count failed: unknown result")))
  method multiget_slice keys column_parent predicate consistency_level = 
    self#send_multiget_slice keys column_parent predicate consistency_level;
    self#recv_multiget_slice
  method private send_multiget_slice keys column_parent predicate consistency_level = 
    oprot#writeMessageBegin ("multiget_slice", Protocol.CALL, seqid);
    let args = new multiget_slice_args in
      args#set_keys keys;
      args#set_column_parent column_parent;
      args#set_predicate predicate;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_multiget_slice  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_multiget_slice_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_ue with None -> () | Some _v ->
            raise (UnavailableException _v));
          (match result#get_te with None -> () | Some _v ->
            raise (TimedOutException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "multiget_slice failed: unknown result")))
  method multiget_count keys column_parent predicate consistency_level = 
    self#send_multiget_count keys column_parent predicate consistency_level;
    self#recv_multiget_count
  method private send_multiget_count keys column_parent predicate consistency_level = 
    oprot#writeMessageBegin ("multiget_count", Protocol.CALL, seqid);
    let args = new multiget_count_args in
      args#set_keys keys;
      args#set_column_parent column_parent;
      args#set_predicate predicate;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_multiget_count  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_multiget_count_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_ue with None -> () | Some _v ->
            raise (UnavailableException _v));
          (match result#get_te with None -> () | Some _v ->
            raise (TimedOutException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "multiget_count failed: unknown result")))
  method get_range_slices column_parent predicate range consistency_level = 
    self#send_get_range_slices column_parent predicate range consistency_level;
    self#recv_get_range_slices
  method private send_get_range_slices column_parent predicate range consistency_level = 
    oprot#writeMessageBegin ("get_range_slices", Protocol.CALL, seqid);
    let args = new get_range_slices_args in
      args#set_column_parent column_parent;
      args#set_predicate predicate;
      args#set_range range;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_get_range_slices  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_get_range_slices_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_ue with None -> () | Some _v ->
            raise (UnavailableException _v));
          (match result#get_te with None -> () | Some _v ->
            raise (TimedOutException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "get_range_slices failed: unknown result")))
  method get_indexed_slices column_parent index_clause column_predicate consistency_level = 
    self#send_get_indexed_slices column_parent index_clause column_predicate consistency_level;
    self#recv_get_indexed_slices
  method private send_get_indexed_slices column_parent index_clause column_predicate consistency_level = 
    oprot#writeMessageBegin ("get_indexed_slices", Protocol.CALL, seqid);
    let args = new get_indexed_slices_args in
      args#set_column_parent column_parent;
      args#set_index_clause index_clause;
      args#set_column_predicate column_predicate;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_get_indexed_slices  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_get_indexed_slices_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_ue with None -> () | Some _v ->
            raise (UnavailableException _v));
          (match result#get_te with None -> () | Some _v ->
            raise (TimedOutException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "get_indexed_slices failed: unknown result")))
  method insert key column_parent column consistency_level = 
    self#send_insert key column_parent column consistency_level;
    self#recv_insert
  method private send_insert key column_parent column consistency_level = 
    oprot#writeMessageBegin ("insert", Protocol.CALL, seqid);
    let args = new insert_args in
      args#set_key key;
      args#set_column_parent column_parent;
      args#set_column column;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_insert  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_insert_result iprot in
        iprot#readMessageEnd;
        (match result#get_ire with None -> () | Some _v ->
          raise (InvalidRequestException _v));
        (match result#get_ue with None -> () | Some _v ->
          raise (UnavailableException _v));
        (match result#get_te with None -> () | Some _v ->
          raise (TimedOutException _v));
        ()
  method add key column_parent column consistency_level = 
    self#send_add key column_parent column consistency_level;
    self#recv_add
  method private send_add key column_parent column consistency_level = 
    oprot#writeMessageBegin ("add", Protocol.CALL, seqid);
    let args = new add_args in
      args#set_key key;
      args#set_column_parent column_parent;
      args#set_column column;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_add  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_add_result iprot in
        iprot#readMessageEnd;
        (match result#get_ire with None -> () | Some _v ->
          raise (InvalidRequestException _v));
        (match result#get_ue with None -> () | Some _v ->
          raise (UnavailableException _v));
        (match result#get_te with None -> () | Some _v ->
          raise (TimedOutException _v));
        ()
  method remove key column_path timestamp consistency_level = 
    self#send_remove key column_path timestamp consistency_level;
    self#recv_remove
  method private send_remove key column_path timestamp consistency_level = 
    oprot#writeMessageBegin ("remove", Protocol.CALL, seqid);
    let args = new remove_args in
      args#set_key key;
      args#set_column_path column_path;
      args#set_timestamp timestamp;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_remove  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_remove_result iprot in
        iprot#readMessageEnd;
        (match result#get_ire with None -> () | Some _v ->
          raise (InvalidRequestException _v));
        (match result#get_ue with None -> () | Some _v ->
          raise (UnavailableException _v));
        (match result#get_te with None -> () | Some _v ->
          raise (TimedOutException _v));
        ()
  method remove_counter key path consistency_level = 
    self#send_remove_counter key path consistency_level;
    self#recv_remove_counter
  method private send_remove_counter key path consistency_level = 
    oprot#writeMessageBegin ("remove_counter", Protocol.CALL, seqid);
    let args = new remove_counter_args in
      args#set_key key;
      args#set_path path;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_remove_counter  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_remove_counter_result iprot in
        iprot#readMessageEnd;
        (match result#get_ire with None -> () | Some _v ->
          raise (InvalidRequestException _v));
        (match result#get_ue with None -> () | Some _v ->
          raise (UnavailableException _v));
        (match result#get_te with None -> () | Some _v ->
          raise (TimedOutException _v));
        ()
  method batch_mutate mutation_map consistency_level = 
    self#send_batch_mutate mutation_map consistency_level;
    self#recv_batch_mutate
  method private send_batch_mutate mutation_map consistency_level = 
    oprot#writeMessageBegin ("batch_mutate", Protocol.CALL, seqid);
    let args = new batch_mutate_args in
      args#set_mutation_map mutation_map;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_batch_mutate  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_batch_mutate_result iprot in
        iprot#readMessageEnd;
        (match result#get_ire with None -> () | Some _v ->
          raise (InvalidRequestException _v));
        (match result#get_ue with None -> () | Some _v ->
          raise (UnavailableException _v));
        (match result#get_te with None -> () | Some _v ->
          raise (TimedOutException _v));
        ()
  method truncate cfname = 
    self#send_truncate cfname;
    self#recv_truncate
  method private send_truncate cfname = 
    oprot#writeMessageBegin ("truncate", Protocol.CALL, seqid);
    let args = new truncate_args in
      args#set_cfname cfname;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_truncate  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_truncate_result iprot in
        iprot#readMessageEnd;
        (match result#get_ire with None -> () | Some _v ->
          raise (InvalidRequestException _v));
        (match result#get_ue with None -> () | Some _v ->
          raise (UnavailableException _v));
        ()
  method describe_schema_versions  = 
    self#send_describe_schema_versions;
    self#recv_describe_schema_versions
  method private send_describe_schema_versions  = 
    oprot#writeMessageBegin ("describe_schema_versions", Protocol.CALL, seqid);
    let args = new describe_schema_versions_args in
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_describe_schema_versions  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_describe_schema_versions_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "describe_schema_versions failed: unknown result")))
  method describe_keyspaces  = 
    self#send_describe_keyspaces;
    self#recv_describe_keyspaces
  method private send_describe_keyspaces  = 
    oprot#writeMessageBegin ("describe_keyspaces", Protocol.CALL, seqid);
    let args = new describe_keyspaces_args in
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_describe_keyspaces  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_describe_keyspaces_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "describe_keyspaces failed: unknown result")))
  method describe_cluster_name  = 
    self#send_describe_cluster_name;
    self#recv_describe_cluster_name
  method private send_describe_cluster_name  = 
    oprot#writeMessageBegin ("describe_cluster_name", Protocol.CALL, seqid);
    let args = new describe_cluster_name_args in
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_describe_cluster_name  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_describe_cluster_name_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "describe_cluster_name failed: unknown result")))
  method describe_version  = 
    self#send_describe_version;
    self#recv_describe_version
  method private send_describe_version  = 
    oprot#writeMessageBegin ("describe_version", Protocol.CALL, seqid);
    let args = new describe_version_args in
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_describe_version  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_describe_version_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "describe_version failed: unknown result")))
  method describe_ring keyspace = 
    self#send_describe_ring keyspace;
    self#recv_describe_ring
  method private send_describe_ring keyspace = 
    oprot#writeMessageBegin ("describe_ring", Protocol.CALL, seqid);
    let args = new describe_ring_args in
      args#set_keyspace keyspace;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_describe_ring  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_describe_ring_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "describe_ring failed: unknown result")))
  method describe_partitioner  = 
    self#send_describe_partitioner;
    self#recv_describe_partitioner
  method private send_describe_partitioner  = 
    oprot#writeMessageBegin ("describe_partitioner", Protocol.CALL, seqid);
    let args = new describe_partitioner_args in
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_describe_partitioner  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_describe_partitioner_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "describe_partitioner failed: unknown result")))
  method describe_snitch  = 
    self#send_describe_snitch;
    self#recv_describe_snitch
  method private send_describe_snitch  = 
    oprot#writeMessageBegin ("describe_snitch", Protocol.CALL, seqid);
    let args = new describe_snitch_args in
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_describe_snitch  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_describe_snitch_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "describe_snitch failed: unknown result")))
  method describe_keyspace keyspace = 
    self#send_describe_keyspace keyspace;
    self#recv_describe_keyspace
  method private send_describe_keyspace keyspace = 
    oprot#writeMessageBegin ("describe_keyspace", Protocol.CALL, seqid);
    let args = new describe_keyspace_args in
      args#set_keyspace keyspace;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_describe_keyspace  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_describe_keyspace_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_nfe with None -> () | Some _v ->
            raise (NotFoundException _v));
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "describe_keyspace failed: unknown result")))
  method describe_splits cfName start_token end_token keys_per_split = 
    self#send_describe_splits cfName start_token end_token keys_per_split;
    self#recv_describe_splits
  method private send_describe_splits cfName start_token end_token keys_per_split = 
    oprot#writeMessageBegin ("describe_splits", Protocol.CALL, seqid);
    let args = new describe_splits_args in
      args#set_cfName cfName;
      args#set_start_token start_token;
      args#set_end_token end_token;
      args#set_keys_per_split keys_per_split;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_describe_splits  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_describe_splits_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "describe_splits failed: unknown result")))
  method system_add_column_family cf_def = 
    self#send_system_add_column_family cf_def;
    self#recv_system_add_column_family
  method private send_system_add_column_family cf_def = 
    oprot#writeMessageBegin ("system_add_column_family", Protocol.CALL, seqid);
    let args = new system_add_column_family_args in
      args#set_cf_def cf_def;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_system_add_column_family  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_system_add_column_family_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_sde with None -> () | Some _v ->
            raise (SchemaDisagreementException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "system_add_column_family failed: unknown result")))
  method system_drop_column_family column_family = 
    self#send_system_drop_column_family column_family;
    self#recv_system_drop_column_family
  method private send_system_drop_column_family column_family = 
    oprot#writeMessageBegin ("system_drop_column_family", Protocol.CALL, seqid);
    let args = new system_drop_column_family_args in
      args#set_column_family column_family;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_system_drop_column_family  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_system_drop_column_family_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_sde with None -> () | Some _v ->
            raise (SchemaDisagreementException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "system_drop_column_family failed: unknown result")))
  method system_add_keyspace ks_def = 
    self#send_system_add_keyspace ks_def;
    self#recv_system_add_keyspace
  method private send_system_add_keyspace ks_def = 
    oprot#writeMessageBegin ("system_add_keyspace", Protocol.CALL, seqid);
    let args = new system_add_keyspace_args in
      args#set_ks_def ks_def;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_system_add_keyspace  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_system_add_keyspace_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_sde with None -> () | Some _v ->
            raise (SchemaDisagreementException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "system_add_keyspace failed: unknown result")))
  method system_drop_keyspace keyspace = 
    self#send_system_drop_keyspace keyspace;
    self#recv_system_drop_keyspace
  method private send_system_drop_keyspace keyspace = 
    oprot#writeMessageBegin ("system_drop_keyspace", Protocol.CALL, seqid);
    let args = new system_drop_keyspace_args in
      args#set_keyspace keyspace;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_system_drop_keyspace  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_system_drop_keyspace_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_sde with None -> () | Some _v ->
            raise (SchemaDisagreementException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "system_drop_keyspace failed: unknown result")))
  method system_update_keyspace ks_def = 
    self#send_system_update_keyspace ks_def;
    self#recv_system_update_keyspace
  method private send_system_update_keyspace ks_def = 
    oprot#writeMessageBegin ("system_update_keyspace", Protocol.CALL, seqid);
    let args = new system_update_keyspace_args in
      args#set_ks_def ks_def;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_system_update_keyspace  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_system_update_keyspace_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_sde with None -> () | Some _v ->
            raise (SchemaDisagreementException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "system_update_keyspace failed: unknown result")))
  method system_update_column_family cf_def = 
    self#send_system_update_column_family cf_def;
    self#recv_system_update_column_family
  method private send_system_update_column_family cf_def = 
    oprot#writeMessageBegin ("system_update_column_family", Protocol.CALL, seqid);
    let args = new system_update_column_family_args in
      args#set_cf_def cf_def;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_system_update_column_family  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_system_update_column_family_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_sde with None -> () | Some _v ->
            raise (SchemaDisagreementException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "system_update_column_family failed: unknown result")))
  method execute_cql_query query compression = 
    self#send_execute_cql_query query compression;
    self#recv_execute_cql_query
  method private send_execute_cql_query query compression = 
    oprot#writeMessageBegin ("execute_cql_query", Protocol.CALL, seqid);
    let args = new execute_cql_query_args in
      args#set_query query;
      args#set_compression compression;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_execute_cql_query  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_execute_cql_query_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_ue with None -> () | Some _v ->
            raise (UnavailableException _v));
          (match result#get_te with None -> () | Some _v ->
            raise (TimedOutException _v));
          (match result#get_sde with None -> () | Some _v ->
            raise (SchemaDisagreementException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "execute_cql_query failed: unknown result")))
end

class processor (handler : iface) =
object (self)
  inherit Processor.t

  val processMap = Hashtbl.create 31
  method process iprot oprot =
    let (name, typ, seqid)  = iprot#readMessageBegin in
      if Hashtbl.mem processMap name then
        (Hashtbl.find processMap name) (seqid, iprot, oprot)
      else (
        iprot#skip(Protocol.T_STRUCT);
        iprot#readMessageEnd;
        let x = Application_Exn.create Application_Exn.UNKNOWN_METHOD ("Unknown function "^name) in
          oprot#writeMessageBegin(name, Protocol.EXCEPTION, seqid);
          x#write oprot;
          oprot#writeMessageEnd;
          oprot#getTransport#flush
      );
      true
  method private process_login (seqid, iprot, oprot) =
    let args = read_login_args iprot in
      iprot#readMessageEnd;
      let result = new login_result in
        (try
          (handler#login args#get_auth_request);
        with
          | AuthenticationException authnx -> 
              result#set_authnx authnx
          | AuthorizationException authzx -> 
              result#set_authzx authzx
        );
        oprot#writeMessageBegin ("login", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_set_keyspace (seqid, iprot, oprot) =
    let args = read_set_keyspace_args iprot in
      iprot#readMessageEnd;
      let result = new set_keyspace_result in
        (try
          (handler#set_keyspace args#get_keyspace);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
        );
        oprot#writeMessageBegin ("set_keyspace", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_get (seqid, iprot, oprot) =
    let args = read_get_args iprot in
      iprot#readMessageEnd;
      let result = new get_result in
        (try
          result#set_success (handler#get args#get_key args#get_column_path args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | NotFoundException nfe -> 
              result#set_nfe nfe
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("get", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_get_slice (seqid, iprot, oprot) =
    let args = read_get_slice_args iprot in
      iprot#readMessageEnd;
      let result = new get_slice_result in
        (try
          result#set_success (handler#get_slice args#get_key args#get_column_parent args#get_predicate args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("get_slice", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_get_count (seqid, iprot, oprot) =
    let args = read_get_count_args iprot in
      iprot#readMessageEnd;
      let result = new get_count_result in
        (try
          result#set_success (handler#get_count args#get_key args#get_column_parent args#get_predicate args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("get_count", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_multiget_slice (seqid, iprot, oprot) =
    let args = read_multiget_slice_args iprot in
      iprot#readMessageEnd;
      let result = new multiget_slice_result in
        (try
          result#set_success (handler#multiget_slice args#get_keys args#get_column_parent args#get_predicate args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("multiget_slice", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_multiget_count (seqid, iprot, oprot) =
    let args = read_multiget_count_args iprot in
      iprot#readMessageEnd;
      let result = new multiget_count_result in
        (try
          result#set_success (handler#multiget_count args#get_keys args#get_column_parent args#get_predicate args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("multiget_count", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_get_range_slices (seqid, iprot, oprot) =
    let args = read_get_range_slices_args iprot in
      iprot#readMessageEnd;
      let result = new get_range_slices_result in
        (try
          result#set_success (handler#get_range_slices args#get_column_parent args#get_predicate args#get_range args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("get_range_slices", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_get_indexed_slices (seqid, iprot, oprot) =
    let args = read_get_indexed_slices_args iprot in
      iprot#readMessageEnd;
      let result = new get_indexed_slices_result in
        (try
          result#set_success (handler#get_indexed_slices args#get_column_parent args#get_index_clause args#get_column_predicate args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("get_indexed_slices", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_insert (seqid, iprot, oprot) =
    let args = read_insert_args iprot in
      iprot#readMessageEnd;
      let result = new insert_result in
        (try
          (handler#insert args#get_key args#get_column_parent args#get_column args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("insert", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_add (seqid, iprot, oprot) =
    let args = read_add_args iprot in
      iprot#readMessageEnd;
      let result = new add_result in
        (try
          (handler#add args#get_key args#get_column_parent args#get_column args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("add", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_remove (seqid, iprot, oprot) =
    let args = read_remove_args iprot in
      iprot#readMessageEnd;
      let result = new remove_result in
        (try
          (handler#remove args#get_key args#get_column_path args#get_timestamp args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("remove", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_remove_counter (seqid, iprot, oprot) =
    let args = read_remove_counter_args iprot in
      iprot#readMessageEnd;
      let result = new remove_counter_result in
        (try
          (handler#remove_counter args#get_key args#get_path args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("remove_counter", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_batch_mutate (seqid, iprot, oprot) =
    let args = read_batch_mutate_args iprot in
      iprot#readMessageEnd;
      let result = new batch_mutate_result in
        (try
          (handler#batch_mutate args#get_mutation_map args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("batch_mutate", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_truncate (seqid, iprot, oprot) =
    let args = read_truncate_args iprot in
      iprot#readMessageEnd;
      let result = new truncate_result in
        (try
          (handler#truncate args#get_cfname);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
        );
        oprot#writeMessageBegin ("truncate", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_describe_schema_versions (seqid, iprot, oprot) =
    let _ = read_describe_schema_versions_args iprot in
      iprot#readMessageEnd;
      let result = new describe_schema_versions_result in
        (try
          result#set_success (handler#describe_schema_versions);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
        );
        oprot#writeMessageBegin ("describe_schema_versions", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_describe_keyspaces (seqid, iprot, oprot) =
    let _ = read_describe_keyspaces_args iprot in
      iprot#readMessageEnd;
      let result = new describe_keyspaces_result in
        (try
          result#set_success (handler#describe_keyspaces);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
        );
        oprot#writeMessageBegin ("describe_keyspaces", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_describe_cluster_name (seqid, iprot, oprot) =
    let _ = read_describe_cluster_name_args iprot in
      iprot#readMessageEnd;
      let result = new describe_cluster_name_result in
        result#set_success (handler#describe_cluster_name);
        oprot#writeMessageBegin ("describe_cluster_name", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_describe_version (seqid, iprot, oprot) =
    let _ = read_describe_version_args iprot in
      iprot#readMessageEnd;
      let result = new describe_version_result in
        result#set_success (handler#describe_version);
        oprot#writeMessageBegin ("describe_version", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_describe_ring (seqid, iprot, oprot) =
    let args = read_describe_ring_args iprot in
      iprot#readMessageEnd;
      let result = new describe_ring_result in
        (try
          result#set_success (handler#describe_ring args#get_keyspace);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
        );
        oprot#writeMessageBegin ("describe_ring", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_describe_partitioner (seqid, iprot, oprot) =
    let _ = read_describe_partitioner_args iprot in
      iprot#readMessageEnd;
      let result = new describe_partitioner_result in
        result#set_success (handler#describe_partitioner);
        oprot#writeMessageBegin ("describe_partitioner", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_describe_snitch (seqid, iprot, oprot) =
    let _ = read_describe_snitch_args iprot in
      iprot#readMessageEnd;
      let result = new describe_snitch_result in
        result#set_success (handler#describe_snitch);
        oprot#writeMessageBegin ("describe_snitch", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_describe_keyspace (seqid, iprot, oprot) =
    let args = read_describe_keyspace_args iprot in
      iprot#readMessageEnd;
      let result = new describe_keyspace_result in
        (try
          result#set_success (handler#describe_keyspace args#get_keyspace);
        with
          | NotFoundException nfe -> 
              result#set_nfe nfe
          | InvalidRequestException ire -> 
              result#set_ire ire
        );
        oprot#writeMessageBegin ("describe_keyspace", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_describe_splits (seqid, iprot, oprot) =
    let args = read_describe_splits_args iprot in
      iprot#readMessageEnd;
      let result = new describe_splits_result in
        (try
          result#set_success (handler#describe_splits args#get_cfName args#get_start_token args#get_end_token args#get_keys_per_split);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
        );
        oprot#writeMessageBegin ("describe_splits", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_system_add_column_family (seqid, iprot, oprot) =
    let args = read_system_add_column_family_args iprot in
      iprot#readMessageEnd;
      let result = new system_add_column_family_result in
        (try
          result#set_success (handler#system_add_column_family args#get_cf_def);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | SchemaDisagreementException sde -> 
              result#set_sde sde
        );
        oprot#writeMessageBegin ("system_add_column_family", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_system_drop_column_family (seqid, iprot, oprot) =
    let args = read_system_drop_column_family_args iprot in
      iprot#readMessageEnd;
      let result = new system_drop_column_family_result in
        (try
          result#set_success (handler#system_drop_column_family args#get_column_family);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | SchemaDisagreementException sde -> 
              result#set_sde sde
        );
        oprot#writeMessageBegin ("system_drop_column_family", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_system_add_keyspace (seqid, iprot, oprot) =
    let args = read_system_add_keyspace_args iprot in
      iprot#readMessageEnd;
      let result = new system_add_keyspace_result in
        (try
          result#set_success (handler#system_add_keyspace args#get_ks_def);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | SchemaDisagreementException sde -> 
              result#set_sde sde
        );
        oprot#writeMessageBegin ("system_add_keyspace", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_system_drop_keyspace (seqid, iprot, oprot) =
    let args = read_system_drop_keyspace_args iprot in
      iprot#readMessageEnd;
      let result = new system_drop_keyspace_result in
        (try
          result#set_success (handler#system_drop_keyspace args#get_keyspace);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | SchemaDisagreementException sde -> 
              result#set_sde sde
        );
        oprot#writeMessageBegin ("system_drop_keyspace", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_system_update_keyspace (seqid, iprot, oprot) =
    let args = read_system_update_keyspace_args iprot in
      iprot#readMessageEnd;
      let result = new system_update_keyspace_result in
        (try
          result#set_success (handler#system_update_keyspace args#get_ks_def);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | SchemaDisagreementException sde -> 
              result#set_sde sde
        );
        oprot#writeMessageBegin ("system_update_keyspace", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_system_update_column_family (seqid, iprot, oprot) =
    let args = read_system_update_column_family_args iprot in
      iprot#readMessageEnd;
      let result = new system_update_column_family_result in
        (try
          result#set_success (handler#system_update_column_family args#get_cf_def);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | SchemaDisagreementException sde -> 
              result#set_sde sde
        );
        oprot#writeMessageBegin ("system_update_column_family", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_execute_cql_query (seqid, iprot, oprot) =
    let args = read_execute_cql_query_args iprot in
      iprot#readMessageEnd;
      let result = new execute_cql_query_result in
        (try
          result#set_success (handler#execute_cql_query args#get_query args#get_compression);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
          | SchemaDisagreementException sde -> 
              result#set_sde sde
        );
        oprot#writeMessageBegin ("execute_cql_query", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  initializer
    Hashtbl.add processMap "login" self#process_login;
    Hashtbl.add processMap "set_keyspace" self#process_set_keyspace;
    Hashtbl.add processMap "get" self#process_get;
    Hashtbl.add processMap "get_slice" self#process_get_slice;
    Hashtbl.add processMap "get_count" self#process_get_count;
    Hashtbl.add processMap "multiget_slice" self#process_multiget_slice;
    Hashtbl.add processMap "multiget_count" self#process_multiget_count;
    Hashtbl.add processMap "get_range_slices" self#process_get_range_slices;
    Hashtbl.add processMap "get_indexed_slices" self#process_get_indexed_slices;
    Hashtbl.add processMap "insert" self#process_insert;
    Hashtbl.add processMap "add" self#process_add;
    Hashtbl.add processMap "remove" self#process_remove;
    Hashtbl.add processMap "remove_counter" self#process_remove_counter;
    Hashtbl.add processMap "batch_mutate" self#process_batch_mutate;
    Hashtbl.add processMap "truncate" self#process_truncate;
    Hashtbl.add processMap "describe_schema_versions" self#process_describe_schema_versions;
    Hashtbl.add processMap "describe_keyspaces" self#process_describe_keyspaces;
    Hashtbl.add processMap "describe_cluster_name" self#process_describe_cluster_name;
    Hashtbl.add processMap "describe_version" self#process_describe_version;
    Hashtbl.add processMap "describe_ring" self#process_describe_ring;
    Hashtbl.add processMap "describe_partitioner" self#process_describe_partitioner;
    Hashtbl.add processMap "describe_snitch" self#process_describe_snitch;
    Hashtbl.add processMap "describe_keyspace" self#process_describe_keyspace;
    Hashtbl.add processMap "describe_splits" self#process_describe_splits;
    Hashtbl.add processMap "system_add_column_family" self#process_system_add_column_family;
    Hashtbl.add processMap "system_drop_column_family" self#process_system_drop_column_family;
    Hashtbl.add processMap "system_add_keyspace" self#process_system_add_keyspace;
    Hashtbl.add processMap "system_drop_keyspace" self#process_system_drop_keyspace;
    Hashtbl.add processMap "system_update_keyspace" self#process_system_update_keyspace;
    Hashtbl.add processMap "system_update_column_family" self#process_system_update_column_family;
    Hashtbl.add processMap "execute_cql_query" self#process_execute_cql_query;
end

