(*
 Autogenerated by Thrift

 DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING
*)

open Thrift
open Cassandra_types

(* HELPER FUNCTIONS AND STRUCTURES *)

class login_args =
object (self)
  val mutable _auth_request : authenticationRequest option = None
  method get_auth_request = _auth_request
  method grab_auth_request = match _auth_request with None->raise (Field_empty "login_args.auth_request") | Some _x231 -> _x231
  method set_auth_request _x231 = _auth_request <- Some _x231
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "login_args";
    (match _auth_request with None -> () | Some _v -> 
      oprot#writeFieldBegin("auth_request",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_login_args (iprot : Protocol.t) =
  let _str234 = new login_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t235,_id236) = iprot#readFieldBegin in
        if _t235 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id236 with 
          | 1 -> (if _t235 = Protocol.T_STRUCT then
              _str234#set_auth_request (read_authenticationRequest iprot)
            else
              iprot#skip _t235)
          | _ -> iprot#skip _t235);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str234

class login_result =
object (self)
  val mutable _authnx : authenticationException option = None
  method get_authnx = _authnx
  method grab_authnx = match _authnx with None->raise (Field_empty "login_result.authnx") | Some _x237 -> _x237
  method set_authnx _x237 = _authnx <- Some _x237
  val mutable _authzx : authorizationException option = None
  method get_authzx = _authzx
  method grab_authzx = match _authzx with None->raise (Field_empty "login_result.authzx") | Some _x237 -> _x237
  method set_authzx _x237 = _authzx <- Some _x237
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "login_result";
    (match _authnx with None -> () | Some _v -> 
      oprot#writeFieldBegin("authnx",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _authzx with None -> () | Some _v -> 
      oprot#writeFieldBegin("authzx",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_login_result (iprot : Protocol.t) =
  let _str240 = new login_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t241,_id242) = iprot#readFieldBegin in
        if _t241 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id242 with 
          | 1 -> (if _t241 = Protocol.T_STRUCT then
              _str240#set_authnx (read_authenticationException iprot)
            else
              iprot#skip _t241)
          | 2 -> (if _t241 = Protocol.T_STRUCT then
              _str240#set_authzx (read_authorizationException iprot)
            else
              iprot#skip _t241)
          | _ -> iprot#skip _t241);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str240

class set_keyspace_args =
object (self)
  val mutable _keyspace : string option = None
  method get_keyspace = _keyspace
  method grab_keyspace = match _keyspace with None->raise (Field_empty "set_keyspace_args.keyspace") | Some _x243 -> _x243
  method set_keyspace _x243 = _keyspace <- Some _x243
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "set_keyspace_args";
    (match _keyspace with None -> () | Some _v -> 
      oprot#writeFieldBegin("keyspace",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_set_keyspace_args (iprot : Protocol.t) =
  let _str246 = new set_keyspace_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t247,_id248) = iprot#readFieldBegin in
        if _t247 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id248 with 
          | 1 -> (if _t247 = Protocol.T_STRING then
              _str246#set_keyspace iprot#readString
            else
              iprot#skip _t247)
          | _ -> iprot#skip _t247);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str246

class set_keyspace_result =
object (self)
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "set_keyspace_result.ire") | Some _x249 -> _x249
  method set_ire _x249 = _ire <- Some _x249
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "set_keyspace_result";
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_set_keyspace_result (iprot : Protocol.t) =
  let _str252 = new set_keyspace_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t253,_id254) = iprot#readFieldBegin in
        if _t253 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id254 with 
          | 1 -> (if _t253 = Protocol.T_STRUCT then
              _str252#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t253)
          | _ -> iprot#skip _t253);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str252

class get_args =
object (self)
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "get_args.key") | Some _x255 -> _x255
  method set_key _x255 = _key <- Some _x255
  val mutable _column_path : columnPath option = None
  method get_column_path = _column_path
  method grab_column_path = match _column_path with None->raise (Field_empty "get_args.column_path") | Some _x255 -> _x255
  method set_column_path _x255 = _column_path <- Some _x255
  val mutable _consistency_level : ConsistencyLevel.t option = None
  method get_consistency_level = _consistency_level
  method grab_consistency_level = match _consistency_level with None->raise (Field_empty "get_args.consistency_level") | Some _x255 -> _x255
  method set_consistency_level _x255 = _consistency_level <- Some _x255
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_args";
    (match _key with None -> () | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _column_path with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_path",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _consistency_level with None -> () | Some _v -> 
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,3);
      oprot#writeI32(ConsistencyLevel.to_i _v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_args (iprot : Protocol.t) =
  let _str258 = new get_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t259,_id260) = iprot#readFieldBegin in
        if _t259 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id260 with 
          | 1 -> (if _t259 = Protocol.T_STRING then
              _str258#set_key iprot#readString
            else
              iprot#skip _t259)
          | 2 -> (if _t259 = Protocol.T_STRUCT then
              _str258#set_column_path (read_columnPath iprot)
            else
              iprot#skip _t259)
          | 3 -> (if _t259 = Protocol.T_I32 then
              _str258#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t259)
          | _ -> iprot#skip _t259);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str258

class get_result =
object (self)
  val mutable _success : columnOrSuperColumn option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "get_result.success") | Some _x261 -> _x261
  method set_success _x261 = _success <- Some _x261
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "get_result.ire") | Some _x261 -> _x261
  method set_ire _x261 = _ire <- Some _x261
  val mutable _nfe : notFoundException option = None
  method get_nfe = _nfe
  method grab_nfe = match _nfe with None->raise (Field_empty "get_result.nfe") | Some _x261 -> _x261
  method set_nfe _x261 = _nfe <- Some _x261
  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "get_result.ue") | Some _x261 -> _x261
  method set_ue _x261 = _ue <- Some _x261
  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "get_result.te") | Some _x261 -> _x261
  method set_te _x261 = _te <- Some _x261
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRUCT,0);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _nfe with None -> () | Some _v -> 
      oprot#writeFieldBegin("nfe",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,4);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_result (iprot : Protocol.t) =
  let _str264 = new get_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t265,_id266) = iprot#readFieldBegin in
        if _t265 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id266 with 
          | 0 -> (if _t265 = Protocol.T_STRUCT then
              _str264#set_success (read_columnOrSuperColumn iprot)
            else
              iprot#skip _t265)
          | 1 -> (if _t265 = Protocol.T_STRUCT then
              _str264#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t265)
          | 2 -> (if _t265 = Protocol.T_STRUCT then
              _str264#set_nfe (read_notFoundException iprot)
            else
              iprot#skip _t265)
          | 3 -> (if _t265 = Protocol.T_STRUCT then
              _str264#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t265)
          | 4 -> (if _t265 = Protocol.T_STRUCT then
              _str264#set_te (read_timedOutException iprot)
            else
              iprot#skip _t265)
          | _ -> iprot#skip _t265);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str264

class get_slice_args =
object (self)
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "get_slice_args.key") | Some _x267 -> _x267
  method set_key _x267 = _key <- Some _x267
  val mutable _column_parent : columnParent option = None
  method get_column_parent = _column_parent
  method grab_column_parent = match _column_parent with None->raise (Field_empty "get_slice_args.column_parent") | Some _x267 -> _x267
  method set_column_parent _x267 = _column_parent <- Some _x267
  val mutable _predicate : slicePredicate option = None
  method get_predicate = _predicate
  method grab_predicate = match _predicate with None->raise (Field_empty "get_slice_args.predicate") | Some _x267 -> _x267
  method set_predicate _x267 = _predicate <- Some _x267
  val mutable _consistency_level : ConsistencyLevel.t option = None
  method get_consistency_level = _consistency_level
  method grab_consistency_level = match _consistency_level with None->raise (Field_empty "get_slice_args.consistency_level") | Some _x267 -> _x267
  method set_consistency_level _x267 = _consistency_level <- Some _x267
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_slice_args";
    (match _key with None -> () | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _column_parent with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_parent",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _predicate with None -> () | Some _v -> 
      oprot#writeFieldBegin("predicate",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _consistency_level with None -> () | Some _v -> 
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,4);
      oprot#writeI32(ConsistencyLevel.to_i _v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_slice_args (iprot : Protocol.t) =
  let _str270 = new get_slice_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t271,_id272) = iprot#readFieldBegin in
        if _t271 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id272 with 
          | 1 -> (if _t271 = Protocol.T_STRING then
              _str270#set_key iprot#readString
            else
              iprot#skip _t271)
          | 2 -> (if _t271 = Protocol.T_STRUCT then
              _str270#set_column_parent (read_columnParent iprot)
            else
              iprot#skip _t271)
          | 3 -> (if _t271 = Protocol.T_STRUCT then
              _str270#set_predicate (read_slicePredicate iprot)
            else
              iprot#skip _t271)
          | 4 -> (if _t271 = Protocol.T_I32 then
              _str270#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t271)
          | _ -> iprot#skip _t271);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str270

class get_slice_result =
object (self)
  val mutable _success : columnOrSuperColumn list option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "get_slice_result.success") | Some _x273 -> _x273
  method set_success _x273 = _success <- Some _x273
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "get_slice_result.ire") | Some _x273 -> _x273
  method set_ire _x273 = _ire <- Some _x273
  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "get_slice_result.ue") | Some _x273 -> _x273
  method set_ue _x273 = _ue <- Some _x273
  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "get_slice_result.te") | Some _x273 -> _x273
  method set_te _x273 = _te <- Some _x273
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_slice_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_LIST,0);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter276 ->         _iter276#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_slice_result (iprot : Protocol.t) =
  let _str277 = new get_slice_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t278,_id279) = iprot#readFieldBegin in
        if _t278 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id279 with 
          | 0 -> (if _t278 = Protocol.T_LIST then
              _str277#set_success 
                (let (_etype283,_size280) = iprot#readListBegin in
                  let _con284 = (Array.to_list (Array.init _size280 (fun _ -> (read_columnOrSuperColumn iprot)))) in
                    iprot#readListEnd; _con284)
            else
              iprot#skip _t278)
          | 1 -> (if _t278 = Protocol.T_STRUCT then
              _str277#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t278)
          | 2 -> (if _t278 = Protocol.T_STRUCT then
              _str277#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t278)
          | 3 -> (if _t278 = Protocol.T_STRUCT then
              _str277#set_te (read_timedOutException iprot)
            else
              iprot#skip _t278)
          | _ -> iprot#skip _t278);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str277

class get_count_args =
object (self)
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "get_count_args.key") | Some _x285 -> _x285
  method set_key _x285 = _key <- Some _x285
  val mutable _column_parent : columnParent option = None
  method get_column_parent = _column_parent
  method grab_column_parent = match _column_parent with None->raise (Field_empty "get_count_args.column_parent") | Some _x285 -> _x285
  method set_column_parent _x285 = _column_parent <- Some _x285
  val mutable _predicate : slicePredicate option = None
  method get_predicate = _predicate
  method grab_predicate = match _predicate with None->raise (Field_empty "get_count_args.predicate") | Some _x285 -> _x285
  method set_predicate _x285 = _predicate <- Some _x285
  val mutable _consistency_level : ConsistencyLevel.t option = None
  method get_consistency_level = _consistency_level
  method grab_consistency_level = match _consistency_level with None->raise (Field_empty "get_count_args.consistency_level") | Some _x285 -> _x285
  method set_consistency_level _x285 = _consistency_level <- Some _x285
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_count_args";
    (match _key with None -> () | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _column_parent with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_parent",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _predicate with None -> () | Some _v -> 
      oprot#writeFieldBegin("predicate",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _consistency_level with None -> () | Some _v -> 
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,4);
      oprot#writeI32(ConsistencyLevel.to_i _v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_count_args (iprot : Protocol.t) =
  let _str288 = new get_count_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t289,_id290) = iprot#readFieldBegin in
        if _t289 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id290 with 
          | 1 -> (if _t289 = Protocol.T_STRING then
              _str288#set_key iprot#readString
            else
              iprot#skip _t289)
          | 2 -> (if _t289 = Protocol.T_STRUCT then
              _str288#set_column_parent (read_columnParent iprot)
            else
              iprot#skip _t289)
          | 3 -> (if _t289 = Protocol.T_STRUCT then
              _str288#set_predicate (read_slicePredicate iprot)
            else
              iprot#skip _t289)
          | 4 -> (if _t289 = Protocol.T_I32 then
              _str288#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t289)
          | _ -> iprot#skip _t289);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str288

class get_count_result =
object (self)
  val mutable _success : int option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "get_count_result.success") | Some _x291 -> _x291
  method set_success _x291 = _success <- Some _x291
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "get_count_result.ire") | Some _x291 -> _x291
  method set_ire _x291 = _ire <- Some _x291
  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "get_count_result.ue") | Some _x291 -> _x291
  method set_ue _x291 = _ue <- Some _x291
  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "get_count_result.te") | Some _x291 -> _x291
  method set_te _x291 = _te <- Some _x291
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_count_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_I32,0);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_count_result (iprot : Protocol.t) =
  let _str294 = new get_count_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t295,_id296) = iprot#readFieldBegin in
        if _t295 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id296 with 
          | 0 -> (if _t295 = Protocol.T_I32 then
              _str294#set_success iprot#readI32
            else
              iprot#skip _t295)
          | 1 -> (if _t295 = Protocol.T_STRUCT then
              _str294#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t295)
          | 2 -> (if _t295 = Protocol.T_STRUCT then
              _str294#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t295)
          | 3 -> (if _t295 = Protocol.T_STRUCT then
              _str294#set_te (read_timedOutException iprot)
            else
              iprot#skip _t295)
          | _ -> iprot#skip _t295);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str294

class multiget_slice_args =
object (self)
  val mutable _keys : string list option = None
  method get_keys = _keys
  method grab_keys = match _keys with None->raise (Field_empty "multiget_slice_args.keys") | Some _x297 -> _x297
  method set_keys _x297 = _keys <- Some _x297
  val mutable _column_parent : columnParent option = None
  method get_column_parent = _column_parent
  method grab_column_parent = match _column_parent with None->raise (Field_empty "multiget_slice_args.column_parent") | Some _x297 -> _x297
  method set_column_parent _x297 = _column_parent <- Some _x297
  val mutable _predicate : slicePredicate option = None
  method get_predicate = _predicate
  method grab_predicate = match _predicate with None->raise (Field_empty "multiget_slice_args.predicate") | Some _x297 -> _x297
  method set_predicate _x297 = _predicate <- Some _x297
  val mutable _consistency_level : ConsistencyLevel.t option = None
  method get_consistency_level = _consistency_level
  method grab_consistency_level = match _consistency_level with None->raise (Field_empty "multiget_slice_args.consistency_level") | Some _x297 -> _x297
  method set_consistency_level _x297 = _consistency_level <- Some _x297
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "multiget_slice_args";
    (match _keys with None -> () | Some _v -> 
      oprot#writeFieldBegin("keys",Protocol.T_LIST,1);
      oprot#writeListBegin(Protocol.T_STRING,List.length _v);
      List.iter (fun _iter300 ->         oprot#writeString(_iter300);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _column_parent with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_parent",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _predicate with None -> () | Some _v -> 
      oprot#writeFieldBegin("predicate",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _consistency_level with None -> () | Some _v -> 
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,4);
      oprot#writeI32(ConsistencyLevel.to_i _v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_multiget_slice_args (iprot : Protocol.t) =
  let _str301 = new multiget_slice_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t302,_id303) = iprot#readFieldBegin in
        if _t302 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id303 with 
          | 1 -> (if _t302 = Protocol.T_LIST then
              _str301#set_keys 
                (let (_etype307,_size304) = iprot#readListBegin in
                  let _con308 = (Array.to_list (Array.init _size304 (fun _ -> iprot#readString))) in
                    iprot#readListEnd; _con308)
            else
              iprot#skip _t302)
          | 2 -> (if _t302 = Protocol.T_STRUCT then
              _str301#set_column_parent (read_columnParent iprot)
            else
              iprot#skip _t302)
          | 3 -> (if _t302 = Protocol.T_STRUCT then
              _str301#set_predicate (read_slicePredicate iprot)
            else
              iprot#skip _t302)
          | 4 -> (if _t302 = Protocol.T_I32 then
              _str301#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t302)
          | _ -> iprot#skip _t302);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str301

class multiget_slice_result =
object (self)
  val mutable _success : (string,columnOrSuperColumn list) Hashtbl.t option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "multiget_slice_result.success") | Some _x309 -> _x309
  method set_success _x309 = _success <- Some _x309
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "multiget_slice_result.ire") | Some _x309 -> _x309
  method set_ire _x309 = _ire <- Some _x309
  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "multiget_slice_result.ue") | Some _x309 -> _x309
  method set_ue _x309 = _ue <- Some _x309
  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "multiget_slice_result.te") | Some _x309 -> _x309
  method set_te _x309 = _te <- Some _x309
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "multiget_slice_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_MAP,0);
      oprot#writeMapBegin(Protocol.T_STRING,Protocol.T_LIST,Hashtbl.length _v);
      Hashtbl.iter (fun _kiter312 -> fun _viter313 -> 
        oprot#writeString(_kiter312);
        oprot#writeListBegin(Protocol.T_STRUCT,List.length _viter313);
        List.iter (fun _iter314 ->           _iter314#write(oprot);
        ) _viter313;
        oprot#writeListEnd;
      ) _v;
      oprot#writeMapEnd;
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_multiget_slice_result (iprot : Protocol.t) =
  let _str315 = new multiget_slice_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t316,_id317) = iprot#readFieldBegin in
        if _t316 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id317 with 
          | 0 -> (if _t316 = Protocol.T_MAP then
              _str315#set_success 
                (let (_ktype319,_vtype320,_size318) = iprot#readMapBegin in
                let _con322 = Hashtbl.create _size318 in
                  for i = 1 to _size318 do
                    let _k = iprot#readString in
                    let _v = 
                      (let (_etype326,_size323) = iprot#readListBegin in
                        let _con327 = (Array.to_list (Array.init _size323 (fun _ -> (read_columnOrSuperColumn iprot)))) in
                          iprot#readListEnd; _con327) in
                      Hashtbl.add _con322 _k _v
                  done; iprot#readMapEnd; _con322)
            else
              iprot#skip _t316)
          | 1 -> (if _t316 = Protocol.T_STRUCT then
              _str315#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t316)
          | 2 -> (if _t316 = Protocol.T_STRUCT then
              _str315#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t316)
          | 3 -> (if _t316 = Protocol.T_STRUCT then
              _str315#set_te (read_timedOutException iprot)
            else
              iprot#skip _t316)
          | _ -> iprot#skip _t316);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str315

class multiget_count_args =
object (self)
  val mutable _keys : string list option = None
  method get_keys = _keys
  method grab_keys = match _keys with None->raise (Field_empty "multiget_count_args.keys") | Some _x328 -> _x328
  method set_keys _x328 = _keys <- Some _x328
  val mutable _column_parent : columnParent option = None
  method get_column_parent = _column_parent
  method grab_column_parent = match _column_parent with None->raise (Field_empty "multiget_count_args.column_parent") | Some _x328 -> _x328
  method set_column_parent _x328 = _column_parent <- Some _x328
  val mutable _predicate : slicePredicate option = None
  method get_predicate = _predicate
  method grab_predicate = match _predicate with None->raise (Field_empty "multiget_count_args.predicate") | Some _x328 -> _x328
  method set_predicate _x328 = _predicate <- Some _x328
  val mutable _consistency_level : ConsistencyLevel.t option = None
  method get_consistency_level = _consistency_level
  method grab_consistency_level = match _consistency_level with None->raise (Field_empty "multiget_count_args.consistency_level") | Some _x328 -> _x328
  method set_consistency_level _x328 = _consistency_level <- Some _x328
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "multiget_count_args";
    (match _keys with None -> () | Some _v -> 
      oprot#writeFieldBegin("keys",Protocol.T_LIST,1);
      oprot#writeListBegin(Protocol.T_STRING,List.length _v);
      List.iter (fun _iter331 ->         oprot#writeString(_iter331);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _column_parent with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_parent",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _predicate with None -> () | Some _v -> 
      oprot#writeFieldBegin("predicate",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _consistency_level with None -> () | Some _v -> 
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,4);
      oprot#writeI32(ConsistencyLevel.to_i _v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_multiget_count_args (iprot : Protocol.t) =
  let _str332 = new multiget_count_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t333,_id334) = iprot#readFieldBegin in
        if _t333 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id334 with 
          | 1 -> (if _t333 = Protocol.T_LIST then
              _str332#set_keys 
                (let (_etype338,_size335) = iprot#readListBegin in
                  let _con339 = (Array.to_list (Array.init _size335 (fun _ -> iprot#readString))) in
                    iprot#readListEnd; _con339)
            else
              iprot#skip _t333)
          | 2 -> (if _t333 = Protocol.T_STRUCT then
              _str332#set_column_parent (read_columnParent iprot)
            else
              iprot#skip _t333)
          | 3 -> (if _t333 = Protocol.T_STRUCT then
              _str332#set_predicate (read_slicePredicate iprot)
            else
              iprot#skip _t333)
          | 4 -> (if _t333 = Protocol.T_I32 then
              _str332#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t333)
          | _ -> iprot#skip _t333);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str332

class multiget_count_result =
object (self)
  val mutable _success : (string,int) Hashtbl.t option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "multiget_count_result.success") | Some _x340 -> _x340
  method set_success _x340 = _success <- Some _x340
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "multiget_count_result.ire") | Some _x340 -> _x340
  method set_ire _x340 = _ire <- Some _x340
  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "multiget_count_result.ue") | Some _x340 -> _x340
  method set_ue _x340 = _ue <- Some _x340
  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "multiget_count_result.te") | Some _x340 -> _x340
  method set_te _x340 = _te <- Some _x340
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "multiget_count_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_MAP,0);
      oprot#writeMapBegin(Protocol.T_STRING,Protocol.T_I32,Hashtbl.length _v);
      Hashtbl.iter (fun _kiter343 -> fun _viter344 -> 
        oprot#writeString(_kiter343);
        oprot#writeI32(_viter344);
      ) _v;
      oprot#writeMapEnd;
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_multiget_count_result (iprot : Protocol.t) =
  let _str345 = new multiget_count_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t346,_id347) = iprot#readFieldBegin in
        if _t346 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id347 with 
          | 0 -> (if _t346 = Protocol.T_MAP then
              _str345#set_success 
                (let (_ktype349,_vtype350,_size348) = iprot#readMapBegin in
                let _con352 = Hashtbl.create _size348 in
                  for i = 1 to _size348 do
                    let _k = iprot#readString in
                    let _v = iprot#readI32 in
                      Hashtbl.add _con352 _k _v
                  done; iprot#readMapEnd; _con352)
            else
              iprot#skip _t346)
          | 1 -> (if _t346 = Protocol.T_STRUCT then
              _str345#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t346)
          | 2 -> (if _t346 = Protocol.T_STRUCT then
              _str345#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t346)
          | 3 -> (if _t346 = Protocol.T_STRUCT then
              _str345#set_te (read_timedOutException iprot)
            else
              iprot#skip _t346)
          | _ -> iprot#skip _t346);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str345

class get_range_slices_args =
object (self)
  val mutable _column_parent : columnParent option = None
  method get_column_parent = _column_parent
  method grab_column_parent = match _column_parent with None->raise (Field_empty "get_range_slices_args.column_parent") | Some _x353 -> _x353
  method set_column_parent _x353 = _column_parent <- Some _x353
  val mutable _predicate : slicePredicate option = None
  method get_predicate = _predicate
  method grab_predicate = match _predicate with None->raise (Field_empty "get_range_slices_args.predicate") | Some _x353 -> _x353
  method set_predicate _x353 = _predicate <- Some _x353
  val mutable _range : keyRange option = None
  method get_range = _range
  method grab_range = match _range with None->raise (Field_empty "get_range_slices_args.range") | Some _x353 -> _x353
  method set_range _x353 = _range <- Some _x353
  val mutable _consistency_level : ConsistencyLevel.t option = None
  method get_consistency_level = _consistency_level
  method grab_consistency_level = match _consistency_level with None->raise (Field_empty "get_range_slices_args.consistency_level") | Some _x353 -> _x353
  method set_consistency_level _x353 = _consistency_level <- Some _x353
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_range_slices_args";
    (match _column_parent with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_parent",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _predicate with None -> () | Some _v -> 
      oprot#writeFieldBegin("predicate",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _range with None -> () | Some _v -> 
      oprot#writeFieldBegin("range",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _consistency_level with None -> () | Some _v -> 
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,4);
      oprot#writeI32(ConsistencyLevel.to_i _v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_range_slices_args (iprot : Protocol.t) =
  let _str356 = new get_range_slices_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t357,_id358) = iprot#readFieldBegin in
        if _t357 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id358 with 
          | 1 -> (if _t357 = Protocol.T_STRUCT then
              _str356#set_column_parent (read_columnParent iprot)
            else
              iprot#skip _t357)
          | 2 -> (if _t357 = Protocol.T_STRUCT then
              _str356#set_predicate (read_slicePredicate iprot)
            else
              iprot#skip _t357)
          | 3 -> (if _t357 = Protocol.T_STRUCT then
              _str356#set_range (read_keyRange iprot)
            else
              iprot#skip _t357)
          | 4 -> (if _t357 = Protocol.T_I32 then
              _str356#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t357)
          | _ -> iprot#skip _t357);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str356

class get_range_slices_result =
object (self)
  val mutable _success : keySlice list option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "get_range_slices_result.success") | Some _x359 -> _x359
  method set_success _x359 = _success <- Some _x359
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "get_range_slices_result.ire") | Some _x359 -> _x359
  method set_ire _x359 = _ire <- Some _x359
  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "get_range_slices_result.ue") | Some _x359 -> _x359
  method set_ue _x359 = _ue <- Some _x359
  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "get_range_slices_result.te") | Some _x359 -> _x359
  method set_te _x359 = _te <- Some _x359
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_range_slices_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_LIST,0);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter362 ->         _iter362#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_range_slices_result (iprot : Protocol.t) =
  let _str363 = new get_range_slices_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t364,_id365) = iprot#readFieldBegin in
        if _t364 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id365 with 
          | 0 -> (if _t364 = Protocol.T_LIST then
              _str363#set_success 
                (let (_etype369,_size366) = iprot#readListBegin in
                  let _con370 = (Array.to_list (Array.init _size366 (fun _ -> (read_keySlice iprot)))) in
                    iprot#readListEnd; _con370)
            else
              iprot#skip _t364)
          | 1 -> (if _t364 = Protocol.T_STRUCT then
              _str363#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t364)
          | 2 -> (if _t364 = Protocol.T_STRUCT then
              _str363#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t364)
          | 3 -> (if _t364 = Protocol.T_STRUCT then
              _str363#set_te (read_timedOutException iprot)
            else
              iprot#skip _t364)
          | _ -> iprot#skip _t364);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str363

class get_indexed_slices_args =
object (self)
  val mutable _column_parent : columnParent option = None
  method get_column_parent = _column_parent
  method grab_column_parent = match _column_parent with None->raise (Field_empty "get_indexed_slices_args.column_parent") | Some _x371 -> _x371
  method set_column_parent _x371 = _column_parent <- Some _x371
  val mutable _index_clause : indexClause option = None
  method get_index_clause = _index_clause
  method grab_index_clause = match _index_clause with None->raise (Field_empty "get_indexed_slices_args.index_clause") | Some _x371 -> _x371
  method set_index_clause _x371 = _index_clause <- Some _x371
  val mutable _column_predicate : slicePredicate option = None
  method get_column_predicate = _column_predicate
  method grab_column_predicate = match _column_predicate with None->raise (Field_empty "get_indexed_slices_args.column_predicate") | Some _x371 -> _x371
  method set_column_predicate _x371 = _column_predicate <- Some _x371
  val mutable _consistency_level : ConsistencyLevel.t option = None
  method get_consistency_level = _consistency_level
  method grab_consistency_level = match _consistency_level with None->raise (Field_empty "get_indexed_slices_args.consistency_level") | Some _x371 -> _x371
  method set_consistency_level _x371 = _consistency_level <- Some _x371
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_indexed_slices_args";
    (match _column_parent with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_parent",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _index_clause with None -> () | Some _v -> 
      oprot#writeFieldBegin("index_clause",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _column_predicate with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_predicate",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _consistency_level with None -> () | Some _v -> 
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,4);
      oprot#writeI32(ConsistencyLevel.to_i _v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_indexed_slices_args (iprot : Protocol.t) =
  let _str374 = new get_indexed_slices_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t375,_id376) = iprot#readFieldBegin in
        if _t375 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id376 with 
          | 1 -> (if _t375 = Protocol.T_STRUCT then
              _str374#set_column_parent (read_columnParent iprot)
            else
              iprot#skip _t375)
          | 2 -> (if _t375 = Protocol.T_STRUCT then
              _str374#set_index_clause (read_indexClause iprot)
            else
              iprot#skip _t375)
          | 3 -> (if _t375 = Protocol.T_STRUCT then
              _str374#set_column_predicate (read_slicePredicate iprot)
            else
              iprot#skip _t375)
          | 4 -> (if _t375 = Protocol.T_I32 then
              _str374#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t375)
          | _ -> iprot#skip _t375);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str374

class get_indexed_slices_result =
object (self)
  val mutable _success : keySlice list option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "get_indexed_slices_result.success") | Some _x377 -> _x377
  method set_success _x377 = _success <- Some _x377
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "get_indexed_slices_result.ire") | Some _x377 -> _x377
  method set_ire _x377 = _ire <- Some _x377
  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "get_indexed_slices_result.ue") | Some _x377 -> _x377
  method set_ue _x377 = _ue <- Some _x377
  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "get_indexed_slices_result.te") | Some _x377 -> _x377
  method set_te _x377 = _te <- Some _x377
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_indexed_slices_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_LIST,0);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter380 ->         _iter380#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_indexed_slices_result (iprot : Protocol.t) =
  let _str381 = new get_indexed_slices_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t382,_id383) = iprot#readFieldBegin in
        if _t382 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id383 with 
          | 0 -> (if _t382 = Protocol.T_LIST then
              _str381#set_success 
                (let (_etype387,_size384) = iprot#readListBegin in
                  let _con388 = (Array.to_list (Array.init _size384 (fun _ -> (read_keySlice iprot)))) in
                    iprot#readListEnd; _con388)
            else
              iprot#skip _t382)
          | 1 -> (if _t382 = Protocol.T_STRUCT then
              _str381#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t382)
          | 2 -> (if _t382 = Protocol.T_STRUCT then
              _str381#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t382)
          | 3 -> (if _t382 = Protocol.T_STRUCT then
              _str381#set_te (read_timedOutException iprot)
            else
              iprot#skip _t382)
          | _ -> iprot#skip _t382);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str381

class insert_args =
object (self)
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "insert_args.key") | Some _x389 -> _x389
  method set_key _x389 = _key <- Some _x389
  val mutable _column_parent : columnParent option = None
  method get_column_parent = _column_parent
  method grab_column_parent = match _column_parent with None->raise (Field_empty "insert_args.column_parent") | Some _x389 -> _x389
  method set_column_parent _x389 = _column_parent <- Some _x389
  val mutable _column : column option = None
  method get_column = _column
  method grab_column = match _column with None->raise (Field_empty "insert_args.column") | Some _x389 -> _x389
  method set_column _x389 = _column <- Some _x389
  val mutable _consistency_level : ConsistencyLevel.t option = None
  method get_consistency_level = _consistency_level
  method grab_consistency_level = match _consistency_level with None->raise (Field_empty "insert_args.consistency_level") | Some _x389 -> _x389
  method set_consistency_level _x389 = _consistency_level <- Some _x389
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "insert_args";
    (match _key with None -> () | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _column_parent with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_parent",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _column with None -> () | Some _v -> 
      oprot#writeFieldBegin("column",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _consistency_level with None -> () | Some _v -> 
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,4);
      oprot#writeI32(ConsistencyLevel.to_i _v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_insert_args (iprot : Protocol.t) =
  let _str392 = new insert_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t393,_id394) = iprot#readFieldBegin in
        if _t393 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id394 with 
          | 1 -> (if _t393 = Protocol.T_STRING then
              _str392#set_key iprot#readString
            else
              iprot#skip _t393)
          | 2 -> (if _t393 = Protocol.T_STRUCT then
              _str392#set_column_parent (read_columnParent iprot)
            else
              iprot#skip _t393)
          | 3 -> (if _t393 = Protocol.T_STRUCT then
              _str392#set_column (read_column iprot)
            else
              iprot#skip _t393)
          | 4 -> (if _t393 = Protocol.T_I32 then
              _str392#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t393)
          | _ -> iprot#skip _t393);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str392

class insert_result =
object (self)
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "insert_result.ire") | Some _x395 -> _x395
  method set_ire _x395 = _ire <- Some _x395
  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "insert_result.ue") | Some _x395 -> _x395
  method set_ue _x395 = _ue <- Some _x395
  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "insert_result.te") | Some _x395 -> _x395
  method set_te _x395 = _te <- Some _x395
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "insert_result";
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_insert_result (iprot : Protocol.t) =
  let _str398 = new insert_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t399,_id400) = iprot#readFieldBegin in
        if _t399 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id400 with 
          | 1 -> (if _t399 = Protocol.T_STRUCT then
              _str398#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t399)
          | 2 -> (if _t399 = Protocol.T_STRUCT then
              _str398#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t399)
          | 3 -> (if _t399 = Protocol.T_STRUCT then
              _str398#set_te (read_timedOutException iprot)
            else
              iprot#skip _t399)
          | _ -> iprot#skip _t399);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str398

class remove_args =
object (self)
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "remove_args.key") | Some _x401 -> _x401
  method set_key _x401 = _key <- Some _x401
  val mutable _column_path : columnPath option = None
  method get_column_path = _column_path
  method grab_column_path = match _column_path with None->raise (Field_empty "remove_args.column_path") | Some _x401 -> _x401
  method set_column_path _x401 = _column_path <- Some _x401
  val mutable _timestamp : Int64.t option = None
  method get_timestamp = _timestamp
  method grab_timestamp = match _timestamp with None->raise (Field_empty "remove_args.timestamp") | Some _x401 -> _x401
  method set_timestamp _x401 = _timestamp <- Some _x401
  val mutable _consistency_level : ConsistencyLevel.t option = None
  method get_consistency_level = _consistency_level
  method grab_consistency_level = match _consistency_level with None->raise (Field_empty "remove_args.consistency_level") | Some _x401 -> _x401
  method set_consistency_level _x401 = _consistency_level <- Some _x401
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "remove_args";
    (match _key with None -> () | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _column_path with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_path",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _timestamp with None -> () | Some _v -> 
      oprot#writeFieldBegin("timestamp",Protocol.T_I64,3);
      oprot#writeI64(_v);
      oprot#writeFieldEnd
    );
    (match _consistency_level with None -> () | Some _v -> 
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,4);
      oprot#writeI32(ConsistencyLevel.to_i _v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_remove_args (iprot : Protocol.t) =
  let _str404 = new remove_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t405,_id406) = iprot#readFieldBegin in
        if _t405 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id406 with 
          | 1 -> (if _t405 = Protocol.T_STRING then
              _str404#set_key iprot#readString
            else
              iprot#skip _t405)
          | 2 -> (if _t405 = Protocol.T_STRUCT then
              _str404#set_column_path (read_columnPath iprot)
            else
              iprot#skip _t405)
          | 3 -> (if _t405 = Protocol.T_I64 then
              _str404#set_timestamp iprot#readI64
            else
              iprot#skip _t405)
          | 4 -> (if _t405 = Protocol.T_I32 then
              _str404#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t405)
          | _ -> iprot#skip _t405);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str404

class remove_result =
object (self)
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "remove_result.ire") | Some _x407 -> _x407
  method set_ire _x407 = _ire <- Some _x407
  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "remove_result.ue") | Some _x407 -> _x407
  method set_ue _x407 = _ue <- Some _x407
  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "remove_result.te") | Some _x407 -> _x407
  method set_te _x407 = _te <- Some _x407
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "remove_result";
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_remove_result (iprot : Protocol.t) =
  let _str410 = new remove_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t411,_id412) = iprot#readFieldBegin in
        if _t411 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id412 with 
          | 1 -> (if _t411 = Protocol.T_STRUCT then
              _str410#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t411)
          | 2 -> (if _t411 = Protocol.T_STRUCT then
              _str410#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t411)
          | 3 -> (if _t411 = Protocol.T_STRUCT then
              _str410#set_te (read_timedOutException iprot)
            else
              iprot#skip _t411)
          | _ -> iprot#skip _t411);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str410

class batch_mutate_args =
object (self)
  val mutable _mutation_map : (string,(string,mutation list) Hashtbl.t) Hashtbl.t option = None
  method get_mutation_map = _mutation_map
  method grab_mutation_map = match _mutation_map with None->raise (Field_empty "batch_mutate_args.mutation_map") | Some _x413 -> _x413
  method set_mutation_map _x413 = _mutation_map <- Some _x413
  val mutable _consistency_level : ConsistencyLevel.t option = None
  method get_consistency_level = _consistency_level
  method grab_consistency_level = match _consistency_level with None->raise (Field_empty "batch_mutate_args.consistency_level") | Some _x413 -> _x413
  method set_consistency_level _x413 = _consistency_level <- Some _x413
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "batch_mutate_args";
    (match _mutation_map with None -> () | Some _v -> 
      oprot#writeFieldBegin("mutation_map",Protocol.T_MAP,1);
      oprot#writeMapBegin(Protocol.T_STRING,Protocol.T_MAP,Hashtbl.length _v);
      Hashtbl.iter (fun _kiter416 -> fun _viter417 -> 
        oprot#writeString(_kiter416);
        oprot#writeMapBegin(Protocol.T_STRING,Protocol.T_LIST,Hashtbl.length _viter417);
        Hashtbl.iter (fun _kiter418 -> fun _viter419 -> 
          oprot#writeString(_kiter418);
          oprot#writeListBegin(Protocol.T_STRUCT,List.length _viter419);
          List.iter (fun _iter420 ->             _iter420#write(oprot);
          ) _viter419;
          oprot#writeListEnd;
        ) _viter417;
        oprot#writeMapEnd;
      ) _v;
      oprot#writeMapEnd;
      oprot#writeFieldEnd
    );
    (match _consistency_level with None -> () | Some _v -> 
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,2);
      oprot#writeI32(ConsistencyLevel.to_i _v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_batch_mutate_args (iprot : Protocol.t) =
  let _str421 = new batch_mutate_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t422,_id423) = iprot#readFieldBegin in
        if _t422 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id423 with 
          | 1 -> (if _t422 = Protocol.T_MAP then
              _str421#set_mutation_map 
                (let (_ktype425,_vtype426,_size424) = iprot#readMapBegin in
                let _con428 = Hashtbl.create _size424 in
                  for i = 1 to _size424 do
                    let _k = iprot#readString in
                    let _v = 
                      (let (_ktype430,_vtype431,_size429) = iprot#readMapBegin in
                      let _con433 = Hashtbl.create _size429 in
                        for i = 1 to _size429 do
                          let _k = iprot#readString in
                          let _v = 
                            (let (_etype437,_size434) = iprot#readListBegin in
                              let _con438 = (Array.to_list (Array.init _size434 (fun _ -> (read_mutation iprot)))) in
                                iprot#readListEnd; _con438) in
                            Hashtbl.add _con433 _k _v
                        done; iprot#readMapEnd; _con433) in
                      Hashtbl.add _con428 _k _v
                  done; iprot#readMapEnd; _con428)
            else
              iprot#skip _t422)
          | 2 -> (if _t422 = Protocol.T_I32 then
              _str421#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t422)
          | _ -> iprot#skip _t422);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str421

class batch_mutate_result =
object (self)
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "batch_mutate_result.ire") | Some _x439 -> _x439
  method set_ire _x439 = _ire <- Some _x439
  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "batch_mutate_result.ue") | Some _x439 -> _x439
  method set_ue _x439 = _ue <- Some _x439
  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "batch_mutate_result.te") | Some _x439 -> _x439
  method set_te _x439 = _te <- Some _x439
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "batch_mutate_result";
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_batch_mutate_result (iprot : Protocol.t) =
  let _str442 = new batch_mutate_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t443,_id444) = iprot#readFieldBegin in
        if _t443 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id444 with 
          | 1 -> (if _t443 = Protocol.T_STRUCT then
              _str442#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t443)
          | 2 -> (if _t443 = Protocol.T_STRUCT then
              _str442#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t443)
          | 3 -> (if _t443 = Protocol.T_STRUCT then
              _str442#set_te (read_timedOutException iprot)
            else
              iprot#skip _t443)
          | _ -> iprot#skip _t443);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str442

class truncate_args =
object (self)
  val mutable _cfname : string option = None
  method get_cfname = _cfname
  method grab_cfname = match _cfname with None->raise (Field_empty "truncate_args.cfname") | Some _x445 -> _x445
  method set_cfname _x445 = _cfname <- Some _x445
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "truncate_args";
    (match _cfname with None -> () | Some _v -> 
      oprot#writeFieldBegin("cfname",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_truncate_args (iprot : Protocol.t) =
  let _str448 = new truncate_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t449,_id450) = iprot#readFieldBegin in
        if _t449 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id450 with 
          | 1 -> (if _t449 = Protocol.T_STRING then
              _str448#set_cfname iprot#readString
            else
              iprot#skip _t449)
          | _ -> iprot#skip _t449);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str448

class truncate_result =
object (self)
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "truncate_result.ire") | Some _x451 -> _x451
  method set_ire _x451 = _ire <- Some _x451
  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "truncate_result.ue") | Some _x451 -> _x451
  method set_ue _x451 = _ue <- Some _x451
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "truncate_result";
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_truncate_result (iprot : Protocol.t) =
  let _str454 = new truncate_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t455,_id456) = iprot#readFieldBegin in
        if _t455 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id456 with 
          | 1 -> (if _t455 = Protocol.T_STRUCT then
              _str454#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t455)
          | 2 -> (if _t455 = Protocol.T_STRUCT then
              _str454#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t455)
          | _ -> iprot#skip _t455);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str454

class describe_schema_versions_args =
object (self)
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_schema_versions_args";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_schema_versions_args (iprot : Protocol.t) =
  let _str460 = new describe_schema_versions_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t461,_id462) = iprot#readFieldBegin in
        if _t461 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id462 with 
          | _ -> iprot#skip _t461);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str460

class describe_schema_versions_result =
object (self)
  val mutable _success : (string,string list) Hashtbl.t option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "describe_schema_versions_result.success") | Some _x463 -> _x463
  method set_success _x463 = _success <- Some _x463
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "describe_schema_versions_result.ire") | Some _x463 -> _x463
  method set_ire _x463 = _ire <- Some _x463
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_schema_versions_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_MAP,0);
      oprot#writeMapBegin(Protocol.T_STRING,Protocol.T_LIST,Hashtbl.length _v);
      Hashtbl.iter (fun _kiter466 -> fun _viter467 -> 
        oprot#writeString(_kiter466);
        oprot#writeListBegin(Protocol.T_STRING,List.length _viter467);
        List.iter (fun _iter468 ->           oprot#writeString(_iter468);
        ) _viter467;
        oprot#writeListEnd;
      ) _v;
      oprot#writeMapEnd;
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_schema_versions_result (iprot : Protocol.t) =
  let _str469 = new describe_schema_versions_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t470,_id471) = iprot#readFieldBegin in
        if _t470 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id471 with 
          | 0 -> (if _t470 = Protocol.T_MAP then
              _str469#set_success 
                (let (_ktype473,_vtype474,_size472) = iprot#readMapBegin in
                let _con476 = Hashtbl.create _size472 in
                  for i = 1 to _size472 do
                    let _k = iprot#readString in
                    let _v = 
                      (let (_etype480,_size477) = iprot#readListBegin in
                        let _con481 = (Array.to_list (Array.init _size477 (fun _ -> iprot#readString))) in
                          iprot#readListEnd; _con481) in
                      Hashtbl.add _con476 _k _v
                  done; iprot#readMapEnd; _con476)
            else
              iprot#skip _t470)
          | 1 -> (if _t470 = Protocol.T_STRUCT then
              _str469#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t470)
          | _ -> iprot#skip _t470);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str469

class describe_keyspaces_args =
object (self)
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_keyspaces_args";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_keyspaces_args (iprot : Protocol.t) =
  let _str485 = new describe_keyspaces_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t486,_id487) = iprot#readFieldBegin in
        if _t486 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id487 with 
          | _ -> iprot#skip _t486);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str485

class describe_keyspaces_result =
object (self)
  val mutable _success : ksDef list option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "describe_keyspaces_result.success") | Some _x488 -> _x488
  method set_success _x488 = _success <- Some _x488
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "describe_keyspaces_result.ire") | Some _x488 -> _x488
  method set_ire _x488 = _ire <- Some _x488
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_keyspaces_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_LIST,0);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter491 ->         _iter491#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_keyspaces_result (iprot : Protocol.t) =
  let _str492 = new describe_keyspaces_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t493,_id494) = iprot#readFieldBegin in
        if _t493 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id494 with 
          | 0 -> (if _t493 = Protocol.T_LIST then
              _str492#set_success 
                (let (_etype498,_size495) = iprot#readListBegin in
                  let _con499 = (Array.to_list (Array.init _size495 (fun _ -> (read_ksDef iprot)))) in
                    iprot#readListEnd; _con499)
            else
              iprot#skip _t493)
          | 1 -> (if _t493 = Protocol.T_STRUCT then
              _str492#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t493)
          | _ -> iprot#skip _t493);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str492

class describe_cluster_name_args =
object (self)
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_cluster_name_args";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_cluster_name_args (iprot : Protocol.t) =
  let _str503 = new describe_cluster_name_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t504,_id505) = iprot#readFieldBegin in
        if _t504 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id505 with 
          | _ -> iprot#skip _t504);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str503

class describe_cluster_name_result =
object (self)
  val mutable _success : string option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "describe_cluster_name_result.success") | Some _x506 -> _x506
  method set_success _x506 = _success <- Some _x506
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_cluster_name_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRING,0);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_cluster_name_result (iprot : Protocol.t) =
  let _str509 = new describe_cluster_name_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t510,_id511) = iprot#readFieldBegin in
        if _t510 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id511 with 
          | 0 -> (if _t510 = Protocol.T_STRING then
              _str509#set_success iprot#readString
            else
              iprot#skip _t510)
          | _ -> iprot#skip _t510);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str509

class describe_version_args =
object (self)
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_version_args";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_version_args (iprot : Protocol.t) =
  let _str515 = new describe_version_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t516,_id517) = iprot#readFieldBegin in
        if _t516 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id517 with 
          | _ -> iprot#skip _t516);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str515

class describe_version_result =
object (self)
  val mutable _success : string option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "describe_version_result.success") | Some _x518 -> _x518
  method set_success _x518 = _success <- Some _x518
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_version_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRING,0);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_version_result (iprot : Protocol.t) =
  let _str521 = new describe_version_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t522,_id523) = iprot#readFieldBegin in
        if _t522 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id523 with 
          | 0 -> (if _t522 = Protocol.T_STRING then
              _str521#set_success iprot#readString
            else
              iprot#skip _t522)
          | _ -> iprot#skip _t522);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str521

class describe_ring_args =
object (self)
  val mutable _keyspace : string option = None
  method get_keyspace = _keyspace
  method grab_keyspace = match _keyspace with None->raise (Field_empty "describe_ring_args.keyspace") | Some _x524 -> _x524
  method set_keyspace _x524 = _keyspace <- Some _x524
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_ring_args";
    (match _keyspace with None -> () | Some _v -> 
      oprot#writeFieldBegin("keyspace",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_ring_args (iprot : Protocol.t) =
  let _str527 = new describe_ring_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t528,_id529) = iprot#readFieldBegin in
        if _t528 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id529 with 
          | 1 -> (if _t528 = Protocol.T_STRING then
              _str527#set_keyspace iprot#readString
            else
              iprot#skip _t528)
          | _ -> iprot#skip _t528);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str527

class describe_ring_result =
object (self)
  val mutable _success : tokenRange list option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "describe_ring_result.success") | Some _x530 -> _x530
  method set_success _x530 = _success <- Some _x530
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "describe_ring_result.ire") | Some _x530 -> _x530
  method set_ire _x530 = _ire <- Some _x530
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_ring_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_LIST,0);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter533 ->         _iter533#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_ring_result (iprot : Protocol.t) =
  let _str534 = new describe_ring_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t535,_id536) = iprot#readFieldBegin in
        if _t535 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id536 with 
          | 0 -> (if _t535 = Protocol.T_LIST then
              _str534#set_success 
                (let (_etype540,_size537) = iprot#readListBegin in
                  let _con541 = (Array.to_list (Array.init _size537 (fun _ -> (read_tokenRange iprot)))) in
                    iprot#readListEnd; _con541)
            else
              iprot#skip _t535)
          | 1 -> (if _t535 = Protocol.T_STRUCT then
              _str534#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t535)
          | _ -> iprot#skip _t535);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str534

class describe_partitioner_args =
object (self)
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_partitioner_args";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_partitioner_args (iprot : Protocol.t) =
  let _str545 = new describe_partitioner_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t546,_id547) = iprot#readFieldBegin in
        if _t546 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id547 with 
          | _ -> iprot#skip _t546);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str545

class describe_partitioner_result =
object (self)
  val mutable _success : string option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "describe_partitioner_result.success") | Some _x548 -> _x548
  method set_success _x548 = _success <- Some _x548
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_partitioner_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRING,0);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_partitioner_result (iprot : Protocol.t) =
  let _str551 = new describe_partitioner_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t552,_id553) = iprot#readFieldBegin in
        if _t552 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id553 with 
          | 0 -> (if _t552 = Protocol.T_STRING then
              _str551#set_success iprot#readString
            else
              iprot#skip _t552)
          | _ -> iprot#skip _t552);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str551

class describe_snitch_args =
object (self)
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_snitch_args";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_snitch_args (iprot : Protocol.t) =
  let _str557 = new describe_snitch_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t558,_id559) = iprot#readFieldBegin in
        if _t558 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id559 with 
          | _ -> iprot#skip _t558);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str557

class describe_snitch_result =
object (self)
  val mutable _success : string option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "describe_snitch_result.success") | Some _x560 -> _x560
  method set_success _x560 = _success <- Some _x560
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_snitch_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRING,0);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_snitch_result (iprot : Protocol.t) =
  let _str563 = new describe_snitch_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t564,_id565) = iprot#readFieldBegin in
        if _t564 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id565 with 
          | 0 -> (if _t564 = Protocol.T_STRING then
              _str563#set_success iprot#readString
            else
              iprot#skip _t564)
          | _ -> iprot#skip _t564);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str563

class describe_keyspace_args =
object (self)
  val mutable _keyspace : string option = None
  method get_keyspace = _keyspace
  method grab_keyspace = match _keyspace with None->raise (Field_empty "describe_keyspace_args.keyspace") | Some _x566 -> _x566
  method set_keyspace _x566 = _keyspace <- Some _x566
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_keyspace_args";
    (match _keyspace with None -> () | Some _v -> 
      oprot#writeFieldBegin("keyspace",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_keyspace_args (iprot : Protocol.t) =
  let _str569 = new describe_keyspace_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t570,_id571) = iprot#readFieldBegin in
        if _t570 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id571 with 
          | 1 -> (if _t570 = Protocol.T_STRING then
              _str569#set_keyspace iprot#readString
            else
              iprot#skip _t570)
          | _ -> iprot#skip _t570);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str569

class describe_keyspace_result =
object (self)
  val mutable _success : ksDef option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "describe_keyspace_result.success") | Some _x572 -> _x572
  method set_success _x572 = _success <- Some _x572
  val mutable _nfe : notFoundException option = None
  method get_nfe = _nfe
  method grab_nfe = match _nfe with None->raise (Field_empty "describe_keyspace_result.nfe") | Some _x572 -> _x572
  method set_nfe _x572 = _nfe <- Some _x572
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "describe_keyspace_result.ire") | Some _x572 -> _x572
  method set_ire _x572 = _ire <- Some _x572
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_keyspace_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRUCT,0);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _nfe with None -> () | Some _v -> 
      oprot#writeFieldBegin("nfe",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_keyspace_result (iprot : Protocol.t) =
  let _str575 = new describe_keyspace_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t576,_id577) = iprot#readFieldBegin in
        if _t576 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id577 with 
          | 0 -> (if _t576 = Protocol.T_STRUCT then
              _str575#set_success (read_ksDef iprot)
            else
              iprot#skip _t576)
          | 1 -> (if _t576 = Protocol.T_STRUCT then
              _str575#set_nfe (read_notFoundException iprot)
            else
              iprot#skip _t576)
          | 2 -> (if _t576 = Protocol.T_STRUCT then
              _str575#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t576)
          | _ -> iprot#skip _t576);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str575

class describe_splits_args =
object (self)
  val mutable _cfName : string option = None
  method get_cfName = _cfName
  method grab_cfName = match _cfName with None->raise (Field_empty "describe_splits_args.cfName") | Some _x578 -> _x578
  method set_cfName _x578 = _cfName <- Some _x578
  val mutable _start_token : string option = None
  method get_start_token = _start_token
  method grab_start_token = match _start_token with None->raise (Field_empty "describe_splits_args.start_token") | Some _x578 -> _x578
  method set_start_token _x578 = _start_token <- Some _x578
  val mutable _end_token : string option = None
  method get_end_token = _end_token
  method grab_end_token = match _end_token with None->raise (Field_empty "describe_splits_args.end_token") | Some _x578 -> _x578
  method set_end_token _x578 = _end_token <- Some _x578
  val mutable _keys_per_split : int option = None
  method get_keys_per_split = _keys_per_split
  method grab_keys_per_split = match _keys_per_split with None->raise (Field_empty "describe_splits_args.keys_per_split") | Some _x578 -> _x578
  method set_keys_per_split _x578 = _keys_per_split <- Some _x578
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_splits_args";
    (match _cfName with None -> () | Some _v -> 
      oprot#writeFieldBegin("cfName",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _start_token with None -> () | Some _v -> 
      oprot#writeFieldBegin("start_token",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _end_token with None -> () | Some _v -> 
      oprot#writeFieldBegin("end_token",Protocol.T_STRING,3);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _keys_per_split with None -> () | Some _v -> 
      oprot#writeFieldBegin("keys_per_split",Protocol.T_I32,4);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_splits_args (iprot : Protocol.t) =
  let _str581 = new describe_splits_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t582,_id583) = iprot#readFieldBegin in
        if _t582 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id583 with 
          | 1 -> (if _t582 = Protocol.T_STRING then
              _str581#set_cfName iprot#readString
            else
              iprot#skip _t582)
          | 2 -> (if _t582 = Protocol.T_STRING then
              _str581#set_start_token iprot#readString
            else
              iprot#skip _t582)
          | 3 -> (if _t582 = Protocol.T_STRING then
              _str581#set_end_token iprot#readString
            else
              iprot#skip _t582)
          | 4 -> (if _t582 = Protocol.T_I32 then
              _str581#set_keys_per_split iprot#readI32
            else
              iprot#skip _t582)
          | _ -> iprot#skip _t582);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str581

class describe_splits_result =
object (self)
  val mutable _success : string list option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "describe_splits_result.success") | Some _x584 -> _x584
  method set_success _x584 = _success <- Some _x584
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_splits_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_LIST,0);
      oprot#writeListBegin(Protocol.T_STRING,List.length _v);
      List.iter (fun _iter587 ->         oprot#writeString(_iter587);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_splits_result (iprot : Protocol.t) =
  let _str588 = new describe_splits_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t589,_id590) = iprot#readFieldBegin in
        if _t589 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id590 with 
          | 0 -> (if _t589 = Protocol.T_LIST then
              _str588#set_success 
                (let (_etype594,_size591) = iprot#readListBegin in
                  let _con595 = (Array.to_list (Array.init _size591 (fun _ -> iprot#readString))) in
                    iprot#readListEnd; _con595)
            else
              iprot#skip _t589)
          | _ -> iprot#skip _t589);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str588

class system_add_column_family_args =
object (self)
  val mutable _cf_def : cfDef option = None
  method get_cf_def = _cf_def
  method grab_cf_def = match _cf_def with None->raise (Field_empty "system_add_column_family_args.cf_def") | Some _x596 -> _x596
  method set_cf_def _x596 = _cf_def <- Some _x596
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_add_column_family_args";
    (match _cf_def with None -> () | Some _v -> 
      oprot#writeFieldBegin("cf_def",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_add_column_family_args (iprot : Protocol.t) =
  let _str599 = new system_add_column_family_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t600,_id601) = iprot#readFieldBegin in
        if _t600 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id601 with 
          | 1 -> (if _t600 = Protocol.T_STRUCT then
              _str599#set_cf_def (read_cfDef iprot)
            else
              iprot#skip _t600)
          | _ -> iprot#skip _t600);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str599

class system_add_column_family_result =
object (self)
  val mutable _success : string option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "system_add_column_family_result.success") | Some _x602 -> _x602
  method set_success _x602 = _success <- Some _x602
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "system_add_column_family_result.ire") | Some _x602 -> _x602
  method set_ire _x602 = _ire <- Some _x602
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_add_column_family_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRING,0);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_add_column_family_result (iprot : Protocol.t) =
  let _str605 = new system_add_column_family_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t606,_id607) = iprot#readFieldBegin in
        if _t606 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id607 with 
          | 0 -> (if _t606 = Protocol.T_STRING then
              _str605#set_success iprot#readString
            else
              iprot#skip _t606)
          | 1 -> (if _t606 = Protocol.T_STRUCT then
              _str605#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t606)
          | _ -> iprot#skip _t606);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str605

class system_drop_column_family_args =
object (self)
  val mutable _column_family : string option = None
  method get_column_family = _column_family
  method grab_column_family = match _column_family with None->raise (Field_empty "system_drop_column_family_args.column_family") | Some _x608 -> _x608
  method set_column_family _x608 = _column_family <- Some _x608
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_drop_column_family_args";
    (match _column_family with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_family",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_drop_column_family_args (iprot : Protocol.t) =
  let _str611 = new system_drop_column_family_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t612,_id613) = iprot#readFieldBegin in
        if _t612 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id613 with 
          | 1 -> (if _t612 = Protocol.T_STRING then
              _str611#set_column_family iprot#readString
            else
              iprot#skip _t612)
          | _ -> iprot#skip _t612);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str611

class system_drop_column_family_result =
object (self)
  val mutable _success : string option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "system_drop_column_family_result.success") | Some _x614 -> _x614
  method set_success _x614 = _success <- Some _x614
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "system_drop_column_family_result.ire") | Some _x614 -> _x614
  method set_ire _x614 = _ire <- Some _x614
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_drop_column_family_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRING,0);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_drop_column_family_result (iprot : Protocol.t) =
  let _str617 = new system_drop_column_family_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t618,_id619) = iprot#readFieldBegin in
        if _t618 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id619 with 
          | 0 -> (if _t618 = Protocol.T_STRING then
              _str617#set_success iprot#readString
            else
              iprot#skip _t618)
          | 1 -> (if _t618 = Protocol.T_STRUCT then
              _str617#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t618)
          | _ -> iprot#skip _t618);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str617

class system_rename_column_family_args =
object (self)
  val mutable _old_name : string option = None
  method get_old_name = _old_name
  method grab_old_name = match _old_name with None->raise (Field_empty "system_rename_column_family_args.old_name") | Some _x620 -> _x620
  method set_old_name _x620 = _old_name <- Some _x620
  val mutable _new_name : string option = None
  method get_new_name = _new_name
  method grab_new_name = match _new_name with None->raise (Field_empty "system_rename_column_family_args.new_name") | Some _x620 -> _x620
  method set_new_name _x620 = _new_name <- Some _x620
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_rename_column_family_args";
    (match _old_name with None -> () | Some _v -> 
      oprot#writeFieldBegin("old_name",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _new_name with None -> () | Some _v -> 
      oprot#writeFieldBegin("new_name",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_rename_column_family_args (iprot : Protocol.t) =
  let _str623 = new system_rename_column_family_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t624,_id625) = iprot#readFieldBegin in
        if _t624 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id625 with 
          | 1 -> (if _t624 = Protocol.T_STRING then
              _str623#set_old_name iprot#readString
            else
              iprot#skip _t624)
          | 2 -> (if _t624 = Protocol.T_STRING then
              _str623#set_new_name iprot#readString
            else
              iprot#skip _t624)
          | _ -> iprot#skip _t624);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str623

class system_rename_column_family_result =
object (self)
  val mutable _success : string option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "system_rename_column_family_result.success") | Some _x626 -> _x626
  method set_success _x626 = _success <- Some _x626
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "system_rename_column_family_result.ire") | Some _x626 -> _x626
  method set_ire _x626 = _ire <- Some _x626
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_rename_column_family_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRING,0);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_rename_column_family_result (iprot : Protocol.t) =
  let _str629 = new system_rename_column_family_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t630,_id631) = iprot#readFieldBegin in
        if _t630 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id631 with 
          | 0 -> (if _t630 = Protocol.T_STRING then
              _str629#set_success iprot#readString
            else
              iprot#skip _t630)
          | 1 -> (if _t630 = Protocol.T_STRUCT then
              _str629#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t630)
          | _ -> iprot#skip _t630);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str629

class system_add_keyspace_args =
object (self)
  val mutable _ks_def : ksDef option = None
  method get_ks_def = _ks_def
  method grab_ks_def = match _ks_def with None->raise (Field_empty "system_add_keyspace_args.ks_def") | Some _x632 -> _x632
  method set_ks_def _x632 = _ks_def <- Some _x632
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_add_keyspace_args";
    (match _ks_def with None -> () | Some _v -> 
      oprot#writeFieldBegin("ks_def",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_add_keyspace_args (iprot : Protocol.t) =
  let _str635 = new system_add_keyspace_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t636,_id637) = iprot#readFieldBegin in
        if _t636 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id637 with 
          | 1 -> (if _t636 = Protocol.T_STRUCT then
              _str635#set_ks_def (read_ksDef iprot)
            else
              iprot#skip _t636)
          | _ -> iprot#skip _t636);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str635

class system_add_keyspace_result =
object (self)
  val mutable _success : string option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "system_add_keyspace_result.success") | Some _x638 -> _x638
  method set_success _x638 = _success <- Some _x638
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "system_add_keyspace_result.ire") | Some _x638 -> _x638
  method set_ire _x638 = _ire <- Some _x638
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_add_keyspace_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRING,0);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_add_keyspace_result (iprot : Protocol.t) =
  let _str641 = new system_add_keyspace_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t642,_id643) = iprot#readFieldBegin in
        if _t642 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id643 with 
          | 0 -> (if _t642 = Protocol.T_STRING then
              _str641#set_success iprot#readString
            else
              iprot#skip _t642)
          | 1 -> (if _t642 = Protocol.T_STRUCT then
              _str641#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t642)
          | _ -> iprot#skip _t642);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str641

class system_drop_keyspace_args =
object (self)
  val mutable _keyspace : string option = None
  method get_keyspace = _keyspace
  method grab_keyspace = match _keyspace with None->raise (Field_empty "system_drop_keyspace_args.keyspace") | Some _x644 -> _x644
  method set_keyspace _x644 = _keyspace <- Some _x644
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_drop_keyspace_args";
    (match _keyspace with None -> () | Some _v -> 
      oprot#writeFieldBegin("keyspace",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_drop_keyspace_args (iprot : Protocol.t) =
  let _str647 = new system_drop_keyspace_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t648,_id649) = iprot#readFieldBegin in
        if _t648 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id649 with 
          | 1 -> (if _t648 = Protocol.T_STRING then
              _str647#set_keyspace iprot#readString
            else
              iprot#skip _t648)
          | _ -> iprot#skip _t648);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str647

class system_drop_keyspace_result =
object (self)
  val mutable _success : string option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "system_drop_keyspace_result.success") | Some _x650 -> _x650
  method set_success _x650 = _success <- Some _x650
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "system_drop_keyspace_result.ire") | Some _x650 -> _x650
  method set_ire _x650 = _ire <- Some _x650
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_drop_keyspace_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRING,0);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_drop_keyspace_result (iprot : Protocol.t) =
  let _str653 = new system_drop_keyspace_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t654,_id655) = iprot#readFieldBegin in
        if _t654 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id655 with 
          | 0 -> (if _t654 = Protocol.T_STRING then
              _str653#set_success iprot#readString
            else
              iprot#skip _t654)
          | 1 -> (if _t654 = Protocol.T_STRUCT then
              _str653#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t654)
          | _ -> iprot#skip _t654);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str653

class system_rename_keyspace_args =
object (self)
  val mutable _old_name : string option = None
  method get_old_name = _old_name
  method grab_old_name = match _old_name with None->raise (Field_empty "system_rename_keyspace_args.old_name") | Some _x656 -> _x656
  method set_old_name _x656 = _old_name <- Some _x656
  val mutable _new_name : string option = None
  method get_new_name = _new_name
  method grab_new_name = match _new_name with None->raise (Field_empty "system_rename_keyspace_args.new_name") | Some _x656 -> _x656
  method set_new_name _x656 = _new_name <- Some _x656
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_rename_keyspace_args";
    (match _old_name with None -> () | Some _v -> 
      oprot#writeFieldBegin("old_name",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _new_name with None -> () | Some _v -> 
      oprot#writeFieldBegin("new_name",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_rename_keyspace_args (iprot : Protocol.t) =
  let _str659 = new system_rename_keyspace_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t660,_id661) = iprot#readFieldBegin in
        if _t660 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id661 with 
          | 1 -> (if _t660 = Protocol.T_STRING then
              _str659#set_old_name iprot#readString
            else
              iprot#skip _t660)
          | 2 -> (if _t660 = Protocol.T_STRING then
              _str659#set_new_name iprot#readString
            else
              iprot#skip _t660)
          | _ -> iprot#skip _t660);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str659

class system_rename_keyspace_result =
object (self)
  val mutable _success : string option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "system_rename_keyspace_result.success") | Some _x662 -> _x662
  method set_success _x662 = _success <- Some _x662
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "system_rename_keyspace_result.ire") | Some _x662 -> _x662
  method set_ire _x662 = _ire <- Some _x662
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_rename_keyspace_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRING,0);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_rename_keyspace_result (iprot : Protocol.t) =
  let _str665 = new system_rename_keyspace_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t666,_id667) = iprot#readFieldBegin in
        if _t666 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id667 with 
          | 0 -> (if _t666 = Protocol.T_STRING then
              _str665#set_success iprot#readString
            else
              iprot#skip _t666)
          | 1 -> (if _t666 = Protocol.T_STRUCT then
              _str665#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t666)
          | _ -> iprot#skip _t666);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str665

class system_update_keyspace_args =
object (self)
  val mutable _ks_def : ksDef option = None
  method get_ks_def = _ks_def
  method grab_ks_def = match _ks_def with None->raise (Field_empty "system_update_keyspace_args.ks_def") | Some _x668 -> _x668
  method set_ks_def _x668 = _ks_def <- Some _x668
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_update_keyspace_args";
    (match _ks_def with None -> () | Some _v -> 
      oprot#writeFieldBegin("ks_def",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_update_keyspace_args (iprot : Protocol.t) =
  let _str671 = new system_update_keyspace_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t672,_id673) = iprot#readFieldBegin in
        if _t672 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id673 with 
          | 1 -> (if _t672 = Protocol.T_STRUCT then
              _str671#set_ks_def (read_ksDef iprot)
            else
              iprot#skip _t672)
          | _ -> iprot#skip _t672);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str671

class system_update_keyspace_result =
object (self)
  val mutable _success : string option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "system_update_keyspace_result.success") | Some _x674 -> _x674
  method set_success _x674 = _success <- Some _x674
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "system_update_keyspace_result.ire") | Some _x674 -> _x674
  method set_ire _x674 = _ire <- Some _x674
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_update_keyspace_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRING,0);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_update_keyspace_result (iprot : Protocol.t) =
  let _str677 = new system_update_keyspace_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t678,_id679) = iprot#readFieldBegin in
        if _t678 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id679 with 
          | 0 -> (if _t678 = Protocol.T_STRING then
              _str677#set_success iprot#readString
            else
              iprot#skip _t678)
          | 1 -> (if _t678 = Protocol.T_STRUCT then
              _str677#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t678)
          | _ -> iprot#skip _t678);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str677

class system_update_column_family_args =
object (self)
  val mutable _cf_def : cfDef option = None
  method get_cf_def = _cf_def
  method grab_cf_def = match _cf_def with None->raise (Field_empty "system_update_column_family_args.cf_def") | Some _x680 -> _x680
  method set_cf_def _x680 = _cf_def <- Some _x680
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_update_column_family_args";
    (match _cf_def with None -> () | Some _v -> 
      oprot#writeFieldBegin("cf_def",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_update_column_family_args (iprot : Protocol.t) =
  let _str683 = new system_update_column_family_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t684,_id685) = iprot#readFieldBegin in
        if _t684 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id685 with 
          | 1 -> (if _t684 = Protocol.T_STRUCT then
              _str683#set_cf_def (read_cfDef iprot)
            else
              iprot#skip _t684)
          | _ -> iprot#skip _t684);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str683

class system_update_column_family_result =
object (self)
  val mutable _success : string option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "system_update_column_family_result.success") | Some _x686 -> _x686
  method set_success _x686 = _success <- Some _x686
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "system_update_column_family_result.ire") | Some _x686 -> _x686
  method set_ire _x686 = _ire <- Some _x686
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_update_column_family_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRING,0);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_update_column_family_result (iprot : Protocol.t) =
  let _str689 = new system_update_column_family_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t690,_id691) = iprot#readFieldBegin in
        if _t690 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id691 with 
          | 0 -> (if _t690 = Protocol.T_STRING then
              _str689#set_success iprot#readString
            else
              iprot#skip _t690)
          | 1 -> (if _t690 = Protocol.T_STRUCT then
              _str689#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t690)
          | _ -> iprot#skip _t690);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str689

class virtual iface =
object (self)
  method virtual login : authenticationRequest option -> unit
  method virtual set_keyspace : string option -> unit
  method virtual get : string option -> columnPath option -> ConsistencyLevel.t option -> columnOrSuperColumn
  method virtual get_slice : string option -> columnParent option -> slicePredicate option -> ConsistencyLevel.t option -> columnOrSuperColumn list
  method virtual get_count : string option -> columnParent option -> slicePredicate option -> ConsistencyLevel.t option -> int
  method virtual multiget_slice : string list option -> columnParent option -> slicePredicate option -> ConsistencyLevel.t option -> (string,columnOrSuperColumn list) Hashtbl.t
  method virtual multiget_count : string list option -> columnParent option -> slicePredicate option -> ConsistencyLevel.t option -> (string,int) Hashtbl.t
  method virtual get_range_slices : columnParent option -> slicePredicate option -> keyRange option -> ConsistencyLevel.t option -> keySlice list
  method virtual get_indexed_slices : columnParent option -> indexClause option -> slicePredicate option -> ConsistencyLevel.t option -> keySlice list
  method virtual insert : string option -> columnParent option -> column option -> ConsistencyLevel.t option -> unit
  method virtual remove : string option -> columnPath option -> Int64.t option -> ConsistencyLevel.t option -> unit
  method virtual batch_mutate : (string,(string,mutation list) Hashtbl.t) Hashtbl.t option -> ConsistencyLevel.t option -> unit
  method virtual truncate : string option -> unit
  method virtual describe_schema_versions : (string,string list) Hashtbl.t
  method virtual describe_keyspaces : ksDef list
  method virtual describe_cluster_name : string
  method virtual describe_version : string
  method virtual describe_ring : string option -> tokenRange list
  method virtual describe_partitioner : string
  method virtual describe_snitch : string
  method virtual describe_keyspace : string option -> ksDef
  method virtual describe_splits : string option -> string option -> string option -> int option -> string list
  method virtual system_add_column_family : cfDef option -> string
  method virtual system_drop_column_family : string option -> string
  method virtual system_rename_column_family : string option -> string option -> string
  method virtual system_add_keyspace : ksDef option -> string
  method virtual system_drop_keyspace : string option -> string
  method virtual system_rename_keyspace : string option -> string option -> string
  method virtual system_update_keyspace : ksDef option -> string
  method virtual system_update_column_family : cfDef option -> string
end

class client (iprot : Protocol.t) (oprot : Protocol.t) =
object (self)
  val mutable seqid = 0
  method login auth_request = 
    self#send_login auth_request;
    self#recv_login
  method private send_login auth_request = 
    oprot#writeMessageBegin ("login", Protocol.CALL, seqid);
    let args = new login_args in
      args#set_auth_request auth_request;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_login  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_login_result iprot in
        iprot#readMessageEnd;
        (match result#get_authnx with None -> () | Some _v ->
          raise (AuthenticationException _v));
        (match result#get_authzx with None -> () | Some _v ->
          raise (AuthorizationException _v));
        ()
  method set_keyspace keyspace = 
    self#send_set_keyspace keyspace;
    self#recv_set_keyspace
  method private send_set_keyspace keyspace = 
    oprot#writeMessageBegin ("set_keyspace", Protocol.CALL, seqid);
    let args = new set_keyspace_args in
      args#set_keyspace keyspace;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_set_keyspace  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_set_keyspace_result iprot in
        iprot#readMessageEnd;
        (match result#get_ire with None -> () | Some _v ->
          raise (InvalidRequestException _v));
        ()
  method get key column_path consistency_level = 
    self#send_get key column_path consistency_level;
    self#recv_get
  method private send_get key column_path consistency_level = 
    oprot#writeMessageBegin ("get", Protocol.CALL, seqid);
    let args = new get_args in
      args#set_key key;
      args#set_column_path column_path;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_get  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_get_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_nfe with None -> () | Some _v ->
            raise (NotFoundException _v));
          (match result#get_ue with None -> () | Some _v ->
            raise (UnavailableException _v));
          (match result#get_te with None -> () | Some _v ->
            raise (TimedOutException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "get failed: unknown result")))
  method get_slice key column_parent predicate consistency_level = 
    self#send_get_slice key column_parent predicate consistency_level;
    self#recv_get_slice
  method private send_get_slice key column_parent predicate consistency_level = 
    oprot#writeMessageBegin ("get_slice", Protocol.CALL, seqid);
    let args = new get_slice_args in
      args#set_key key;
      args#set_column_parent column_parent;
      args#set_predicate predicate;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_get_slice  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_get_slice_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_ue with None -> () | Some _v ->
            raise (UnavailableException _v));
          (match result#get_te with None -> () | Some _v ->
            raise (TimedOutException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "get_slice failed: unknown result")))
  method get_count key column_parent predicate consistency_level = 
    self#send_get_count key column_parent predicate consistency_level;
    self#recv_get_count
  method private send_get_count key column_parent predicate consistency_level = 
    oprot#writeMessageBegin ("get_count", Protocol.CALL, seqid);
    let args = new get_count_args in
      args#set_key key;
      args#set_column_parent column_parent;
      args#set_predicate predicate;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_get_count  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_get_count_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_ue with None -> () | Some _v ->
            raise (UnavailableException _v));
          (match result#get_te with None -> () | Some _v ->
            raise (TimedOutException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "get_count failed: unknown result")))
  method multiget_slice keys column_parent predicate consistency_level = 
    self#send_multiget_slice keys column_parent predicate consistency_level;
    self#recv_multiget_slice
  method private send_multiget_slice keys column_parent predicate consistency_level = 
    oprot#writeMessageBegin ("multiget_slice", Protocol.CALL, seqid);
    let args = new multiget_slice_args in
      args#set_keys keys;
      args#set_column_parent column_parent;
      args#set_predicate predicate;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_multiget_slice  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_multiget_slice_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_ue with None -> () | Some _v ->
            raise (UnavailableException _v));
          (match result#get_te with None -> () | Some _v ->
            raise (TimedOutException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "multiget_slice failed: unknown result")))
  method multiget_count keys column_parent predicate consistency_level = 
    self#send_multiget_count keys column_parent predicate consistency_level;
    self#recv_multiget_count
  method private send_multiget_count keys column_parent predicate consistency_level = 
    oprot#writeMessageBegin ("multiget_count", Protocol.CALL, seqid);
    let args = new multiget_count_args in
      args#set_keys keys;
      args#set_column_parent column_parent;
      args#set_predicate predicate;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_multiget_count  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_multiget_count_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_ue with None -> () | Some _v ->
            raise (UnavailableException _v));
          (match result#get_te with None -> () | Some _v ->
            raise (TimedOutException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "multiget_count failed: unknown result")))
  method get_range_slices column_parent predicate range consistency_level = 
    self#send_get_range_slices column_parent predicate range consistency_level;
    self#recv_get_range_slices
  method private send_get_range_slices column_parent predicate range consistency_level = 
    oprot#writeMessageBegin ("get_range_slices", Protocol.CALL, seqid);
    let args = new get_range_slices_args in
      args#set_column_parent column_parent;
      args#set_predicate predicate;
      args#set_range range;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_get_range_slices  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_get_range_slices_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_ue with None -> () | Some _v ->
            raise (UnavailableException _v));
          (match result#get_te with None -> () | Some _v ->
            raise (TimedOutException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "get_range_slices failed: unknown result")))
  method get_indexed_slices column_parent index_clause column_predicate consistency_level = 
    self#send_get_indexed_slices column_parent index_clause column_predicate consistency_level;
    self#recv_get_indexed_slices
  method private send_get_indexed_slices column_parent index_clause column_predicate consistency_level = 
    oprot#writeMessageBegin ("get_indexed_slices", Protocol.CALL, seqid);
    let args = new get_indexed_slices_args in
      args#set_column_parent column_parent;
      args#set_index_clause index_clause;
      args#set_column_predicate column_predicate;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_get_indexed_slices  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_get_indexed_slices_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_ue with None -> () | Some _v ->
            raise (UnavailableException _v));
          (match result#get_te with None -> () | Some _v ->
            raise (TimedOutException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "get_indexed_slices failed: unknown result")))
  method insert key column_parent column consistency_level = 
    self#send_insert key column_parent column consistency_level;
    self#recv_insert
  method private send_insert key column_parent column consistency_level = 
    oprot#writeMessageBegin ("insert", Protocol.CALL, seqid);
    let args = new insert_args in
      args#set_key key;
      args#set_column_parent column_parent;
      args#set_column column;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_insert  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_insert_result iprot in
        iprot#readMessageEnd;
        (match result#get_ire with None -> () | Some _v ->
          raise (InvalidRequestException _v));
        (match result#get_ue with None -> () | Some _v ->
          raise (UnavailableException _v));
        (match result#get_te with None -> () | Some _v ->
          raise (TimedOutException _v));
        ()
  method remove key column_path timestamp consistency_level = 
    self#send_remove key column_path timestamp consistency_level;
    self#recv_remove
  method private send_remove key column_path timestamp consistency_level = 
    oprot#writeMessageBegin ("remove", Protocol.CALL, seqid);
    let args = new remove_args in
      args#set_key key;
      args#set_column_path column_path;
      args#set_timestamp timestamp;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_remove  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_remove_result iprot in
        iprot#readMessageEnd;
        (match result#get_ire with None -> () | Some _v ->
          raise (InvalidRequestException _v));
        (match result#get_ue with None -> () | Some _v ->
          raise (UnavailableException _v));
        (match result#get_te with None -> () | Some _v ->
          raise (TimedOutException _v));
        ()
  method batch_mutate mutation_map consistency_level = 
    self#send_batch_mutate mutation_map consistency_level;
    self#recv_batch_mutate
  method private send_batch_mutate mutation_map consistency_level = 
    oprot#writeMessageBegin ("batch_mutate", Protocol.CALL, seqid);
    let args = new batch_mutate_args in
      args#set_mutation_map mutation_map;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_batch_mutate  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_batch_mutate_result iprot in
        iprot#readMessageEnd;
        (match result#get_ire with None -> () | Some _v ->
          raise (InvalidRequestException _v));
        (match result#get_ue with None -> () | Some _v ->
          raise (UnavailableException _v));
        (match result#get_te with None -> () | Some _v ->
          raise (TimedOutException _v));
        ()
  method truncate cfname = 
    self#send_truncate cfname;
    self#recv_truncate
  method private send_truncate cfname = 
    oprot#writeMessageBegin ("truncate", Protocol.CALL, seqid);
    let args = new truncate_args in
      args#set_cfname cfname;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_truncate  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_truncate_result iprot in
        iprot#readMessageEnd;
        (match result#get_ire with None -> () | Some _v ->
          raise (InvalidRequestException _v));
        (match result#get_ue with None -> () | Some _v ->
          raise (UnavailableException _v));
        ()
  method describe_schema_versions  = 
    self#send_describe_schema_versions;
    self#recv_describe_schema_versions
  method private send_describe_schema_versions  = 
    oprot#writeMessageBegin ("describe_schema_versions", Protocol.CALL, seqid);
    let args = new describe_schema_versions_args in
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_describe_schema_versions  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_describe_schema_versions_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "describe_schema_versions failed: unknown result")))
  method describe_keyspaces  = 
    self#send_describe_keyspaces;
    self#recv_describe_keyspaces
  method private send_describe_keyspaces  = 
    oprot#writeMessageBegin ("describe_keyspaces", Protocol.CALL, seqid);
    let args = new describe_keyspaces_args in
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_describe_keyspaces  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_describe_keyspaces_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "describe_keyspaces failed: unknown result")))
  method describe_cluster_name  = 
    self#send_describe_cluster_name;
    self#recv_describe_cluster_name
  method private send_describe_cluster_name  = 
    oprot#writeMessageBegin ("describe_cluster_name", Protocol.CALL, seqid);
    let args = new describe_cluster_name_args in
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_describe_cluster_name  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_describe_cluster_name_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "describe_cluster_name failed: unknown result")))
  method describe_version  = 
    self#send_describe_version;
    self#recv_describe_version
  method private send_describe_version  = 
    oprot#writeMessageBegin ("describe_version", Protocol.CALL, seqid);
    let args = new describe_version_args in
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_describe_version  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_describe_version_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "describe_version failed: unknown result")))
  method describe_ring keyspace = 
    self#send_describe_ring keyspace;
    self#recv_describe_ring
  method private send_describe_ring keyspace = 
    oprot#writeMessageBegin ("describe_ring", Protocol.CALL, seqid);
    let args = new describe_ring_args in
      args#set_keyspace keyspace;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_describe_ring  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_describe_ring_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "describe_ring failed: unknown result")))
  method describe_partitioner  = 
    self#send_describe_partitioner;
    self#recv_describe_partitioner
  method private send_describe_partitioner  = 
    oprot#writeMessageBegin ("describe_partitioner", Protocol.CALL, seqid);
    let args = new describe_partitioner_args in
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_describe_partitioner  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_describe_partitioner_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "describe_partitioner failed: unknown result")))
  method describe_snitch  = 
    self#send_describe_snitch;
    self#recv_describe_snitch
  method private send_describe_snitch  = 
    oprot#writeMessageBegin ("describe_snitch", Protocol.CALL, seqid);
    let args = new describe_snitch_args in
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_describe_snitch  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_describe_snitch_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "describe_snitch failed: unknown result")))
  method describe_keyspace keyspace = 
    self#send_describe_keyspace keyspace;
    self#recv_describe_keyspace
  method private send_describe_keyspace keyspace = 
    oprot#writeMessageBegin ("describe_keyspace", Protocol.CALL, seqid);
    let args = new describe_keyspace_args in
      args#set_keyspace keyspace;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_describe_keyspace  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_describe_keyspace_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_nfe with None -> () | Some _v ->
            raise (NotFoundException _v));
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "describe_keyspace failed: unknown result")))
  method describe_splits cfName start_token end_token keys_per_split = 
    self#send_describe_splits cfName start_token end_token keys_per_split;
    self#recv_describe_splits
  method private send_describe_splits cfName start_token end_token keys_per_split = 
    oprot#writeMessageBegin ("describe_splits", Protocol.CALL, seqid);
    let args = new describe_splits_args in
      args#set_cfName cfName;
      args#set_start_token start_token;
      args#set_end_token end_token;
      args#set_keys_per_split keys_per_split;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_describe_splits  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_describe_splits_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "describe_splits failed: unknown result")))
  method system_add_column_family cf_def = 
    self#send_system_add_column_family cf_def;
    self#recv_system_add_column_family
  method private send_system_add_column_family cf_def = 
    oprot#writeMessageBegin ("system_add_column_family", Protocol.CALL, seqid);
    let args = new system_add_column_family_args in
      args#set_cf_def cf_def;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_system_add_column_family  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_system_add_column_family_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "system_add_column_family failed: unknown result")))
  method system_drop_column_family column_family = 
    self#send_system_drop_column_family column_family;
    self#recv_system_drop_column_family
  method private send_system_drop_column_family column_family = 
    oprot#writeMessageBegin ("system_drop_column_family", Protocol.CALL, seqid);
    let args = new system_drop_column_family_args in
      args#set_column_family column_family;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_system_drop_column_family  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_system_drop_column_family_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "system_drop_column_family failed: unknown result")))
  method system_rename_column_family old_name new_name = 
    self#send_system_rename_column_family old_name new_name;
    self#recv_system_rename_column_family
  method private send_system_rename_column_family old_name new_name = 
    oprot#writeMessageBegin ("system_rename_column_family", Protocol.CALL, seqid);
    let args = new system_rename_column_family_args in
      args#set_old_name old_name;
      args#set_new_name new_name;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_system_rename_column_family  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_system_rename_column_family_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "system_rename_column_family failed: unknown result")))
  method system_add_keyspace ks_def = 
    self#send_system_add_keyspace ks_def;
    self#recv_system_add_keyspace
  method private send_system_add_keyspace ks_def = 
    oprot#writeMessageBegin ("system_add_keyspace", Protocol.CALL, seqid);
    let args = new system_add_keyspace_args in
      args#set_ks_def ks_def;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_system_add_keyspace  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_system_add_keyspace_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "system_add_keyspace failed: unknown result")))
  method system_drop_keyspace keyspace = 
    self#send_system_drop_keyspace keyspace;
    self#recv_system_drop_keyspace
  method private send_system_drop_keyspace keyspace = 
    oprot#writeMessageBegin ("system_drop_keyspace", Protocol.CALL, seqid);
    let args = new system_drop_keyspace_args in
      args#set_keyspace keyspace;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_system_drop_keyspace  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_system_drop_keyspace_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "system_drop_keyspace failed: unknown result")))
  method system_rename_keyspace old_name new_name = 
    self#send_system_rename_keyspace old_name new_name;
    self#recv_system_rename_keyspace
  method private send_system_rename_keyspace old_name new_name = 
    oprot#writeMessageBegin ("system_rename_keyspace", Protocol.CALL, seqid);
    let args = new system_rename_keyspace_args in
      args#set_old_name old_name;
      args#set_new_name new_name;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_system_rename_keyspace  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_system_rename_keyspace_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "system_rename_keyspace failed: unknown result")))
  method system_update_keyspace ks_def = 
    self#send_system_update_keyspace ks_def;
    self#recv_system_update_keyspace
  method private send_system_update_keyspace ks_def = 
    oprot#writeMessageBegin ("system_update_keyspace", Protocol.CALL, seqid);
    let args = new system_update_keyspace_args in
      args#set_ks_def ks_def;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_system_update_keyspace  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_system_update_keyspace_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "system_update_keyspace failed: unknown result")))
  method system_update_column_family cf_def = 
    self#send_system_update_column_family cf_def;
    self#recv_system_update_column_family
  method private send_system_update_column_family cf_def = 
    oprot#writeMessageBegin ("system_update_column_family", Protocol.CALL, seqid);
    let args = new system_update_column_family_args in
      args#set_cf_def cf_def;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_system_update_column_family  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_system_update_column_family_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "system_update_column_family failed: unknown result")))
end

class processor (handler : iface) =
object (self)
  inherit Processor.t

  val processMap = Hashtbl.create 30
  method process iprot oprot =
    let (name, typ, seqid)  = iprot#readMessageBegin in
      if Hashtbl.mem processMap name then
        (Hashtbl.find processMap name) (seqid, iprot, oprot)
      else (
        iprot#skip(Protocol.T_STRUCT);
        iprot#readMessageEnd;
        let x = Application_Exn.create Application_Exn.UNKNOWN_METHOD ("Unknown function "^name) in
          oprot#writeMessageBegin(name, Protocol.EXCEPTION, seqid);
          x#write oprot;
          oprot#writeMessageEnd;
          oprot#getTransport#flush
      );
      true
  method private process_login (seqid, iprot, oprot) =
    let args = read_login_args iprot in
      iprot#readMessageEnd;
      let result = new login_result in
        (try
          (handler#login args#get_auth_request);
        with
          | AuthenticationException authnx -> 
              result#set_authnx authnx
          | AuthorizationException authzx -> 
              result#set_authzx authzx
        );
        oprot#writeMessageBegin ("login", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_set_keyspace (seqid, iprot, oprot) =
    let args = read_set_keyspace_args iprot in
      iprot#readMessageEnd;
      let result = new set_keyspace_result in
        (try
          (handler#set_keyspace args#get_keyspace);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
        );
        oprot#writeMessageBegin ("set_keyspace", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_get (seqid, iprot, oprot) =
    let args = read_get_args iprot in
      iprot#readMessageEnd;
      let result = new get_result in
        (try
          result#set_success (handler#get args#get_key args#get_column_path args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | NotFoundException nfe -> 
              result#set_nfe nfe
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("get", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_get_slice (seqid, iprot, oprot) =
    let args = read_get_slice_args iprot in
      iprot#readMessageEnd;
      let result = new get_slice_result in
        (try
          result#set_success (handler#get_slice args#get_key args#get_column_parent args#get_predicate args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("get_slice", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_get_count (seqid, iprot, oprot) =
    let args = read_get_count_args iprot in
      iprot#readMessageEnd;
      let result = new get_count_result in
        (try
          result#set_success (handler#get_count args#get_key args#get_column_parent args#get_predicate args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("get_count", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_multiget_slice (seqid, iprot, oprot) =
    let args = read_multiget_slice_args iprot in
      iprot#readMessageEnd;
      let result = new multiget_slice_result in
        (try
          result#set_success (handler#multiget_slice args#get_keys args#get_column_parent args#get_predicate args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("multiget_slice", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_multiget_count (seqid, iprot, oprot) =
    let args = read_multiget_count_args iprot in
      iprot#readMessageEnd;
      let result = new multiget_count_result in
        (try
          result#set_success (handler#multiget_count args#get_keys args#get_column_parent args#get_predicate args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("multiget_count", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_get_range_slices (seqid, iprot, oprot) =
    let args = read_get_range_slices_args iprot in
      iprot#readMessageEnd;
      let result = new get_range_slices_result in
        (try
          result#set_success (handler#get_range_slices args#get_column_parent args#get_predicate args#get_range args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("get_range_slices", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_get_indexed_slices (seqid, iprot, oprot) =
    let args = read_get_indexed_slices_args iprot in
      iprot#readMessageEnd;
      let result = new get_indexed_slices_result in
        (try
          result#set_success (handler#get_indexed_slices args#get_column_parent args#get_index_clause args#get_column_predicate args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("get_indexed_slices", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_insert (seqid, iprot, oprot) =
    let args = read_insert_args iprot in
      iprot#readMessageEnd;
      let result = new insert_result in
        (try
          (handler#insert args#get_key args#get_column_parent args#get_column args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("insert", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_remove (seqid, iprot, oprot) =
    let args = read_remove_args iprot in
      iprot#readMessageEnd;
      let result = new remove_result in
        (try
          (handler#remove args#get_key args#get_column_path args#get_timestamp args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("remove", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_batch_mutate (seqid, iprot, oprot) =
    let args = read_batch_mutate_args iprot in
      iprot#readMessageEnd;
      let result = new batch_mutate_result in
        (try
          (handler#batch_mutate args#get_mutation_map args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("batch_mutate", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_truncate (seqid, iprot, oprot) =
    let args = read_truncate_args iprot in
      iprot#readMessageEnd;
      let result = new truncate_result in
        (try
          (handler#truncate args#get_cfname);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
        );
        oprot#writeMessageBegin ("truncate", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_describe_schema_versions (seqid, iprot, oprot) =
    let _ = read_describe_schema_versions_args iprot in
      iprot#readMessageEnd;
      let result = new describe_schema_versions_result in
        (try
          result#set_success (handler#describe_schema_versions);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
        );
        oprot#writeMessageBegin ("describe_schema_versions", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_describe_keyspaces (seqid, iprot, oprot) =
    let _ = read_describe_keyspaces_args iprot in
      iprot#readMessageEnd;
      let result = new describe_keyspaces_result in
        (try
          result#set_success (handler#describe_keyspaces);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
        );
        oprot#writeMessageBegin ("describe_keyspaces", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_describe_cluster_name (seqid, iprot, oprot) =
    let _ = read_describe_cluster_name_args iprot in
      iprot#readMessageEnd;
      let result = new describe_cluster_name_result in
        result#set_success (handler#describe_cluster_name);
        oprot#writeMessageBegin ("describe_cluster_name", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_describe_version (seqid, iprot, oprot) =
    let _ = read_describe_version_args iprot in
      iprot#readMessageEnd;
      let result = new describe_version_result in
        result#set_success (handler#describe_version);
        oprot#writeMessageBegin ("describe_version", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_describe_ring (seqid, iprot, oprot) =
    let args = read_describe_ring_args iprot in
      iprot#readMessageEnd;
      let result = new describe_ring_result in
        (try
          result#set_success (handler#describe_ring args#get_keyspace);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
        );
        oprot#writeMessageBegin ("describe_ring", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_describe_partitioner (seqid, iprot, oprot) =
    let _ = read_describe_partitioner_args iprot in
      iprot#readMessageEnd;
      let result = new describe_partitioner_result in
        result#set_success (handler#describe_partitioner);
        oprot#writeMessageBegin ("describe_partitioner", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_describe_snitch (seqid, iprot, oprot) =
    let _ = read_describe_snitch_args iprot in
      iprot#readMessageEnd;
      let result = new describe_snitch_result in
        result#set_success (handler#describe_snitch);
        oprot#writeMessageBegin ("describe_snitch", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_describe_keyspace (seqid, iprot, oprot) =
    let args = read_describe_keyspace_args iprot in
      iprot#readMessageEnd;
      let result = new describe_keyspace_result in
        (try
          result#set_success (handler#describe_keyspace args#get_keyspace);
        with
          | NotFoundException nfe -> 
              result#set_nfe nfe
          | InvalidRequestException ire -> 
              result#set_ire ire
        );
        oprot#writeMessageBegin ("describe_keyspace", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_describe_splits (seqid, iprot, oprot) =
    let args = read_describe_splits_args iprot in
      iprot#readMessageEnd;
      let result = new describe_splits_result in
        result#set_success (handler#describe_splits args#get_cfName args#get_start_token args#get_end_token args#get_keys_per_split);
        oprot#writeMessageBegin ("describe_splits", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_system_add_column_family (seqid, iprot, oprot) =
    let args = read_system_add_column_family_args iprot in
      iprot#readMessageEnd;
      let result = new system_add_column_family_result in
        (try
          result#set_success (handler#system_add_column_family args#get_cf_def);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
        );
        oprot#writeMessageBegin ("system_add_column_family", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_system_drop_column_family (seqid, iprot, oprot) =
    let args = read_system_drop_column_family_args iprot in
      iprot#readMessageEnd;
      let result = new system_drop_column_family_result in
        (try
          result#set_success (handler#system_drop_column_family args#get_column_family);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
        );
        oprot#writeMessageBegin ("system_drop_column_family", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_system_rename_column_family (seqid, iprot, oprot) =
    let args = read_system_rename_column_family_args iprot in
      iprot#readMessageEnd;
      let result = new system_rename_column_family_result in
        (try
          result#set_success (handler#system_rename_column_family args#get_old_name args#get_new_name);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
        );
        oprot#writeMessageBegin ("system_rename_column_family", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_system_add_keyspace (seqid, iprot, oprot) =
    let args = read_system_add_keyspace_args iprot in
      iprot#readMessageEnd;
      let result = new system_add_keyspace_result in
        (try
          result#set_success (handler#system_add_keyspace args#get_ks_def);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
        );
        oprot#writeMessageBegin ("system_add_keyspace", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_system_drop_keyspace (seqid, iprot, oprot) =
    let args = read_system_drop_keyspace_args iprot in
      iprot#readMessageEnd;
      let result = new system_drop_keyspace_result in
        (try
          result#set_success (handler#system_drop_keyspace args#get_keyspace);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
        );
        oprot#writeMessageBegin ("system_drop_keyspace", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_system_rename_keyspace (seqid, iprot, oprot) =
    let args = read_system_rename_keyspace_args iprot in
      iprot#readMessageEnd;
      let result = new system_rename_keyspace_result in
        (try
          result#set_success (handler#system_rename_keyspace args#get_old_name args#get_new_name);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
        );
        oprot#writeMessageBegin ("system_rename_keyspace", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_system_update_keyspace (seqid, iprot, oprot) =
    let args = read_system_update_keyspace_args iprot in
      iprot#readMessageEnd;
      let result = new system_update_keyspace_result in
        (try
          result#set_success (handler#system_update_keyspace args#get_ks_def);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
        );
        oprot#writeMessageBegin ("system_update_keyspace", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_system_update_column_family (seqid, iprot, oprot) =
    let args = read_system_update_column_family_args iprot in
      iprot#readMessageEnd;
      let result = new system_update_column_family_result in
        (try
          result#set_success (handler#system_update_column_family args#get_cf_def);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
        );
        oprot#writeMessageBegin ("system_update_column_family", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  initializer
    Hashtbl.add processMap "login" self#process_login;
    Hashtbl.add processMap "set_keyspace" self#process_set_keyspace;
    Hashtbl.add processMap "get" self#process_get;
    Hashtbl.add processMap "get_slice" self#process_get_slice;
    Hashtbl.add processMap "get_count" self#process_get_count;
    Hashtbl.add processMap "multiget_slice" self#process_multiget_slice;
    Hashtbl.add processMap "multiget_count" self#process_multiget_count;
    Hashtbl.add processMap "get_range_slices" self#process_get_range_slices;
    Hashtbl.add processMap "get_indexed_slices" self#process_get_indexed_slices;
    Hashtbl.add processMap "insert" self#process_insert;
    Hashtbl.add processMap "remove" self#process_remove;
    Hashtbl.add processMap "batch_mutate" self#process_batch_mutate;
    Hashtbl.add processMap "truncate" self#process_truncate;
    Hashtbl.add processMap "describe_schema_versions" self#process_describe_schema_versions;
    Hashtbl.add processMap "describe_keyspaces" self#process_describe_keyspaces;
    Hashtbl.add processMap "describe_cluster_name" self#process_describe_cluster_name;
    Hashtbl.add processMap "describe_version" self#process_describe_version;
    Hashtbl.add processMap "describe_ring" self#process_describe_ring;
    Hashtbl.add processMap "describe_partitioner" self#process_describe_partitioner;
    Hashtbl.add processMap "describe_snitch" self#process_describe_snitch;
    Hashtbl.add processMap "describe_keyspace" self#process_describe_keyspace;
    Hashtbl.add processMap "describe_splits" self#process_describe_splits;
    Hashtbl.add processMap "system_add_column_family" self#process_system_add_column_family;
    Hashtbl.add processMap "system_drop_column_family" self#process_system_drop_column_family;
    Hashtbl.add processMap "system_rename_column_family" self#process_system_rename_column_family;
    Hashtbl.add processMap "system_add_keyspace" self#process_system_add_keyspace;
    Hashtbl.add processMap "system_drop_keyspace" self#process_system_drop_keyspace;
    Hashtbl.add processMap "system_rename_keyspace" self#process_system_rename_keyspace;
    Hashtbl.add processMap "system_update_keyspace" self#process_system_update_keyspace;
    Hashtbl.add processMap "system_update_column_family" self#process_system_update_column_family;
end

