(*
 Autogenerated by Thrift

 DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING
*)

open Thrift
open Cassandra_types

(* HELPER FUNCTIONS AND STRUCTURES *)

class login_args =
object (self)
  val mutable _keyspace : string option = None
  method get_keyspace = _keyspace
  method grab_keyspace = match _keyspace with None->raise (Field_empty "login_args.keyspace") | Some _x164 -> _x164
  method set_keyspace _x164 = _keyspace <- Some _x164
  val mutable _auth_request : authenticationRequest option = None
  method get_auth_request = _auth_request
  method grab_auth_request = match _auth_request with None->raise (Field_empty "login_args.auth_request") | Some _x164 -> _x164
  method set_auth_request _x164 = _auth_request <- Some _x164
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "login_args";
    (match _keyspace with None -> () | Some _v -> 
      oprot#writeFieldBegin("keyspace",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _auth_request with None -> () | Some _v -> 
      oprot#writeFieldBegin("auth_request",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_login_args (iprot : Protocol.t) =
  let _str167 = new login_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t168,_id169) = iprot#readFieldBegin in
        if _t168 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id169 with 
          | 1 -> (if _t168 = Protocol.T_STRING then
              _str167#set_keyspace iprot#readString
            else
              iprot#skip _t168)
          | 2 -> (if _t168 = Protocol.T_STRUCT then
              _str167#set_auth_request (read_authenticationRequest iprot)
            else
              iprot#skip _t168)
          | _ -> iprot#skip _t168);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str167

class login_result =
object (self)
  val mutable _authnx : authenticationException option = None
  method get_authnx = _authnx
  method grab_authnx = match _authnx with None->raise (Field_empty "login_result.authnx") | Some _x170 -> _x170
  method set_authnx _x170 = _authnx <- Some _x170
  val mutable _authzx : authorizationException option = None
  method get_authzx = _authzx
  method grab_authzx = match _authzx with None->raise (Field_empty "login_result.authzx") | Some _x170 -> _x170
  method set_authzx _x170 = _authzx <- Some _x170
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "login_result";
    (match _authnx with None -> () | Some _v -> 
      oprot#writeFieldBegin("authnx",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _authzx with None -> () | Some _v -> 
      oprot#writeFieldBegin("authzx",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_login_result (iprot : Protocol.t) =
  let _str173 = new login_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t174,_id175) = iprot#readFieldBegin in
        if _t174 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id175 with 
          | 1 -> (if _t174 = Protocol.T_STRUCT then
              _str173#set_authnx (read_authenticationException iprot)
            else
              iprot#skip _t174)
          | 2 -> (if _t174 = Protocol.T_STRUCT then
              _str173#set_authzx (read_authorizationException iprot)
            else
              iprot#skip _t174)
          | _ -> iprot#skip _t174);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str173

class get_args =
object (self)
  val mutable _keyspace : string option = None
  method get_keyspace = _keyspace
  method grab_keyspace = match _keyspace with None->raise (Field_empty "get_args.keyspace") | Some _x176 -> _x176
  method set_keyspace _x176 = _keyspace <- Some _x176
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "get_args.key") | Some _x176 -> _x176
  method set_key _x176 = _key <- Some _x176
  val mutable _column_path : columnPath option = None
  method get_column_path = _column_path
  method grab_column_path = match _column_path with None->raise (Field_empty "get_args.column_path") | Some _x176 -> _x176
  method set_column_path _x176 = _column_path <- Some _x176
  val mutable _consistency_level : ConsistencyLevel.t option = None
  method get_consistency_level = _consistency_level
  method grab_consistency_level = match _consistency_level with None->raise (Field_empty "get_args.consistency_level") | Some _x176 -> _x176
  method set_consistency_level _x176 = _consistency_level <- Some _x176
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_args";
    (match _keyspace with None -> () | Some _v -> 
      oprot#writeFieldBegin("keyspace",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _key with None -> () | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _column_path with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_path",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _consistency_level with None -> () | Some _v -> 
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,4);
      oprot#writeI32(ConsistencyLevel.to_i _v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_args (iprot : Protocol.t) =
  let _str179 = new get_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t180,_id181) = iprot#readFieldBegin in
        if _t180 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id181 with 
          | 1 -> (if _t180 = Protocol.T_STRING then
              _str179#set_keyspace iprot#readString
            else
              iprot#skip _t180)
          | 2 -> (if _t180 = Protocol.T_STRING then
              _str179#set_key iprot#readString
            else
              iprot#skip _t180)
          | 3 -> (if _t180 = Protocol.T_STRUCT then
              _str179#set_column_path (read_columnPath iprot)
            else
              iprot#skip _t180)
          | 4 -> (if _t180 = Protocol.T_I32 then
              _str179#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t180)
          | _ -> iprot#skip _t180);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str179

class get_result =
object (self)
  val mutable _success : columnOrSuperColumn option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "get_result.success") | Some _x182 -> _x182
  method set_success _x182 = _success <- Some _x182
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "get_result.ire") | Some _x182 -> _x182
  method set_ire _x182 = _ire <- Some _x182
  val mutable _nfe : notFoundException option = None
  method get_nfe = _nfe
  method grab_nfe = match _nfe with None->raise (Field_empty "get_result.nfe") | Some _x182 -> _x182
  method set_nfe _x182 = _nfe <- Some _x182
  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "get_result.ue") | Some _x182 -> _x182
  method set_ue _x182 = _ue <- Some _x182
  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "get_result.te") | Some _x182 -> _x182
  method set_te _x182 = _te <- Some _x182
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRUCT,0);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _nfe with None -> () | Some _v -> 
      oprot#writeFieldBegin("nfe",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,4);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_result (iprot : Protocol.t) =
  let _str185 = new get_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t186,_id187) = iprot#readFieldBegin in
        if _t186 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id187 with 
          | 0 -> (if _t186 = Protocol.T_STRUCT then
              _str185#set_success (read_columnOrSuperColumn iprot)
            else
              iprot#skip _t186)
          | 1 -> (if _t186 = Protocol.T_STRUCT then
              _str185#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t186)
          | 2 -> (if _t186 = Protocol.T_STRUCT then
              _str185#set_nfe (read_notFoundException iprot)
            else
              iprot#skip _t186)
          | 3 -> (if _t186 = Protocol.T_STRUCT then
              _str185#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t186)
          | 4 -> (if _t186 = Protocol.T_STRUCT then
              _str185#set_te (read_timedOutException iprot)
            else
              iprot#skip _t186)
          | _ -> iprot#skip _t186);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str185

class get_slice_args =
object (self)
  val mutable _keyspace : string option = None
  method get_keyspace = _keyspace
  method grab_keyspace = match _keyspace with None->raise (Field_empty "get_slice_args.keyspace") | Some _x188 -> _x188
  method set_keyspace _x188 = _keyspace <- Some _x188
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "get_slice_args.key") | Some _x188 -> _x188
  method set_key _x188 = _key <- Some _x188
  val mutable _column_parent : columnParent option = None
  method get_column_parent = _column_parent
  method grab_column_parent = match _column_parent with None->raise (Field_empty "get_slice_args.column_parent") | Some _x188 -> _x188
  method set_column_parent _x188 = _column_parent <- Some _x188
  val mutable _predicate : slicePredicate option = None
  method get_predicate = _predicate
  method grab_predicate = match _predicate with None->raise (Field_empty "get_slice_args.predicate") | Some _x188 -> _x188
  method set_predicate _x188 = _predicate <- Some _x188
  val mutable _consistency_level : ConsistencyLevel.t option = None
  method get_consistency_level = _consistency_level
  method grab_consistency_level = match _consistency_level with None->raise (Field_empty "get_slice_args.consistency_level") | Some _x188 -> _x188
  method set_consistency_level _x188 = _consistency_level <- Some _x188
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_slice_args";
    (match _keyspace with None -> () | Some _v -> 
      oprot#writeFieldBegin("keyspace",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _key with None -> () | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _column_parent with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_parent",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _predicate with None -> () | Some _v -> 
      oprot#writeFieldBegin("predicate",Protocol.T_STRUCT,4);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _consistency_level with None -> () | Some _v -> 
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,5);
      oprot#writeI32(ConsistencyLevel.to_i _v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_slice_args (iprot : Protocol.t) =
  let _str191 = new get_slice_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t192,_id193) = iprot#readFieldBegin in
        if _t192 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id193 with 
          | 1 -> (if _t192 = Protocol.T_STRING then
              _str191#set_keyspace iprot#readString
            else
              iprot#skip _t192)
          | 2 -> (if _t192 = Protocol.T_STRING then
              _str191#set_key iprot#readString
            else
              iprot#skip _t192)
          | 3 -> (if _t192 = Protocol.T_STRUCT then
              _str191#set_column_parent (read_columnParent iprot)
            else
              iprot#skip _t192)
          | 4 -> (if _t192 = Protocol.T_STRUCT then
              _str191#set_predicate (read_slicePredicate iprot)
            else
              iprot#skip _t192)
          | 5 -> (if _t192 = Protocol.T_I32 then
              _str191#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t192)
          | _ -> iprot#skip _t192);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str191

class get_slice_result =
object (self)
  val mutable _success : columnOrSuperColumn list option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "get_slice_result.success") | Some _x194 -> _x194
  method set_success _x194 = _success <- Some _x194
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "get_slice_result.ire") | Some _x194 -> _x194
  method set_ire _x194 = _ire <- Some _x194
  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "get_slice_result.ue") | Some _x194 -> _x194
  method set_ue _x194 = _ue <- Some _x194
  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "get_slice_result.te") | Some _x194 -> _x194
  method set_te _x194 = _te <- Some _x194
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_slice_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_LIST,0);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter197 ->         _iter197#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_slice_result (iprot : Protocol.t) =
  let _str198 = new get_slice_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t199,_id200) = iprot#readFieldBegin in
        if _t199 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id200 with 
          | 0 -> (if _t199 = Protocol.T_LIST then
              _str198#set_success 
                (let (_etype204,_size201) = iprot#readListBegin in
                  let _con205 = (Array.to_list (Array.init _size201 (fun _ -> (read_columnOrSuperColumn iprot)))) in
                    iprot#readListEnd; _con205)
            else
              iprot#skip _t199)
          | 1 -> (if _t199 = Protocol.T_STRUCT then
              _str198#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t199)
          | 2 -> (if _t199 = Protocol.T_STRUCT then
              _str198#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t199)
          | 3 -> (if _t199 = Protocol.T_STRUCT then
              _str198#set_te (read_timedOutException iprot)
            else
              iprot#skip _t199)
          | _ -> iprot#skip _t199);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str198

class multiget_args =
object (self)
  val mutable _keyspace : string option = None
  method get_keyspace = _keyspace
  method grab_keyspace = match _keyspace with None->raise (Field_empty "multiget_args.keyspace") | Some _x206 -> _x206
  method set_keyspace _x206 = _keyspace <- Some _x206
  val mutable _keys : string list option = None
  method get_keys = _keys
  method grab_keys = match _keys with None->raise (Field_empty "multiget_args.keys") | Some _x206 -> _x206
  method set_keys _x206 = _keys <- Some _x206
  val mutable _column_path : columnPath option = None
  method get_column_path = _column_path
  method grab_column_path = match _column_path with None->raise (Field_empty "multiget_args.column_path") | Some _x206 -> _x206
  method set_column_path _x206 = _column_path <- Some _x206
  val mutable _consistency_level : ConsistencyLevel.t option = None
  method get_consistency_level = _consistency_level
  method grab_consistency_level = match _consistency_level with None->raise (Field_empty "multiget_args.consistency_level") | Some _x206 -> _x206
  method set_consistency_level _x206 = _consistency_level <- Some _x206
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "multiget_args";
    (match _keyspace with None -> () | Some _v -> 
      oprot#writeFieldBegin("keyspace",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _keys with None -> () | Some _v -> 
      oprot#writeFieldBegin("keys",Protocol.T_LIST,2);
      oprot#writeListBegin(Protocol.T_STRING,List.length _v);
      List.iter (fun _iter209 ->         oprot#writeString(_iter209);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _column_path with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_path",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _consistency_level with None -> () | Some _v -> 
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,4);
      oprot#writeI32(ConsistencyLevel.to_i _v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_multiget_args (iprot : Protocol.t) =
  let _str210 = new multiget_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t211,_id212) = iprot#readFieldBegin in
        if _t211 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id212 with 
          | 1 -> (if _t211 = Protocol.T_STRING then
              _str210#set_keyspace iprot#readString
            else
              iprot#skip _t211)
          | 2 -> (if _t211 = Protocol.T_LIST then
              _str210#set_keys 
                (let (_etype216,_size213) = iprot#readListBegin in
                  let _con217 = (Array.to_list (Array.init _size213 (fun _ -> iprot#readString))) in
                    iprot#readListEnd; _con217)
            else
              iprot#skip _t211)
          | 3 -> (if _t211 = Protocol.T_STRUCT then
              _str210#set_column_path (read_columnPath iprot)
            else
              iprot#skip _t211)
          | 4 -> (if _t211 = Protocol.T_I32 then
              _str210#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t211)
          | _ -> iprot#skip _t211);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str210

class multiget_result =
object (self)
  val mutable _success : (string,columnOrSuperColumn) Hashtbl.t option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "multiget_result.success") | Some _x218 -> _x218
  method set_success _x218 = _success <- Some _x218
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "multiget_result.ire") | Some _x218 -> _x218
  method set_ire _x218 = _ire <- Some _x218
  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "multiget_result.ue") | Some _x218 -> _x218
  method set_ue _x218 = _ue <- Some _x218
  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "multiget_result.te") | Some _x218 -> _x218
  method set_te _x218 = _te <- Some _x218
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "multiget_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_MAP,0);
      oprot#writeMapBegin(Protocol.T_STRING,Protocol.T_STRUCT,Hashtbl.length _v);
      Hashtbl.iter (fun _kiter221 -> fun _viter222 -> 
        oprot#writeString(_kiter221);
        _viter222#write(oprot);
      ) _v;
      oprot#writeMapEnd;
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_multiget_result (iprot : Protocol.t) =
  let _str223 = new multiget_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t224,_id225) = iprot#readFieldBegin in
        if _t224 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id225 with 
          | 0 -> (if _t224 = Protocol.T_MAP then
              _str223#set_success 
                (let (_ktype227,_vtype228,_size226) = iprot#readMapBegin in
                let _con230 = Hashtbl.create _size226 in
                  for i = 1 to _size226 do
                    let _k = iprot#readString in
                    let _v = (read_columnOrSuperColumn iprot) in
                      Hashtbl.add _con230 _k _v
                  done; iprot#readMapEnd; _con230)
            else
              iprot#skip _t224)
          | 1 -> (if _t224 = Protocol.T_STRUCT then
              _str223#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t224)
          | 2 -> (if _t224 = Protocol.T_STRUCT then
              _str223#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t224)
          | 3 -> (if _t224 = Protocol.T_STRUCT then
              _str223#set_te (read_timedOutException iprot)
            else
              iprot#skip _t224)
          | _ -> iprot#skip _t224);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str223

class multiget_slice_args =
object (self)
  val mutable _keyspace : string option = None
  method get_keyspace = _keyspace
  method grab_keyspace = match _keyspace with None->raise (Field_empty "multiget_slice_args.keyspace") | Some _x231 -> _x231
  method set_keyspace _x231 = _keyspace <- Some _x231
  val mutable _keys : string list option = None
  method get_keys = _keys
  method grab_keys = match _keys with None->raise (Field_empty "multiget_slice_args.keys") | Some _x231 -> _x231
  method set_keys _x231 = _keys <- Some _x231
  val mutable _column_parent : columnParent option = None
  method get_column_parent = _column_parent
  method grab_column_parent = match _column_parent with None->raise (Field_empty "multiget_slice_args.column_parent") | Some _x231 -> _x231
  method set_column_parent _x231 = _column_parent <- Some _x231
  val mutable _predicate : slicePredicate option = None
  method get_predicate = _predicate
  method grab_predicate = match _predicate with None->raise (Field_empty "multiget_slice_args.predicate") | Some _x231 -> _x231
  method set_predicate _x231 = _predicate <- Some _x231
  val mutable _consistency_level : ConsistencyLevel.t option = None
  method get_consistency_level = _consistency_level
  method grab_consistency_level = match _consistency_level with None->raise (Field_empty "multiget_slice_args.consistency_level") | Some _x231 -> _x231
  method set_consistency_level _x231 = _consistency_level <- Some _x231
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "multiget_slice_args";
    (match _keyspace with None -> () | Some _v -> 
      oprot#writeFieldBegin("keyspace",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _keys with None -> () | Some _v -> 
      oprot#writeFieldBegin("keys",Protocol.T_LIST,2);
      oprot#writeListBegin(Protocol.T_STRING,List.length _v);
      List.iter (fun _iter234 ->         oprot#writeString(_iter234);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _column_parent with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_parent",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _predicate with None -> () | Some _v -> 
      oprot#writeFieldBegin("predicate",Protocol.T_STRUCT,4);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _consistency_level with None -> () | Some _v -> 
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,5);
      oprot#writeI32(ConsistencyLevel.to_i _v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_multiget_slice_args (iprot : Protocol.t) =
  let _str235 = new multiget_slice_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t236,_id237) = iprot#readFieldBegin in
        if _t236 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id237 with 
          | 1 -> (if _t236 = Protocol.T_STRING then
              _str235#set_keyspace iprot#readString
            else
              iprot#skip _t236)
          | 2 -> (if _t236 = Protocol.T_LIST then
              _str235#set_keys 
                (let (_etype241,_size238) = iprot#readListBegin in
                  let _con242 = (Array.to_list (Array.init _size238 (fun _ -> iprot#readString))) in
                    iprot#readListEnd; _con242)
            else
              iprot#skip _t236)
          | 3 -> (if _t236 = Protocol.T_STRUCT then
              _str235#set_column_parent (read_columnParent iprot)
            else
              iprot#skip _t236)
          | 4 -> (if _t236 = Protocol.T_STRUCT then
              _str235#set_predicate (read_slicePredicate iprot)
            else
              iprot#skip _t236)
          | 5 -> (if _t236 = Protocol.T_I32 then
              _str235#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t236)
          | _ -> iprot#skip _t236);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str235

class multiget_slice_result =
object (self)
  val mutable _success : (string,columnOrSuperColumn list) Hashtbl.t option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "multiget_slice_result.success") | Some _x243 -> _x243
  method set_success _x243 = _success <- Some _x243
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "multiget_slice_result.ire") | Some _x243 -> _x243
  method set_ire _x243 = _ire <- Some _x243
  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "multiget_slice_result.ue") | Some _x243 -> _x243
  method set_ue _x243 = _ue <- Some _x243
  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "multiget_slice_result.te") | Some _x243 -> _x243
  method set_te _x243 = _te <- Some _x243
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "multiget_slice_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_MAP,0);
      oprot#writeMapBegin(Protocol.T_STRING,Protocol.T_LIST,Hashtbl.length _v);
      Hashtbl.iter (fun _kiter246 -> fun _viter247 -> 
        oprot#writeString(_kiter246);
        oprot#writeListBegin(Protocol.T_STRUCT,List.length _viter247);
        List.iter (fun _iter248 ->           _iter248#write(oprot);
        ) _viter247;
        oprot#writeListEnd;
      ) _v;
      oprot#writeMapEnd;
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_multiget_slice_result (iprot : Protocol.t) =
  let _str249 = new multiget_slice_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t250,_id251) = iprot#readFieldBegin in
        if _t250 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id251 with 
          | 0 -> (if _t250 = Protocol.T_MAP then
              _str249#set_success 
                (let (_ktype253,_vtype254,_size252) = iprot#readMapBegin in
                let _con256 = Hashtbl.create _size252 in
                  for i = 1 to _size252 do
                    let _k = iprot#readString in
                    let _v = 
                      (let (_etype260,_size257) = iprot#readListBegin in
                        let _con261 = (Array.to_list (Array.init _size257 (fun _ -> (read_columnOrSuperColumn iprot)))) in
                          iprot#readListEnd; _con261) in
                      Hashtbl.add _con256 _k _v
                  done; iprot#readMapEnd; _con256)
            else
              iprot#skip _t250)
          | 1 -> (if _t250 = Protocol.T_STRUCT then
              _str249#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t250)
          | 2 -> (if _t250 = Protocol.T_STRUCT then
              _str249#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t250)
          | 3 -> (if _t250 = Protocol.T_STRUCT then
              _str249#set_te (read_timedOutException iprot)
            else
              iprot#skip _t250)
          | _ -> iprot#skip _t250);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str249

class get_count_args =
object (self)
  val mutable _keyspace : string option = None
  method get_keyspace = _keyspace
  method grab_keyspace = match _keyspace with None->raise (Field_empty "get_count_args.keyspace") | Some _x262 -> _x262
  method set_keyspace _x262 = _keyspace <- Some _x262
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "get_count_args.key") | Some _x262 -> _x262
  method set_key _x262 = _key <- Some _x262
  val mutable _column_parent : columnParent option = None
  method get_column_parent = _column_parent
  method grab_column_parent = match _column_parent with None->raise (Field_empty "get_count_args.column_parent") | Some _x262 -> _x262
  method set_column_parent _x262 = _column_parent <- Some _x262
  val mutable _consistency_level : ConsistencyLevel.t option = None
  method get_consistency_level = _consistency_level
  method grab_consistency_level = match _consistency_level with None->raise (Field_empty "get_count_args.consistency_level") | Some _x262 -> _x262
  method set_consistency_level _x262 = _consistency_level <- Some _x262
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_count_args";
    (match _keyspace with None -> () | Some _v -> 
      oprot#writeFieldBegin("keyspace",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _key with None -> () | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _column_parent with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_parent",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _consistency_level with None -> () | Some _v -> 
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,4);
      oprot#writeI32(ConsistencyLevel.to_i _v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_count_args (iprot : Protocol.t) =
  let _str265 = new get_count_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t266,_id267) = iprot#readFieldBegin in
        if _t266 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id267 with 
          | 1 -> (if _t266 = Protocol.T_STRING then
              _str265#set_keyspace iprot#readString
            else
              iprot#skip _t266)
          | 2 -> (if _t266 = Protocol.T_STRING then
              _str265#set_key iprot#readString
            else
              iprot#skip _t266)
          | 3 -> (if _t266 = Protocol.T_STRUCT then
              _str265#set_column_parent (read_columnParent iprot)
            else
              iprot#skip _t266)
          | 4 -> (if _t266 = Protocol.T_I32 then
              _str265#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t266)
          | _ -> iprot#skip _t266);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str265

class get_count_result =
object (self)
  val mutable _success : int option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "get_count_result.success") | Some _x268 -> _x268
  method set_success _x268 = _success <- Some _x268
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "get_count_result.ire") | Some _x268 -> _x268
  method set_ire _x268 = _ire <- Some _x268
  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "get_count_result.ue") | Some _x268 -> _x268
  method set_ue _x268 = _ue <- Some _x268
  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "get_count_result.te") | Some _x268 -> _x268
  method set_te _x268 = _te <- Some _x268
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_count_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_I32,0);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_count_result (iprot : Protocol.t) =
  let _str271 = new get_count_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t272,_id273) = iprot#readFieldBegin in
        if _t272 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id273 with 
          | 0 -> (if _t272 = Protocol.T_I32 then
              _str271#set_success iprot#readI32
            else
              iprot#skip _t272)
          | 1 -> (if _t272 = Protocol.T_STRUCT then
              _str271#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t272)
          | 2 -> (if _t272 = Protocol.T_STRUCT then
              _str271#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t272)
          | 3 -> (if _t272 = Protocol.T_STRUCT then
              _str271#set_te (read_timedOutException iprot)
            else
              iprot#skip _t272)
          | _ -> iprot#skip _t272);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str271

class get_range_slice_args =
object (self)
  val mutable _keyspace : string option = None
  method get_keyspace = _keyspace
  method grab_keyspace = match _keyspace with None->raise (Field_empty "get_range_slice_args.keyspace") | Some _x274 -> _x274
  method set_keyspace _x274 = _keyspace <- Some _x274
  val mutable _column_parent : columnParent option = None
  method get_column_parent = _column_parent
  method grab_column_parent = match _column_parent with None->raise (Field_empty "get_range_slice_args.column_parent") | Some _x274 -> _x274
  method set_column_parent _x274 = _column_parent <- Some _x274
  val mutable _predicate : slicePredicate option = None
  method get_predicate = _predicate
  method grab_predicate = match _predicate with None->raise (Field_empty "get_range_slice_args.predicate") | Some _x274 -> _x274
  method set_predicate _x274 = _predicate <- Some _x274
  val mutable _start_key : string option = None
  method get_start_key = _start_key
  method grab_start_key = match _start_key with None->raise (Field_empty "get_range_slice_args.start_key") | Some _x274 -> _x274
  method set_start_key _x274 = _start_key <- Some _x274
  val mutable _finish_key : string option = None
  method get_finish_key = _finish_key
  method grab_finish_key = match _finish_key with None->raise (Field_empty "get_range_slice_args.finish_key") | Some _x274 -> _x274
  method set_finish_key _x274 = _finish_key <- Some _x274
  val mutable _row_count : int option = None
  method get_row_count = _row_count
  method grab_row_count = match _row_count with None->raise (Field_empty "get_range_slice_args.row_count") | Some _x274 -> _x274
  method set_row_count _x274 = _row_count <- Some _x274
  val mutable _consistency_level : ConsistencyLevel.t option = None
  method get_consistency_level = _consistency_level
  method grab_consistency_level = match _consistency_level with None->raise (Field_empty "get_range_slice_args.consistency_level") | Some _x274 -> _x274
  method set_consistency_level _x274 = _consistency_level <- Some _x274
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_range_slice_args";
    (match _keyspace with None -> () | Some _v -> 
      oprot#writeFieldBegin("keyspace",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _column_parent with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_parent",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _predicate with None -> () | Some _v -> 
      oprot#writeFieldBegin("predicate",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _start_key with None -> () | Some _v -> 
      oprot#writeFieldBegin("start_key",Protocol.T_STRING,4);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _finish_key with None -> () | Some _v -> 
      oprot#writeFieldBegin("finish_key",Protocol.T_STRING,5);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _row_count with None -> () | Some _v -> 
      oprot#writeFieldBegin("row_count",Protocol.T_I32,6);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _consistency_level with None -> () | Some _v -> 
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,7);
      oprot#writeI32(ConsistencyLevel.to_i _v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_range_slice_args (iprot : Protocol.t) =
  let _str277 = new get_range_slice_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t278,_id279) = iprot#readFieldBegin in
        if _t278 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id279 with 
          | 1 -> (if _t278 = Protocol.T_STRING then
              _str277#set_keyspace iprot#readString
            else
              iprot#skip _t278)
          | 2 -> (if _t278 = Protocol.T_STRUCT then
              _str277#set_column_parent (read_columnParent iprot)
            else
              iprot#skip _t278)
          | 3 -> (if _t278 = Protocol.T_STRUCT then
              _str277#set_predicate (read_slicePredicate iprot)
            else
              iprot#skip _t278)
          | 4 -> (if _t278 = Protocol.T_STRING then
              _str277#set_start_key iprot#readString
            else
              iprot#skip _t278)
          | 5 -> (if _t278 = Protocol.T_STRING then
              _str277#set_finish_key iprot#readString
            else
              iprot#skip _t278)
          | 6 -> (if _t278 = Protocol.T_I32 then
              _str277#set_row_count iprot#readI32
            else
              iprot#skip _t278)
          | 7 -> (if _t278 = Protocol.T_I32 then
              _str277#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t278)
          | _ -> iprot#skip _t278);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str277

class get_range_slice_result =
object (self)
  val mutable _success : keySlice list option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "get_range_slice_result.success") | Some _x280 -> _x280
  method set_success _x280 = _success <- Some _x280
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "get_range_slice_result.ire") | Some _x280 -> _x280
  method set_ire _x280 = _ire <- Some _x280
  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "get_range_slice_result.ue") | Some _x280 -> _x280
  method set_ue _x280 = _ue <- Some _x280
  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "get_range_slice_result.te") | Some _x280 -> _x280
  method set_te _x280 = _te <- Some _x280
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_range_slice_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_LIST,0);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter283 ->         _iter283#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_range_slice_result (iprot : Protocol.t) =
  let _str284 = new get_range_slice_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t285,_id286) = iprot#readFieldBegin in
        if _t285 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id286 with 
          | 0 -> (if _t285 = Protocol.T_LIST then
              _str284#set_success 
                (let (_etype290,_size287) = iprot#readListBegin in
                  let _con291 = (Array.to_list (Array.init _size287 (fun _ -> (read_keySlice iprot)))) in
                    iprot#readListEnd; _con291)
            else
              iprot#skip _t285)
          | 1 -> (if _t285 = Protocol.T_STRUCT then
              _str284#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t285)
          | 2 -> (if _t285 = Protocol.T_STRUCT then
              _str284#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t285)
          | 3 -> (if _t285 = Protocol.T_STRUCT then
              _str284#set_te (read_timedOutException iprot)
            else
              iprot#skip _t285)
          | _ -> iprot#skip _t285);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str284

class get_range_slices_args =
object (self)
  val mutable _keyspace : string option = None
  method get_keyspace = _keyspace
  method grab_keyspace = match _keyspace with None->raise (Field_empty "get_range_slices_args.keyspace") | Some _x292 -> _x292
  method set_keyspace _x292 = _keyspace <- Some _x292
  val mutable _column_parent : columnParent option = None
  method get_column_parent = _column_parent
  method grab_column_parent = match _column_parent with None->raise (Field_empty "get_range_slices_args.column_parent") | Some _x292 -> _x292
  method set_column_parent _x292 = _column_parent <- Some _x292
  val mutable _predicate : slicePredicate option = None
  method get_predicate = _predicate
  method grab_predicate = match _predicate with None->raise (Field_empty "get_range_slices_args.predicate") | Some _x292 -> _x292
  method set_predicate _x292 = _predicate <- Some _x292
  val mutable _range : keyRange option = None
  method get_range = _range
  method grab_range = match _range with None->raise (Field_empty "get_range_slices_args.range") | Some _x292 -> _x292
  method set_range _x292 = _range <- Some _x292
  val mutable _consistency_level : ConsistencyLevel.t option = None
  method get_consistency_level = _consistency_level
  method grab_consistency_level = match _consistency_level with None->raise (Field_empty "get_range_slices_args.consistency_level") | Some _x292 -> _x292
  method set_consistency_level _x292 = _consistency_level <- Some _x292
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_range_slices_args";
    (match _keyspace with None -> () | Some _v -> 
      oprot#writeFieldBegin("keyspace",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _column_parent with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_parent",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _predicate with None -> () | Some _v -> 
      oprot#writeFieldBegin("predicate",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _range with None -> () | Some _v -> 
      oprot#writeFieldBegin("range",Protocol.T_STRUCT,4);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _consistency_level with None -> () | Some _v -> 
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,5);
      oprot#writeI32(ConsistencyLevel.to_i _v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_range_slices_args (iprot : Protocol.t) =
  let _str295 = new get_range_slices_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t296,_id297) = iprot#readFieldBegin in
        if _t296 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id297 with 
          | 1 -> (if _t296 = Protocol.T_STRING then
              _str295#set_keyspace iprot#readString
            else
              iprot#skip _t296)
          | 2 -> (if _t296 = Protocol.T_STRUCT then
              _str295#set_column_parent (read_columnParent iprot)
            else
              iprot#skip _t296)
          | 3 -> (if _t296 = Protocol.T_STRUCT then
              _str295#set_predicate (read_slicePredicate iprot)
            else
              iprot#skip _t296)
          | 4 -> (if _t296 = Protocol.T_STRUCT then
              _str295#set_range (read_keyRange iprot)
            else
              iprot#skip _t296)
          | 5 -> (if _t296 = Protocol.T_I32 then
              _str295#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t296)
          | _ -> iprot#skip _t296);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str295

class get_range_slices_result =
object (self)
  val mutable _success : keySlice list option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "get_range_slices_result.success") | Some _x298 -> _x298
  method set_success _x298 = _success <- Some _x298
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "get_range_slices_result.ire") | Some _x298 -> _x298
  method set_ire _x298 = _ire <- Some _x298
  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "get_range_slices_result.ue") | Some _x298 -> _x298
  method set_ue _x298 = _ue <- Some _x298
  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "get_range_slices_result.te") | Some _x298 -> _x298
  method set_te _x298 = _te <- Some _x298
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_range_slices_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_LIST,0);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter301 ->         _iter301#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_range_slices_result (iprot : Protocol.t) =
  let _str302 = new get_range_slices_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t303,_id304) = iprot#readFieldBegin in
        if _t303 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id304 with 
          | 0 -> (if _t303 = Protocol.T_LIST then
              _str302#set_success 
                (let (_etype308,_size305) = iprot#readListBegin in
                  let _con309 = (Array.to_list (Array.init _size305 (fun _ -> (read_keySlice iprot)))) in
                    iprot#readListEnd; _con309)
            else
              iprot#skip _t303)
          | 1 -> (if _t303 = Protocol.T_STRUCT then
              _str302#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t303)
          | 2 -> (if _t303 = Protocol.T_STRUCT then
              _str302#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t303)
          | 3 -> (if _t303 = Protocol.T_STRUCT then
              _str302#set_te (read_timedOutException iprot)
            else
              iprot#skip _t303)
          | _ -> iprot#skip _t303);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str302

class insert_args =
object (self)
  val mutable _keyspace : string option = None
  method get_keyspace = _keyspace
  method grab_keyspace = match _keyspace with None->raise (Field_empty "insert_args.keyspace") | Some _x310 -> _x310
  method set_keyspace _x310 = _keyspace <- Some _x310
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "insert_args.key") | Some _x310 -> _x310
  method set_key _x310 = _key <- Some _x310
  val mutable _column_path : columnPath option = None
  method get_column_path = _column_path
  method grab_column_path = match _column_path with None->raise (Field_empty "insert_args.column_path") | Some _x310 -> _x310
  method set_column_path _x310 = _column_path <- Some _x310
  val mutable _value : string option = None
  method get_value = _value
  method grab_value = match _value with None->raise (Field_empty "insert_args.value") | Some _x310 -> _x310
  method set_value _x310 = _value <- Some _x310
  val mutable _timestamp : Int64.t option = None
  method get_timestamp = _timestamp
  method grab_timestamp = match _timestamp with None->raise (Field_empty "insert_args.timestamp") | Some _x310 -> _x310
  method set_timestamp _x310 = _timestamp <- Some _x310
  val mutable _consistency_level : ConsistencyLevel.t option = None
  method get_consistency_level = _consistency_level
  method grab_consistency_level = match _consistency_level with None->raise (Field_empty "insert_args.consistency_level") | Some _x310 -> _x310
  method set_consistency_level _x310 = _consistency_level <- Some _x310
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "insert_args";
    (match _keyspace with None -> () | Some _v -> 
      oprot#writeFieldBegin("keyspace",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _key with None -> () | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _column_path with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_path",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _value with None -> () | Some _v -> 
      oprot#writeFieldBegin("value",Protocol.T_STRING,4);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _timestamp with None -> () | Some _v -> 
      oprot#writeFieldBegin("timestamp",Protocol.T_I64,5);
      oprot#writeI64(_v);
      oprot#writeFieldEnd
    );
    (match _consistency_level with None -> () | Some _v -> 
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,6);
      oprot#writeI32(ConsistencyLevel.to_i _v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_insert_args (iprot : Protocol.t) =
  let _str313 = new insert_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t314,_id315) = iprot#readFieldBegin in
        if _t314 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id315 with 
          | 1 -> (if _t314 = Protocol.T_STRING then
              _str313#set_keyspace iprot#readString
            else
              iprot#skip _t314)
          | 2 -> (if _t314 = Protocol.T_STRING then
              _str313#set_key iprot#readString
            else
              iprot#skip _t314)
          | 3 -> (if _t314 = Protocol.T_STRUCT then
              _str313#set_column_path (read_columnPath iprot)
            else
              iprot#skip _t314)
          | 4 -> (if _t314 = Protocol.T_STRING then
              _str313#set_value iprot#readString
            else
              iprot#skip _t314)
          | 5 -> (if _t314 = Protocol.T_I64 then
              _str313#set_timestamp iprot#readI64
            else
              iprot#skip _t314)
          | 6 -> (if _t314 = Protocol.T_I32 then
              _str313#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t314)
          | _ -> iprot#skip _t314);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str313

class insert_result =
object (self)
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "insert_result.ire") | Some _x316 -> _x316
  method set_ire _x316 = _ire <- Some _x316
  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "insert_result.ue") | Some _x316 -> _x316
  method set_ue _x316 = _ue <- Some _x316
  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "insert_result.te") | Some _x316 -> _x316
  method set_te _x316 = _te <- Some _x316
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "insert_result";
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_insert_result (iprot : Protocol.t) =
  let _str319 = new insert_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t320,_id321) = iprot#readFieldBegin in
        if _t320 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id321 with 
          | 1 -> (if _t320 = Protocol.T_STRUCT then
              _str319#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t320)
          | 2 -> (if _t320 = Protocol.T_STRUCT then
              _str319#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t320)
          | 3 -> (if _t320 = Protocol.T_STRUCT then
              _str319#set_te (read_timedOutException iprot)
            else
              iprot#skip _t320)
          | _ -> iprot#skip _t320);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str319

class batch_insert_args =
object (self)
  val mutable _keyspace : string option = None
  method get_keyspace = _keyspace
  method grab_keyspace = match _keyspace with None->raise (Field_empty "batch_insert_args.keyspace") | Some _x322 -> _x322
  method set_keyspace _x322 = _keyspace <- Some _x322
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "batch_insert_args.key") | Some _x322 -> _x322
  method set_key _x322 = _key <- Some _x322
  val mutable _cfmap : (string,columnOrSuperColumn list) Hashtbl.t option = None
  method get_cfmap = _cfmap
  method grab_cfmap = match _cfmap with None->raise (Field_empty "batch_insert_args.cfmap") | Some _x322 -> _x322
  method set_cfmap _x322 = _cfmap <- Some _x322
  val mutable _consistency_level : ConsistencyLevel.t option = None
  method get_consistency_level = _consistency_level
  method grab_consistency_level = match _consistency_level with None->raise (Field_empty "batch_insert_args.consistency_level") | Some _x322 -> _x322
  method set_consistency_level _x322 = _consistency_level <- Some _x322
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "batch_insert_args";
    (match _keyspace with None -> () | Some _v -> 
      oprot#writeFieldBegin("keyspace",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _key with None -> () | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _cfmap with None -> () | Some _v -> 
      oprot#writeFieldBegin("cfmap",Protocol.T_MAP,3);
      oprot#writeMapBegin(Protocol.T_STRING,Protocol.T_LIST,Hashtbl.length _v);
      Hashtbl.iter (fun _kiter325 -> fun _viter326 -> 
        oprot#writeString(_kiter325);
        oprot#writeListBegin(Protocol.T_STRUCT,List.length _viter326);
        List.iter (fun _iter327 ->           _iter327#write(oprot);
        ) _viter326;
        oprot#writeListEnd;
      ) _v;
      oprot#writeMapEnd;
      oprot#writeFieldEnd
    );
    (match _consistency_level with None -> () | Some _v -> 
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,4);
      oprot#writeI32(ConsistencyLevel.to_i _v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_batch_insert_args (iprot : Protocol.t) =
  let _str328 = new batch_insert_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t329,_id330) = iprot#readFieldBegin in
        if _t329 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id330 with 
          | 1 -> (if _t329 = Protocol.T_STRING then
              _str328#set_keyspace iprot#readString
            else
              iprot#skip _t329)
          | 2 -> (if _t329 = Protocol.T_STRING then
              _str328#set_key iprot#readString
            else
              iprot#skip _t329)
          | 3 -> (if _t329 = Protocol.T_MAP then
              _str328#set_cfmap 
                (let (_ktype332,_vtype333,_size331) = iprot#readMapBegin in
                let _con335 = Hashtbl.create _size331 in
                  for i = 1 to _size331 do
                    let _k = iprot#readString in
                    let _v = 
                      (let (_etype339,_size336) = iprot#readListBegin in
                        let _con340 = (Array.to_list (Array.init _size336 (fun _ -> (read_columnOrSuperColumn iprot)))) in
                          iprot#readListEnd; _con340) in
                      Hashtbl.add _con335 _k _v
                  done; iprot#readMapEnd; _con335)
            else
              iprot#skip _t329)
          | 4 -> (if _t329 = Protocol.T_I32 then
              _str328#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t329)
          | _ -> iprot#skip _t329);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str328

class batch_insert_result =
object (self)
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "batch_insert_result.ire") | Some _x341 -> _x341
  method set_ire _x341 = _ire <- Some _x341
  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "batch_insert_result.ue") | Some _x341 -> _x341
  method set_ue _x341 = _ue <- Some _x341
  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "batch_insert_result.te") | Some _x341 -> _x341
  method set_te _x341 = _te <- Some _x341
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "batch_insert_result";
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_batch_insert_result (iprot : Protocol.t) =
  let _str344 = new batch_insert_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t345,_id346) = iprot#readFieldBegin in
        if _t345 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id346 with 
          | 1 -> (if _t345 = Protocol.T_STRUCT then
              _str344#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t345)
          | 2 -> (if _t345 = Protocol.T_STRUCT then
              _str344#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t345)
          | 3 -> (if _t345 = Protocol.T_STRUCT then
              _str344#set_te (read_timedOutException iprot)
            else
              iprot#skip _t345)
          | _ -> iprot#skip _t345);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str344

class remove_args =
object (self)
  val mutable _keyspace : string option = None
  method get_keyspace = _keyspace
  method grab_keyspace = match _keyspace with None->raise (Field_empty "remove_args.keyspace") | Some _x347 -> _x347
  method set_keyspace _x347 = _keyspace <- Some _x347
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "remove_args.key") | Some _x347 -> _x347
  method set_key _x347 = _key <- Some _x347
  val mutable _column_path : columnPath option = None
  method get_column_path = _column_path
  method grab_column_path = match _column_path with None->raise (Field_empty "remove_args.column_path") | Some _x347 -> _x347
  method set_column_path _x347 = _column_path <- Some _x347
  val mutable _timestamp : Int64.t option = None
  method get_timestamp = _timestamp
  method grab_timestamp = match _timestamp with None->raise (Field_empty "remove_args.timestamp") | Some _x347 -> _x347
  method set_timestamp _x347 = _timestamp <- Some _x347
  val mutable _consistency_level : ConsistencyLevel.t option = None
  method get_consistency_level = _consistency_level
  method grab_consistency_level = match _consistency_level with None->raise (Field_empty "remove_args.consistency_level") | Some _x347 -> _x347
  method set_consistency_level _x347 = _consistency_level <- Some _x347
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "remove_args";
    (match _keyspace with None -> () | Some _v -> 
      oprot#writeFieldBegin("keyspace",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _key with None -> () | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _column_path with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_path",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _timestamp with None -> () | Some _v -> 
      oprot#writeFieldBegin("timestamp",Protocol.T_I64,4);
      oprot#writeI64(_v);
      oprot#writeFieldEnd
    );
    (match _consistency_level with None -> () | Some _v -> 
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,5);
      oprot#writeI32(ConsistencyLevel.to_i _v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_remove_args (iprot : Protocol.t) =
  let _str350 = new remove_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t351,_id352) = iprot#readFieldBegin in
        if _t351 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id352 with 
          | 1 -> (if _t351 = Protocol.T_STRING then
              _str350#set_keyspace iprot#readString
            else
              iprot#skip _t351)
          | 2 -> (if _t351 = Protocol.T_STRING then
              _str350#set_key iprot#readString
            else
              iprot#skip _t351)
          | 3 -> (if _t351 = Protocol.T_STRUCT then
              _str350#set_column_path (read_columnPath iprot)
            else
              iprot#skip _t351)
          | 4 -> (if _t351 = Protocol.T_I64 then
              _str350#set_timestamp iprot#readI64
            else
              iprot#skip _t351)
          | 5 -> (if _t351 = Protocol.T_I32 then
              _str350#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t351)
          | _ -> iprot#skip _t351);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str350

class remove_result =
object (self)
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "remove_result.ire") | Some _x353 -> _x353
  method set_ire _x353 = _ire <- Some _x353
  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "remove_result.ue") | Some _x353 -> _x353
  method set_ue _x353 = _ue <- Some _x353
  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "remove_result.te") | Some _x353 -> _x353
  method set_te _x353 = _te <- Some _x353
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "remove_result";
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_remove_result (iprot : Protocol.t) =
  let _str356 = new remove_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t357,_id358) = iprot#readFieldBegin in
        if _t357 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id358 with 
          | 1 -> (if _t357 = Protocol.T_STRUCT then
              _str356#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t357)
          | 2 -> (if _t357 = Protocol.T_STRUCT then
              _str356#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t357)
          | 3 -> (if _t357 = Protocol.T_STRUCT then
              _str356#set_te (read_timedOutException iprot)
            else
              iprot#skip _t357)
          | _ -> iprot#skip _t357);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str356

class batch_mutate_args =
object (self)
  val mutable _keyspace : string option = None
  method get_keyspace = _keyspace
  method grab_keyspace = match _keyspace with None->raise (Field_empty "batch_mutate_args.keyspace") | Some _x359 -> _x359
  method set_keyspace _x359 = _keyspace <- Some _x359
  val mutable _mutation_map : (string,(string,mutation list) Hashtbl.t) Hashtbl.t option = None
  method get_mutation_map = _mutation_map
  method grab_mutation_map = match _mutation_map with None->raise (Field_empty "batch_mutate_args.mutation_map") | Some _x359 -> _x359
  method set_mutation_map _x359 = _mutation_map <- Some _x359
  val mutable _consistency_level : ConsistencyLevel.t option = None
  method get_consistency_level = _consistency_level
  method grab_consistency_level = match _consistency_level with None->raise (Field_empty "batch_mutate_args.consistency_level") | Some _x359 -> _x359
  method set_consistency_level _x359 = _consistency_level <- Some _x359
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "batch_mutate_args";
    (match _keyspace with None -> () | Some _v -> 
      oprot#writeFieldBegin("keyspace",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _mutation_map with None -> () | Some _v -> 
      oprot#writeFieldBegin("mutation_map",Protocol.T_MAP,2);
      oprot#writeMapBegin(Protocol.T_STRING,Protocol.T_MAP,Hashtbl.length _v);
      Hashtbl.iter (fun _kiter362 -> fun _viter363 -> 
        oprot#writeString(_kiter362);
        oprot#writeMapBegin(Protocol.T_STRING,Protocol.T_LIST,Hashtbl.length _viter363);
        Hashtbl.iter (fun _kiter364 -> fun _viter365 -> 
          oprot#writeString(_kiter364);
          oprot#writeListBegin(Protocol.T_STRUCT,List.length _viter365);
          List.iter (fun _iter366 ->             _iter366#write(oprot);
          ) _viter365;
          oprot#writeListEnd;
        ) _viter363;
        oprot#writeMapEnd;
      ) _v;
      oprot#writeMapEnd;
      oprot#writeFieldEnd
    );
    (match _consistency_level with None -> () | Some _v -> 
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,3);
      oprot#writeI32(ConsistencyLevel.to_i _v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_batch_mutate_args (iprot : Protocol.t) =
  let _str367 = new batch_mutate_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t368,_id369) = iprot#readFieldBegin in
        if _t368 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id369 with 
          | 1 -> (if _t368 = Protocol.T_STRING then
              _str367#set_keyspace iprot#readString
            else
              iprot#skip _t368)
          | 2 -> (if _t368 = Protocol.T_MAP then
              _str367#set_mutation_map 
                (let (_ktype371,_vtype372,_size370) = iprot#readMapBegin in
                let _con374 = Hashtbl.create _size370 in
                  for i = 1 to _size370 do
                    let _k = iprot#readString in
                    let _v = 
                      (let (_ktype376,_vtype377,_size375) = iprot#readMapBegin in
                      let _con379 = Hashtbl.create _size375 in
                        for i = 1 to _size375 do
                          let _k = iprot#readString in
                          let _v = 
                            (let (_etype383,_size380) = iprot#readListBegin in
                              let _con384 = (Array.to_list (Array.init _size380 (fun _ -> (read_mutation iprot)))) in
                                iprot#readListEnd; _con384) in
                            Hashtbl.add _con379 _k _v
                        done; iprot#readMapEnd; _con379) in
                      Hashtbl.add _con374 _k _v
                  done; iprot#readMapEnd; _con374)
            else
              iprot#skip _t368)
          | 3 -> (if _t368 = Protocol.T_I32 then
              _str367#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t368)
          | _ -> iprot#skip _t368);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str367

class batch_mutate_result =
object (self)
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "batch_mutate_result.ire") | Some _x385 -> _x385
  method set_ire _x385 = _ire <- Some _x385
  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "batch_mutate_result.ue") | Some _x385 -> _x385
  method set_ue _x385 = _ue <- Some _x385
  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "batch_mutate_result.te") | Some _x385 -> _x385
  method set_te _x385 = _te <- Some _x385
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "batch_mutate_result";
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_batch_mutate_result (iprot : Protocol.t) =
  let _str388 = new batch_mutate_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t389,_id390) = iprot#readFieldBegin in
        if _t389 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id390 with 
          | 1 -> (if _t389 = Protocol.T_STRUCT then
              _str388#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t389)
          | 2 -> (if _t389 = Protocol.T_STRUCT then
              _str388#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t389)
          | 3 -> (if _t389 = Protocol.T_STRUCT then
              _str388#set_te (read_timedOutException iprot)
            else
              iprot#skip _t389)
          | _ -> iprot#skip _t389);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str388

class get_string_property_args =
object (self)
  val mutable _property : string option = None
  method get_property = _property
  method grab_property = match _property with None->raise (Field_empty "get_string_property_args.property") | Some _x391 -> _x391
  method set_property _x391 = _property <- Some _x391
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_string_property_args";
    (match _property with None -> () | Some _v -> 
      oprot#writeFieldBegin("property",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_string_property_args (iprot : Protocol.t) =
  let _str394 = new get_string_property_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t395,_id396) = iprot#readFieldBegin in
        if _t395 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id396 with 
          | 1 -> (if _t395 = Protocol.T_STRING then
              _str394#set_property iprot#readString
            else
              iprot#skip _t395)
          | _ -> iprot#skip _t395);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str394

class get_string_property_result =
object (self)
  val mutable _success : string option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "get_string_property_result.success") | Some _x397 -> _x397
  method set_success _x397 = _success <- Some _x397
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_string_property_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRING,0);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_string_property_result (iprot : Protocol.t) =
  let _str400 = new get_string_property_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t401,_id402) = iprot#readFieldBegin in
        if _t401 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id402 with 
          | 0 -> (if _t401 = Protocol.T_STRING then
              _str400#set_success iprot#readString
            else
              iprot#skip _t401)
          | _ -> iprot#skip _t401);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str400

class get_string_list_property_args =
object (self)
  val mutable _property : string option = None
  method get_property = _property
  method grab_property = match _property with None->raise (Field_empty "get_string_list_property_args.property") | Some _x403 -> _x403
  method set_property _x403 = _property <- Some _x403
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_string_list_property_args";
    (match _property with None -> () | Some _v -> 
      oprot#writeFieldBegin("property",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_string_list_property_args (iprot : Protocol.t) =
  let _str406 = new get_string_list_property_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t407,_id408) = iprot#readFieldBegin in
        if _t407 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id408 with 
          | 1 -> (if _t407 = Protocol.T_STRING then
              _str406#set_property iprot#readString
            else
              iprot#skip _t407)
          | _ -> iprot#skip _t407);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str406

class get_string_list_property_result =
object (self)
  val mutable _success : string list option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "get_string_list_property_result.success") | Some _x409 -> _x409
  method set_success _x409 = _success <- Some _x409
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_string_list_property_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_LIST,0);
      oprot#writeListBegin(Protocol.T_STRING,List.length _v);
      List.iter (fun _iter412 ->         oprot#writeString(_iter412);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_string_list_property_result (iprot : Protocol.t) =
  let _str413 = new get_string_list_property_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t414,_id415) = iprot#readFieldBegin in
        if _t414 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id415 with 
          | 0 -> (if _t414 = Protocol.T_LIST then
              _str413#set_success 
                (let (_etype419,_size416) = iprot#readListBegin in
                  let _con420 = (Array.to_list (Array.init _size416 (fun _ -> iprot#readString))) in
                    iprot#readListEnd; _con420)
            else
              iprot#skip _t414)
          | _ -> iprot#skip _t414);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str413

class describe_keyspaces_args =
object (self)
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_keyspaces_args";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_keyspaces_args (iprot : Protocol.t) =
  let _str424 = new describe_keyspaces_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t425,_id426) = iprot#readFieldBegin in
        if _t425 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id426 with 
          | _ -> iprot#skip _t425);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str424

class describe_keyspaces_result =
object (self)
  val mutable _success : (string,bool) Hashtbl.t option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "describe_keyspaces_result.success") | Some _x427 -> _x427
  method set_success _x427 = _success <- Some _x427
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_keyspaces_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_SET,0);
      oprot#writeSetBegin(Protocol.T_STRING,Hashtbl.length _v);
      Hashtbl.iter (fun _iter430 -> fun _ ->         oprot#writeString(_iter430);
      ) _v;
      oprot#writeSetEnd;
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_keyspaces_result (iprot : Protocol.t) =
  let _str431 = new describe_keyspaces_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t432,_id433) = iprot#readFieldBegin in
        if _t432 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id433 with 
          | 0 -> (if _t432 = Protocol.T_SET then
              _str431#set_success 
                (let (_etype437,_size434) = iprot#readSetBegin in
                let _con438 = Hashtbl.create _size434 in
                  for i = 1 to _size434 do
                    Hashtbl.add _con438 iprot#readString true
                  done; iprot#readSetEnd; _con438)
            else
              iprot#skip _t432)
          | _ -> iprot#skip _t432);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str431

class describe_cluster_name_args =
object (self)
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_cluster_name_args";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_cluster_name_args (iprot : Protocol.t) =
  let _str442 = new describe_cluster_name_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t443,_id444) = iprot#readFieldBegin in
        if _t443 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id444 with 
          | _ -> iprot#skip _t443);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str442

class describe_cluster_name_result =
object (self)
  val mutable _success : string option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "describe_cluster_name_result.success") | Some _x445 -> _x445
  method set_success _x445 = _success <- Some _x445
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_cluster_name_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRING,0);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_cluster_name_result (iprot : Protocol.t) =
  let _str448 = new describe_cluster_name_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t449,_id450) = iprot#readFieldBegin in
        if _t449 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id450 with 
          | 0 -> (if _t449 = Protocol.T_STRING then
              _str448#set_success iprot#readString
            else
              iprot#skip _t449)
          | _ -> iprot#skip _t449);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str448

class describe_version_args =
object (self)
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_version_args";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_version_args (iprot : Protocol.t) =
  let _str454 = new describe_version_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t455,_id456) = iprot#readFieldBegin in
        if _t455 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id456 with 
          | _ -> iprot#skip _t455);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str454

class describe_version_result =
object (self)
  val mutable _success : string option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "describe_version_result.success") | Some _x457 -> _x457
  method set_success _x457 = _success <- Some _x457
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_version_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRING,0);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_version_result (iprot : Protocol.t) =
  let _str460 = new describe_version_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t461,_id462) = iprot#readFieldBegin in
        if _t461 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id462 with 
          | 0 -> (if _t461 = Protocol.T_STRING then
              _str460#set_success iprot#readString
            else
              iprot#skip _t461)
          | _ -> iprot#skip _t461);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str460

class describe_ring_args =
object (self)
  val mutable _keyspace : string option = None
  method get_keyspace = _keyspace
  method grab_keyspace = match _keyspace with None->raise (Field_empty "describe_ring_args.keyspace") | Some _x463 -> _x463
  method set_keyspace _x463 = _keyspace <- Some _x463
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_ring_args";
    (match _keyspace with None -> () | Some _v -> 
      oprot#writeFieldBegin("keyspace",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_ring_args (iprot : Protocol.t) =
  let _str466 = new describe_ring_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t467,_id468) = iprot#readFieldBegin in
        if _t467 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id468 with 
          | 1 -> (if _t467 = Protocol.T_STRING then
              _str466#set_keyspace iprot#readString
            else
              iprot#skip _t467)
          | _ -> iprot#skip _t467);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str466

class describe_ring_result =
object (self)
  val mutable _success : tokenRange list option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "describe_ring_result.success") | Some _x469 -> _x469
  method set_success _x469 = _success <- Some _x469
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_ring_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_LIST,0);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter472 ->         _iter472#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_ring_result (iprot : Protocol.t) =
  let _str473 = new describe_ring_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t474,_id475) = iprot#readFieldBegin in
        if _t474 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id475 with 
          | 0 -> (if _t474 = Protocol.T_LIST then
              _str473#set_success 
                (let (_etype479,_size476) = iprot#readListBegin in
                  let _con480 = (Array.to_list (Array.init _size476 (fun _ -> (read_tokenRange iprot)))) in
                    iprot#readListEnd; _con480)
            else
              iprot#skip _t474)
          | _ -> iprot#skip _t474);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str473

class describe_keyspace_args =
object (self)
  val mutable _keyspace : string option = None
  method get_keyspace = _keyspace
  method grab_keyspace = match _keyspace with None->raise (Field_empty "describe_keyspace_args.keyspace") | Some _x481 -> _x481
  method set_keyspace _x481 = _keyspace <- Some _x481
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_keyspace_args";
    (match _keyspace with None -> () | Some _v -> 
      oprot#writeFieldBegin("keyspace",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_keyspace_args (iprot : Protocol.t) =
  let _str484 = new describe_keyspace_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t485,_id486) = iprot#readFieldBegin in
        if _t485 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id486 with 
          | 1 -> (if _t485 = Protocol.T_STRING then
              _str484#set_keyspace iprot#readString
            else
              iprot#skip _t485)
          | _ -> iprot#skip _t485);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str484

class describe_keyspace_result =
object (self)
  val mutable _success : (string,(string,string) Hashtbl.t) Hashtbl.t option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "describe_keyspace_result.success") | Some _x487 -> _x487
  method set_success _x487 = _success <- Some _x487
  val mutable _nfe : notFoundException option = None
  method get_nfe = _nfe
  method grab_nfe = match _nfe with None->raise (Field_empty "describe_keyspace_result.nfe") | Some _x487 -> _x487
  method set_nfe _x487 = _nfe <- Some _x487
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_keyspace_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_MAP,0);
      oprot#writeMapBegin(Protocol.T_STRING,Protocol.T_MAP,Hashtbl.length _v);
      Hashtbl.iter (fun _kiter490 -> fun _viter491 -> 
        oprot#writeString(_kiter490);
        oprot#writeMapBegin(Protocol.T_STRING,Protocol.T_STRING,Hashtbl.length _viter491);
        Hashtbl.iter (fun _kiter492 -> fun _viter493 -> 
          oprot#writeString(_kiter492);
          oprot#writeString(_viter493);
        ) _viter491;
        oprot#writeMapEnd;
      ) _v;
      oprot#writeMapEnd;
      oprot#writeFieldEnd
    );
    (match _nfe with None -> () | Some _v -> 
      oprot#writeFieldBegin("nfe",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_keyspace_result (iprot : Protocol.t) =
  let _str494 = new describe_keyspace_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t495,_id496) = iprot#readFieldBegin in
        if _t495 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id496 with 
          | 0 -> (if _t495 = Protocol.T_MAP then
              _str494#set_success 
                (let (_ktype498,_vtype499,_size497) = iprot#readMapBegin in
                let _con501 = Hashtbl.create _size497 in
                  for i = 1 to _size497 do
                    let _k = iprot#readString in
                    let _v = 
                      (let (_ktype503,_vtype504,_size502) = iprot#readMapBegin in
                      let _con506 = Hashtbl.create _size502 in
                        for i = 1 to _size502 do
                          let _k = iprot#readString in
                          let _v = iprot#readString in
                            Hashtbl.add _con506 _k _v
                        done; iprot#readMapEnd; _con506) in
                      Hashtbl.add _con501 _k _v
                  done; iprot#readMapEnd; _con501)
            else
              iprot#skip _t495)
          | 1 -> (if _t495 = Protocol.T_STRUCT then
              _str494#set_nfe (read_notFoundException iprot)
            else
              iprot#skip _t495)
          | _ -> iprot#skip _t495);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str494

class describe_splits_args =
object (self)
  val mutable _start_token : string option = None
  method get_start_token = _start_token
  method grab_start_token = match _start_token with None->raise (Field_empty "describe_splits_args.start_token") | Some _x507 -> _x507
  method set_start_token _x507 = _start_token <- Some _x507
  val mutable _end_token : string option = None
  method get_end_token = _end_token
  method grab_end_token = match _end_token with None->raise (Field_empty "describe_splits_args.end_token") | Some _x507 -> _x507
  method set_end_token _x507 = _end_token <- Some _x507
  val mutable _keys_per_split : int option = None
  method get_keys_per_split = _keys_per_split
  method grab_keys_per_split = match _keys_per_split with None->raise (Field_empty "describe_splits_args.keys_per_split") | Some _x507 -> _x507
  method set_keys_per_split _x507 = _keys_per_split <- Some _x507
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_splits_args";
    (match _start_token with None -> () | Some _v -> 
      oprot#writeFieldBegin("start_token",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _end_token with None -> () | Some _v -> 
      oprot#writeFieldBegin("end_token",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _keys_per_split with None -> () | Some _v -> 
      oprot#writeFieldBegin("keys_per_split",Protocol.T_I32,3);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_splits_args (iprot : Protocol.t) =
  let _str510 = new describe_splits_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t511,_id512) = iprot#readFieldBegin in
        if _t511 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id512 with 
          | 1 -> (if _t511 = Protocol.T_STRING then
              _str510#set_start_token iprot#readString
            else
              iprot#skip _t511)
          | 2 -> (if _t511 = Protocol.T_STRING then
              _str510#set_end_token iprot#readString
            else
              iprot#skip _t511)
          | 3 -> (if _t511 = Protocol.T_I32 then
              _str510#set_keys_per_split iprot#readI32
            else
              iprot#skip _t511)
          | _ -> iprot#skip _t511);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str510

class describe_splits_result =
object (self)
  val mutable _success : string list option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "describe_splits_result.success") | Some _x513 -> _x513
  method set_success _x513 = _success <- Some _x513
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_splits_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_LIST,0);
      oprot#writeListBegin(Protocol.T_STRING,List.length _v);
      List.iter (fun _iter516 ->         oprot#writeString(_iter516);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_splits_result (iprot : Protocol.t) =
  let _str517 = new describe_splits_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t518,_id519) = iprot#readFieldBegin in
        if _t518 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id519 with 
          | 0 -> (if _t518 = Protocol.T_LIST then
              _str517#set_success 
                (let (_etype523,_size520) = iprot#readListBegin in
                  let _con524 = (Array.to_list (Array.init _size520 (fun _ -> iprot#readString))) in
                    iprot#readListEnd; _con524)
            else
              iprot#skip _t518)
          | _ -> iprot#skip _t518);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str517

class virtual iface =
object (self)
  method virtual login : string option -> authenticationRequest option -> unit
  method virtual get : string option -> string option -> columnPath option -> ConsistencyLevel.t option -> columnOrSuperColumn
  method virtual get_slice : string option -> string option -> columnParent option -> slicePredicate option -> ConsistencyLevel.t option -> columnOrSuperColumn list
  method virtual multiget : string option -> string list option -> columnPath option -> ConsistencyLevel.t option -> (string,columnOrSuperColumn) Hashtbl.t
  method virtual multiget_slice : string option -> string list option -> columnParent option -> slicePredicate option -> ConsistencyLevel.t option -> (string,columnOrSuperColumn list) Hashtbl.t
  method virtual get_count : string option -> string option -> columnParent option -> ConsistencyLevel.t option -> int
  method virtual get_range_slice : string option -> columnParent option -> slicePredicate option -> string option -> string option -> int option -> ConsistencyLevel.t option -> keySlice list
  method virtual get_range_slices : string option -> columnParent option -> slicePredicate option -> keyRange option -> ConsistencyLevel.t option -> keySlice list
  method virtual insert : string option -> string option -> columnPath option -> string option -> Int64.t option -> ConsistencyLevel.t option -> unit
  method virtual batch_insert : string option -> string option -> (string,columnOrSuperColumn list) Hashtbl.t option -> ConsistencyLevel.t option -> unit
  method virtual remove : string option -> string option -> columnPath option -> Int64.t option -> ConsistencyLevel.t option -> unit
  method virtual batch_mutate : string option -> (string,(string,mutation list) Hashtbl.t) Hashtbl.t option -> ConsistencyLevel.t option -> unit
  method virtual get_string_property : string option -> string
  method virtual get_string_list_property : string option -> string list
  method virtual describe_keyspaces : (string,bool) Hashtbl.t
  method virtual describe_cluster_name : string
  method virtual describe_version : string
  method virtual describe_ring : string option -> tokenRange list
  method virtual describe_keyspace : string option -> (string,(string,string) Hashtbl.t) Hashtbl.t
  method virtual describe_splits : string option -> string option -> int option -> string list
end

class client (iprot : Protocol.t) (oprot : Protocol.t) =
object (self)
  val mutable seqid = 0
  method login keyspace auth_request = 
    self#send_login keyspace auth_request;
    self#recv_login
  method private send_login keyspace auth_request = 
    oprot#writeMessageBegin ("login", Protocol.CALL, seqid);
    let args = new login_args in
      args#set_keyspace keyspace;
      args#set_auth_request auth_request;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_login  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_login_result iprot in
        iprot#readMessageEnd;
        (match result#get_authnx with None -> () | Some _v ->
          raise (AuthenticationException _v));
        (match result#get_authzx with None -> () | Some _v ->
          raise (AuthorizationException _v));
        ()
  method get keyspace key column_path consistency_level = 
    self#send_get keyspace key column_path consistency_level;
    self#recv_get
  method private send_get keyspace key column_path consistency_level = 
    oprot#writeMessageBegin ("get", Protocol.CALL, seqid);
    let args = new get_args in
      args#set_keyspace keyspace;
      args#set_key key;
      args#set_column_path column_path;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_get  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_get_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_nfe with None -> () | Some _v ->
            raise (NotFoundException _v));
          (match result#get_ue with None -> () | Some _v ->
            raise (UnavailableException _v));
          (match result#get_te with None -> () | Some _v ->
            raise (TimedOutException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "get failed: unknown result")))
  method get_slice keyspace key column_parent predicate consistency_level = 
    self#send_get_slice keyspace key column_parent predicate consistency_level;
    self#recv_get_slice
  method private send_get_slice keyspace key column_parent predicate consistency_level = 
    oprot#writeMessageBegin ("get_slice", Protocol.CALL, seqid);
    let args = new get_slice_args in
      args#set_keyspace keyspace;
      args#set_key key;
      args#set_column_parent column_parent;
      args#set_predicate predicate;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_get_slice  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_get_slice_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_ue with None -> () | Some _v ->
            raise (UnavailableException _v));
          (match result#get_te with None -> () | Some _v ->
            raise (TimedOutException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "get_slice failed: unknown result")))
  method multiget keyspace keys column_path consistency_level = 
    self#send_multiget keyspace keys column_path consistency_level;
    self#recv_multiget
  method private send_multiget keyspace keys column_path consistency_level = 
    oprot#writeMessageBegin ("multiget", Protocol.CALL, seqid);
    let args = new multiget_args in
      args#set_keyspace keyspace;
      args#set_keys keys;
      args#set_column_path column_path;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_multiget  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_multiget_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_ue with None -> () | Some _v ->
            raise (UnavailableException _v));
          (match result#get_te with None -> () | Some _v ->
            raise (TimedOutException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "multiget failed: unknown result")))
  method multiget_slice keyspace keys column_parent predicate consistency_level = 
    self#send_multiget_slice keyspace keys column_parent predicate consistency_level;
    self#recv_multiget_slice
  method private send_multiget_slice keyspace keys column_parent predicate consistency_level = 
    oprot#writeMessageBegin ("multiget_slice", Protocol.CALL, seqid);
    let args = new multiget_slice_args in
      args#set_keyspace keyspace;
      args#set_keys keys;
      args#set_column_parent column_parent;
      args#set_predicate predicate;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_multiget_slice  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_multiget_slice_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_ue with None -> () | Some _v ->
            raise (UnavailableException _v));
          (match result#get_te with None -> () | Some _v ->
            raise (TimedOutException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "multiget_slice failed: unknown result")))
  method get_count keyspace key column_parent consistency_level = 
    self#send_get_count keyspace key column_parent consistency_level;
    self#recv_get_count
  method private send_get_count keyspace key column_parent consistency_level = 
    oprot#writeMessageBegin ("get_count", Protocol.CALL, seqid);
    let args = new get_count_args in
      args#set_keyspace keyspace;
      args#set_key key;
      args#set_column_parent column_parent;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_get_count  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_get_count_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_ue with None -> () | Some _v ->
            raise (UnavailableException _v));
          (match result#get_te with None -> () | Some _v ->
            raise (TimedOutException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "get_count failed: unknown result")))
  method get_range_slice keyspace column_parent predicate start_key finish_key row_count consistency_level = 
    self#send_get_range_slice keyspace column_parent predicate start_key finish_key row_count consistency_level;
    self#recv_get_range_slice
  method private send_get_range_slice keyspace column_parent predicate start_key finish_key row_count consistency_level = 
    oprot#writeMessageBegin ("get_range_slice", Protocol.CALL, seqid);
    let args = new get_range_slice_args in
      args#set_keyspace keyspace;
      args#set_column_parent column_parent;
      args#set_predicate predicate;
      args#set_start_key start_key;
      args#set_finish_key finish_key;
      args#set_row_count row_count;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_get_range_slice  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_get_range_slice_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_ue with None -> () | Some _v ->
            raise (UnavailableException _v));
          (match result#get_te with None -> () | Some _v ->
            raise (TimedOutException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "get_range_slice failed: unknown result")))
  method get_range_slices keyspace column_parent predicate range consistency_level = 
    self#send_get_range_slices keyspace column_parent predicate range consistency_level;
    self#recv_get_range_slices
  method private send_get_range_slices keyspace column_parent predicate range consistency_level = 
    oprot#writeMessageBegin ("get_range_slices", Protocol.CALL, seqid);
    let args = new get_range_slices_args in
      args#set_keyspace keyspace;
      args#set_column_parent column_parent;
      args#set_predicate predicate;
      args#set_range range;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_get_range_slices  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_get_range_slices_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_ue with None -> () | Some _v ->
            raise (UnavailableException _v));
          (match result#get_te with None -> () | Some _v ->
            raise (TimedOutException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "get_range_slices failed: unknown result")))
  method insert keyspace key column_path value timestamp consistency_level = 
    self#send_insert keyspace key column_path value timestamp consistency_level;
    self#recv_insert
  method private send_insert keyspace key column_path value timestamp consistency_level = 
    oprot#writeMessageBegin ("insert", Protocol.CALL, seqid);
    let args = new insert_args in
      args#set_keyspace keyspace;
      args#set_key key;
      args#set_column_path column_path;
      args#set_value value;
      args#set_timestamp timestamp;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_insert  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_insert_result iprot in
        iprot#readMessageEnd;
        (match result#get_ire with None -> () | Some _v ->
          raise (InvalidRequestException _v));
        (match result#get_ue with None -> () | Some _v ->
          raise (UnavailableException _v));
        (match result#get_te with None -> () | Some _v ->
          raise (TimedOutException _v));
        ()
  method batch_insert keyspace key cfmap consistency_level = 
    self#send_batch_insert keyspace key cfmap consistency_level;
    self#recv_batch_insert
  method private send_batch_insert keyspace key cfmap consistency_level = 
    oprot#writeMessageBegin ("batch_insert", Protocol.CALL, seqid);
    let args = new batch_insert_args in
      args#set_keyspace keyspace;
      args#set_key key;
      args#set_cfmap cfmap;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_batch_insert  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_batch_insert_result iprot in
        iprot#readMessageEnd;
        (match result#get_ire with None -> () | Some _v ->
          raise (InvalidRequestException _v));
        (match result#get_ue with None -> () | Some _v ->
          raise (UnavailableException _v));
        (match result#get_te with None -> () | Some _v ->
          raise (TimedOutException _v));
        ()
  method remove keyspace key column_path timestamp consistency_level = 
    self#send_remove keyspace key column_path timestamp consistency_level;
    self#recv_remove
  method private send_remove keyspace key column_path timestamp consistency_level = 
    oprot#writeMessageBegin ("remove", Protocol.CALL, seqid);
    let args = new remove_args in
      args#set_keyspace keyspace;
      args#set_key key;
      args#set_column_path column_path;
      args#set_timestamp timestamp;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_remove  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_remove_result iprot in
        iprot#readMessageEnd;
        (match result#get_ire with None -> () | Some _v ->
          raise (InvalidRequestException _v));
        (match result#get_ue with None -> () | Some _v ->
          raise (UnavailableException _v));
        (match result#get_te with None -> () | Some _v ->
          raise (TimedOutException _v));
        ()
  method batch_mutate keyspace mutation_map consistency_level = 
    self#send_batch_mutate keyspace mutation_map consistency_level;
    self#recv_batch_mutate
  method private send_batch_mutate keyspace mutation_map consistency_level = 
    oprot#writeMessageBegin ("batch_mutate", Protocol.CALL, seqid);
    let args = new batch_mutate_args in
      args#set_keyspace keyspace;
      args#set_mutation_map mutation_map;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_batch_mutate  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_batch_mutate_result iprot in
        iprot#readMessageEnd;
        (match result#get_ire with None -> () | Some _v ->
          raise (InvalidRequestException _v));
        (match result#get_ue with None -> () | Some _v ->
          raise (UnavailableException _v));
        (match result#get_te with None -> () | Some _v ->
          raise (TimedOutException _v));
        ()
  method get_string_property property = 
    self#send_get_string_property property;
    self#recv_get_string_property
  method private send_get_string_property property = 
    oprot#writeMessageBegin ("get_string_property", Protocol.CALL, seqid);
    let args = new get_string_property_args in
      args#set_property property;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_get_string_property  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_get_string_property_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "get_string_property failed: unknown result")))
  method get_string_list_property property = 
    self#send_get_string_list_property property;
    self#recv_get_string_list_property
  method private send_get_string_list_property property = 
    oprot#writeMessageBegin ("get_string_list_property", Protocol.CALL, seqid);
    let args = new get_string_list_property_args in
      args#set_property property;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_get_string_list_property  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_get_string_list_property_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "get_string_list_property failed: unknown result")))
  method describe_keyspaces  = 
    self#send_describe_keyspaces;
    self#recv_describe_keyspaces
  method private send_describe_keyspaces  = 
    oprot#writeMessageBegin ("describe_keyspaces", Protocol.CALL, seqid);
    let args = new describe_keyspaces_args in
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_describe_keyspaces  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_describe_keyspaces_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "describe_keyspaces failed: unknown result")))
  method describe_cluster_name  = 
    self#send_describe_cluster_name;
    self#recv_describe_cluster_name
  method private send_describe_cluster_name  = 
    oprot#writeMessageBegin ("describe_cluster_name", Protocol.CALL, seqid);
    let args = new describe_cluster_name_args in
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_describe_cluster_name  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_describe_cluster_name_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "describe_cluster_name failed: unknown result")))
  method describe_version  = 
    self#send_describe_version;
    self#recv_describe_version
  method private send_describe_version  = 
    oprot#writeMessageBegin ("describe_version", Protocol.CALL, seqid);
    let args = new describe_version_args in
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_describe_version  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_describe_version_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "describe_version failed: unknown result")))
  method describe_ring keyspace = 
    self#send_describe_ring keyspace;
    self#recv_describe_ring
  method private send_describe_ring keyspace = 
    oprot#writeMessageBegin ("describe_ring", Protocol.CALL, seqid);
    let args = new describe_ring_args in
      args#set_keyspace keyspace;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_describe_ring  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_describe_ring_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "describe_ring failed: unknown result")))
  method describe_keyspace keyspace = 
    self#send_describe_keyspace keyspace;
    self#recv_describe_keyspace
  method private send_describe_keyspace keyspace = 
    oprot#writeMessageBegin ("describe_keyspace", Protocol.CALL, seqid);
    let args = new describe_keyspace_args in
      args#set_keyspace keyspace;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_describe_keyspace  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_describe_keyspace_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_nfe with None -> () | Some _v ->
            raise (NotFoundException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "describe_keyspace failed: unknown result")))
  method describe_splits start_token end_token keys_per_split = 
    self#send_describe_splits start_token end_token keys_per_split;
    self#recv_describe_splits
  method private send_describe_splits start_token end_token keys_per_split = 
    oprot#writeMessageBegin ("describe_splits", Protocol.CALL, seqid);
    let args = new describe_splits_args in
      args#set_start_token start_token;
      args#set_end_token end_token;
      args#set_keys_per_split keys_per_split;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_describe_splits  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_describe_splits_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "describe_splits failed: unknown result")))
end

class processor (handler : iface) =
object (self)
  inherit Processor.t

  val processMap = Hashtbl.create 20
  method process iprot oprot =
    let (name, typ, seqid)  = iprot#readMessageBegin in
      if Hashtbl.mem processMap name then
        (Hashtbl.find processMap name) (seqid, iprot, oprot)
      else (
        iprot#skip(Protocol.T_STRUCT);
        iprot#readMessageEnd;
        let x = Application_Exn.create Application_Exn.UNKNOWN_METHOD ("Unknown function "^name) in
          oprot#writeMessageBegin(name, Protocol.EXCEPTION, seqid);
          x#write oprot;
          oprot#writeMessageEnd;
          oprot#getTransport#flush
      );
      true
  method private process_login (seqid, iprot, oprot) =
    let args = read_login_args iprot in
      iprot#readMessageEnd;
      let result = new login_result in
        (try
          (handler#login args#get_keyspace args#get_auth_request);
        with
          | AuthenticationException authnx -> 
              result#set_authnx authnx
          | AuthorizationException authzx -> 
              result#set_authzx authzx
        );
        oprot#writeMessageBegin ("login", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_get (seqid, iprot, oprot) =
    let args = read_get_args iprot in
      iprot#readMessageEnd;
      let result = new get_result in
        (try
          result#set_success (handler#get args#get_keyspace args#get_key args#get_column_path args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | NotFoundException nfe -> 
              result#set_nfe nfe
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("get", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_get_slice (seqid, iprot, oprot) =
    let args = read_get_slice_args iprot in
      iprot#readMessageEnd;
      let result = new get_slice_result in
        (try
          result#set_success (handler#get_slice args#get_keyspace args#get_key args#get_column_parent args#get_predicate args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("get_slice", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_multiget (seqid, iprot, oprot) =
    let args = read_multiget_args iprot in
      iprot#readMessageEnd;
      let result = new multiget_result in
        (try
          result#set_success (handler#multiget args#get_keyspace args#get_keys args#get_column_path args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("multiget", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_multiget_slice (seqid, iprot, oprot) =
    let args = read_multiget_slice_args iprot in
      iprot#readMessageEnd;
      let result = new multiget_slice_result in
        (try
          result#set_success (handler#multiget_slice args#get_keyspace args#get_keys args#get_column_parent args#get_predicate args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("multiget_slice", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_get_count (seqid, iprot, oprot) =
    let args = read_get_count_args iprot in
      iprot#readMessageEnd;
      let result = new get_count_result in
        (try
          result#set_success (handler#get_count args#get_keyspace args#get_key args#get_column_parent args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("get_count", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_get_range_slice (seqid, iprot, oprot) =
    let args = read_get_range_slice_args iprot in
      iprot#readMessageEnd;
      let result = new get_range_slice_result in
        (try
          result#set_success (handler#get_range_slice args#get_keyspace args#get_column_parent args#get_predicate args#get_start_key args#get_finish_key args#get_row_count args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("get_range_slice", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_get_range_slices (seqid, iprot, oprot) =
    let args = read_get_range_slices_args iprot in
      iprot#readMessageEnd;
      let result = new get_range_slices_result in
        (try
          result#set_success (handler#get_range_slices args#get_keyspace args#get_column_parent args#get_predicate args#get_range args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("get_range_slices", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_insert (seqid, iprot, oprot) =
    let args = read_insert_args iprot in
      iprot#readMessageEnd;
      let result = new insert_result in
        (try
          (handler#insert args#get_keyspace args#get_key args#get_column_path args#get_value args#get_timestamp args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("insert", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_batch_insert (seqid, iprot, oprot) =
    let args = read_batch_insert_args iprot in
      iprot#readMessageEnd;
      let result = new batch_insert_result in
        (try
          (handler#batch_insert args#get_keyspace args#get_key args#get_cfmap args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("batch_insert", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_remove (seqid, iprot, oprot) =
    let args = read_remove_args iprot in
      iprot#readMessageEnd;
      let result = new remove_result in
        (try
          (handler#remove args#get_keyspace args#get_key args#get_column_path args#get_timestamp args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("remove", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_batch_mutate (seqid, iprot, oprot) =
    let args = read_batch_mutate_args iprot in
      iprot#readMessageEnd;
      let result = new batch_mutate_result in
        (try
          (handler#batch_mutate args#get_keyspace args#get_mutation_map args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("batch_mutate", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_get_string_property (seqid, iprot, oprot) =
    let args = read_get_string_property_args iprot in
      iprot#readMessageEnd;
      let result = new get_string_property_result in
        result#set_success (handler#get_string_property args#get_property);
        oprot#writeMessageBegin ("get_string_property", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_get_string_list_property (seqid, iprot, oprot) =
    let args = read_get_string_list_property_args iprot in
      iprot#readMessageEnd;
      let result = new get_string_list_property_result in
        result#set_success (handler#get_string_list_property args#get_property);
        oprot#writeMessageBegin ("get_string_list_property", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_describe_keyspaces (seqid, iprot, oprot) =
    let _ = read_describe_keyspaces_args iprot in
      iprot#readMessageEnd;
      let result = new describe_keyspaces_result in
        result#set_success (handler#describe_keyspaces);
        oprot#writeMessageBegin ("describe_keyspaces", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_describe_cluster_name (seqid, iprot, oprot) =
    let _ = read_describe_cluster_name_args iprot in
      iprot#readMessageEnd;
      let result = new describe_cluster_name_result in
        result#set_success (handler#describe_cluster_name);
        oprot#writeMessageBegin ("describe_cluster_name", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_describe_version (seqid, iprot, oprot) =
    let _ = read_describe_version_args iprot in
      iprot#readMessageEnd;
      let result = new describe_version_result in
        result#set_success (handler#describe_version);
        oprot#writeMessageBegin ("describe_version", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_describe_ring (seqid, iprot, oprot) =
    let args = read_describe_ring_args iprot in
      iprot#readMessageEnd;
      let result = new describe_ring_result in
        result#set_success (handler#describe_ring args#get_keyspace);
        oprot#writeMessageBegin ("describe_ring", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_describe_keyspace (seqid, iprot, oprot) =
    let args = read_describe_keyspace_args iprot in
      iprot#readMessageEnd;
      let result = new describe_keyspace_result in
        (try
          result#set_success (handler#describe_keyspace args#get_keyspace);
        with
          | NotFoundException nfe -> 
              result#set_nfe nfe
        );
        oprot#writeMessageBegin ("describe_keyspace", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_describe_splits (seqid, iprot, oprot) =
    let args = read_describe_splits_args iprot in
      iprot#readMessageEnd;
      let result = new describe_splits_result in
        result#set_success (handler#describe_splits args#get_start_token args#get_end_token args#get_keys_per_split);
        oprot#writeMessageBegin ("describe_splits", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  initializer
    Hashtbl.add processMap "login" self#process_login;
    Hashtbl.add processMap "get" self#process_get;
    Hashtbl.add processMap "get_slice" self#process_get_slice;
    Hashtbl.add processMap "multiget" self#process_multiget;
    Hashtbl.add processMap "multiget_slice" self#process_multiget_slice;
    Hashtbl.add processMap "get_count" self#process_get_count;
    Hashtbl.add processMap "get_range_slice" self#process_get_range_slice;
    Hashtbl.add processMap "get_range_slices" self#process_get_range_slices;
    Hashtbl.add processMap "insert" self#process_insert;
    Hashtbl.add processMap "batch_insert" self#process_batch_insert;
    Hashtbl.add processMap "remove" self#process_remove;
    Hashtbl.add processMap "batch_mutate" self#process_batch_mutate;
    Hashtbl.add processMap "get_string_property" self#process_get_string_property;
    Hashtbl.add processMap "get_string_list_property" self#process_get_string_list_property;
    Hashtbl.add processMap "describe_keyspaces" self#process_describe_keyspaces;
    Hashtbl.add processMap "describe_cluster_name" self#process_describe_cluster_name;
    Hashtbl.add processMap "describe_version" self#process_describe_version;
    Hashtbl.add processMap "describe_ring" self#process_describe_ring;
    Hashtbl.add processMap "describe_keyspace" self#process_describe_keyspace;
    Hashtbl.add processMap "describe_splits" self#process_describe_splits;
end

